<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Web3 on 王离谱的小破站</title>
        <link>https://yearsuns-github-io.vercel.app/tags/web3/</link>
        <description>Recent content in Web3 on 王离谱的小破站</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-CN</language>
        <copyright>王离谱</copyright>
        <lastBuildDate>Sat, 20 Sep 2025 14:59:56 +0800</lastBuildDate><atom:link href="https://yearsuns-github-io.vercel.app/tags/web3/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Solidity中的Gas优化最佳实践</title>
        <link>https://yearsuns-github-io.vercel.app/p/best-practices-for-gas-optimization-in-solidity/</link>
        <pubDate>Sat, 20 Sep 2025 14:59:56 +0800</pubDate>
        
        <guid>https://yearsuns-github-io.vercel.app/p/best-practices-for-gas-optimization-in-solidity/</guid>
        <description>&lt;h2 id=&#34;1-为什么需要-gas-优化&#34;&gt;1. 为什么需要 Gas 优化
&lt;/h2&gt;&lt;p&gt;在以太坊上开发智能合约时，Gas 是一个绕不开的概念。
它既不是单纯的“手续费”，也不仅仅是网络拥堵时的临时成本，而是&lt;strong&gt;对合约设计质量的一种长期约束&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;很多开发者第一次关注 Gas，往往是在以下场景中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;合约部署费用异常高&lt;/li&gt;
&lt;li&gt;用户调用某个函数时频繁 Out of Gas&lt;/li&gt;
&lt;li&gt;同样的功能，不同实现方式的成本差异明显&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些问题通常并非出现在业务逻辑上，而是源于&lt;strong&gt;对 EVM 成本模型缺乏直觉&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;11-gas-的两层含义&#34;&gt;1.1 Gas 的两层含义
&lt;/h3&gt;&lt;p&gt;在讨论优化之前，必须先区分两个容易混淆的概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;gas used&lt;/strong&gt;：执行一笔交易实际消耗的 Gas 单位数量&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;gas price&lt;/strong&gt;：你愿意为每个 Gas 单位支付的价格&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;合约代码本身只能影响 &lt;strong&gt;gas used&lt;/strong&gt;，而无法控制 gas price。&lt;/p&gt;
&lt;p&gt;这意味着：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;网络拥堵会推高 gas price，但不会改变合约的 gas used&lt;/li&gt;
&lt;li&gt;一个设计不佳的合约，在任何网络环境下都会更贵&lt;/li&gt;
&lt;li&gt;在 gas price 较高的时期，低效设计的成本差距会被进一步放大&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，Gas 优化并不是为了“赌网络状况”，而是为了&lt;strong&gt;让每次执行尽可能少地消耗 Gas 单位&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;12-为什么功能正确并不等于成本合理&#34;&gt;1.2 为什么“功能正确”并不等于“成本合理”
&lt;/h3&gt;&lt;p&gt;在传统软件中，只要程序运行正确，性能问题往往可以后置优化。
但在智能合约中，&lt;strong&gt;性能就是成本&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一个合约即使：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没有安全漏洞&lt;/li&gt;
&lt;li&gt;功能完全符合预期&lt;/li&gt;
&lt;li&gt;能通过所有测试&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;仍然可能因为以下原因变得难以使用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;某些函数在链上执行成本过高&lt;/li&gt;
&lt;li&gt;高峰期交易失败率上升&lt;/li&gt;
&lt;li&gt;长期来看，用户为相同功能支付了不必要的费用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这类问题往往不是“写错了代码”，而是&lt;strong&gt;在设计阶段忽略了 Gas 的结构性成本&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;13-gas-优化的目标是什么&#34;&gt;1.3 Gas 优化的目标是什么
&lt;/h3&gt;&lt;p&gt;Gas 优化并不是追求“极致便宜”，而是服务于三个更现实的目标：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;降低长期使用成本&lt;/strong&gt;
高频调用的函数，哪怕节省几百 Gas，长期也会累积显著差异。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;提高交易成功率&lt;/strong&gt;
Gas 消耗越可控，越不容易在复杂路径中触发 Out of Gas。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;提升成本的可预测性&lt;/strong&gt;
让调用者更容易估算所需 Gas，减少不确定性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这也是为什么 Gas 优化通常应当优先作用在：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高频路径&lt;/li&gt;
&lt;li&gt;核心业务逻辑&lt;/li&gt;
&lt;li&gt;用户直接支付成本的函数&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;14-何时不应该过度优化&#34;&gt;1.4 何时不应该过度优化
&lt;/h3&gt;&lt;p&gt;需要明确的是，&lt;strong&gt;Gas 优化有明显的边际递减效应&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;以下情况通常不值得：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为了节省极少量 Gas，引入复杂且晦涩的写法&lt;/li&gt;
&lt;li&gt;在低频、冷路径上做大量微优化&lt;/li&gt;
&lt;li&gt;牺牲安全检查或可读性来换取微小收益&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;合理的原则是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;先写出安全、清晰、可维护的代码，再在“真正昂贵的地方”做优化。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在大多数情况下，理解并避免高成本结构，比记住零散技巧更重要。&lt;/p&gt;
&lt;h3 id=&#34;15-接下来要做什么&#34;&gt;1.5 接下来要做什么
&lt;/h3&gt;&lt;p&gt;接下来的章节将从最基础的问题开始：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;EVM 到底在为什么操作收费&lt;/li&gt;
&lt;li&gt;哪些指令最贵，哪些几乎可以忽略&lt;/li&gt;
&lt;li&gt;为什么 storage 读写是 Gas 成本的核心&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;理解这些原理之后，后续的所有优化实践都会变得自然，而不是依赖记忆规则。&lt;/p&gt;
&lt;h2 id=&#34;2-gas-成本模型&#34;&gt;2. Gas 成本模型
&lt;/h2&gt;&lt;p&gt;在讨论具体的优化技巧之前，有必要先建立一个清晰的成本直觉：&lt;strong&gt;EVM 并不是所有操作都同样昂贵&lt;/strong&gt;。
很多看起来“简单”的 Solidity 代码，之所以 Gas 消耗很高，原因往往不在业务逻辑本身，而在于它触发了高成本的底层指令。&lt;/p&gt;
&lt;p&gt;理解这一节内容的目标只有一个：
&lt;strong&gt;知道哪些操作值得被重点避免或合并，哪些操作几乎可以忽略不计。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;21-什么是指令级收费&#34;&gt;2.1 什么是指令级收费
&lt;/h3&gt;&lt;p&gt;EVM 是一台基于栈的虚拟机。Solidity 代码在部署或调用前，会被编译为一系列 EVM 指令（opcode），例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ADD、SUB、LT 等算术或比较指令&lt;/li&gt;
&lt;li&gt;MLOAD、MSTORE 等内存操作&lt;/li&gt;
&lt;li&gt;SLOAD、SSTORE 等 storage 操作&lt;/li&gt;
&lt;li&gt;CALL、DELEGATECALL 等外部调用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Gas 的计算完全发生在指令层面&lt;/strong&gt;，而不是在 Solidity 语法层面。这意味着：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一行 Solidity 代码可能对应多条指令&lt;/li&gt;
&lt;li&gt;不同写法即使“看起来一样”，编译后的指令序列也可能不同&lt;/li&gt;
&lt;li&gt;Gas 的差异，来自指令类型和数量，而不是代码长度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，Gas 优化本质上是在做一件事：
&lt;strong&gt;让高成本指令执行得更少。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;22-成本层级&#34;&gt;2.2 成本层级
&lt;/h3&gt;&lt;p&gt;从成本角度，可以粗略把 EVM 中的操作分为几个层级（从低到高）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;纯计算（算术、比较、位运算）&lt;/li&gt;
&lt;li&gt;内存（memory）读写&lt;/li&gt;
&lt;li&gt;calldata 读取&lt;/li&gt;
&lt;li&gt;storage 读取（SLOAD）&lt;/li&gt;
&lt;li&gt;storage 写入（SSTORE）&lt;/li&gt;
&lt;li&gt;外部调用与返回大量数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中最重要的一点是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;storage 操作的成本，远高于绝大多数计算操作。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这也是为什么很多 Gas 优化最终都会指向同一个方向：
&lt;strong&gt;减少 storage 的访问次数。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;23-storage-是什么为什么这么贵&#34;&gt;2.3 Storage 是什么，为什么这么贵
&lt;/h3&gt;&lt;p&gt;在 Solidity 中，所有状态变量都会存储在 storage 中。
从 EVM 的视角来看，storage 是一张巨大的键值表：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;key：storage slot 的位置&lt;/li&gt;
&lt;li&gt;value：32 字节的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;storage 的特点是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据是永久存在的&lt;/li&gt;
&lt;li&gt;会影响全局状态树&lt;/li&gt;
&lt;li&gt;所有全节点都必须对其状态达成共识&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每一次 storage 的写入，都意味着对整个系统状态的一次修改，这正是它昂贵的根本原因。&lt;/p&gt;
&lt;h3 id=&#34;24-读取-storage-的真实成本&#34;&gt;2.4 读取 storage 的真实成本
&lt;/h3&gt;&lt;p&gt;当你读取一个状态变量时，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; count;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;编译后的关键指令是 &lt;code&gt;SLOAD&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;自 EIP-2929 之后，SLOAD 的成本分为两种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;冷访问（cold access）&lt;/strong&gt;：
在一次交易中，第一次访问某个 storage slot&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;热访问（warm access）&lt;/strong&gt;：
在同一交易中，再次访问已经读过的 slot&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;直觉上可以理解为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一次读取某个状态变量，EVM 需要“把它带进来”&lt;/li&gt;
&lt;li&gt;后续再读同一个变量，成本会降低，但仍然不便宜&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;即使是热访问，SLOAD 的成本也明显高于内存或算术操作。&lt;/p&gt;
&lt;h3 id=&#34;25-为什么写-storage-是最贵的操作之一&#34;&gt;2.5 为什么写 storage 是最贵的操作之一
&lt;/h3&gt;&lt;p&gt;当你修改一个状态变量时，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; count &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这并不是一次简单的“加一”，而是一个完整的读–改–写过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;SLOAD：读取原始值&lt;/li&gt;
&lt;li&gt;执行加法&lt;/li&gt;
&lt;li&gt;SSTORE：写入新值&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;SSTORE 的成本取决于写入前后的状态，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从 0 写成非 0：成本最高&lt;/li&gt;
&lt;li&gt;从非 0 改为非 0：次之&lt;/li&gt;
&lt;li&gt;从非 0 改为 0：成本较低，并可能获得退款&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些规则的存在，本质上是为了鼓励合约释放不再使用的状态。&lt;/p&gt;
&lt;h3 id=&#34;26-一行-solidity-代码背后的真实执行过程&#34;&gt;2.6 一行 Solidity 代码背后的真实执行过程
&lt;/h3&gt;&lt;p&gt;来看一个非常常见的写法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;count &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;从 Solidity 的角度看，它只是一次简单的自增。
但从 EVM 的角度看，它通常意味着：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一次 SLOAD&lt;/li&gt;
&lt;li&gt;一次加法指令&lt;/li&gt;
&lt;li&gt;一次 SSTORE&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果在同一个函数中多次写出类似代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;count &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;count &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;count &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;你并不是做了三次加法，而是触发了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;3 次 SLOAD&lt;/li&gt;
&lt;li&gt;3 次 SSTORE&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这正是 Gas 消耗迅速放大的原因。&lt;/p&gt;
&lt;h3 id=&#34;27-建立一个关键直觉&#34;&gt;2.7 建立一个关键直觉
&lt;/h3&gt;&lt;p&gt;到这里，可以总结出一个非常重要的直觉：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;算术和逻辑运算通常不是 Gas 的瓶颈&lt;/li&gt;
&lt;li&gt;storage 的读写，才是 Gas 成本的核心来源&lt;/li&gt;
&lt;li&gt;多次重复访问同一个 storage slot，是最常见也最容易忽视的浪费&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一旦你建立起这个直觉，后续关于缓存变量、合并写入、storage packing 等优化方式，都会显得顺理成章，而不是技巧堆砌。&lt;/p&gt;
&lt;h2 id=&#34;3-减少-storage-读写&#34;&gt;3. 减少 Storage 读写
&lt;/h2&gt;&lt;p&gt;在理解了 EVM 的成本模型之后，Gas 优化的优先级其实已经非常清晰：
&lt;strong&gt;只要能减少 storage 的读写次数，几乎一定能获得显著的 Gas 收益。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所有的gas优化技巧大多围绕一个核心目标展开：
&lt;strong&gt;让 SLOAD 和 SSTORE 尽可能少地执行。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;31-为什么-storage-优化具有最高性价比&#34;&gt;3.1 为什么 Storage 优化具有最高性价比
&lt;/h3&gt;&lt;p&gt;前面我们讨论过：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;算术运算非常便宜&lt;/li&gt;
&lt;li&gt;内存操作成本中等&lt;/li&gt;
&lt;li&gt;storage 写入是最昂贵的操作之一&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这意味着：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;省掉一次 SSTORE，往往比优化十几行计算代码更有价值&lt;/li&gt;
&lt;li&gt;优化 storage 访问，收益通常是数量级上的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，在实际工程中，Gas 优化的顺序应当是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先看是否能减少 storage 读写&lt;/li&gt;
&lt;li&gt;再考虑循环、参数、位运算等次级优化&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;32-缓存多次读取把多次-sload-变成一次&#34;&gt;3.2 缓存多次读取：把多次 SLOAD 变成一次
&lt;/h3&gt;&lt;p&gt;最常见、也最容易忽视的低效写法，是在同一个函数中多次读取同一个状态变量。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;increment&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    require(count &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; max, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;too large&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; count &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    emit Updated(count);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在这段代码中，&lt;code&gt;count&lt;/code&gt; 实际上被读取了多次：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;require&lt;/code&gt; 中读取一次&lt;/li&gt;
&lt;li&gt;自增时读取一次&lt;/li&gt;
&lt;li&gt;事件参数中再读取一次&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更高效的写法是先将其缓存到局部变量：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;increment&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; count;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    require(c &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; max, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;too large&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; c &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; c;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    emit Updated(c);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样做的结果是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;storage 只读一次&lt;/li&gt;
&lt;li&gt;storage 只写一次&lt;/li&gt;
&lt;li&gt;后续操作都在内存中完成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种改动几乎不影响可读性，却能显著减少 Gas。&lt;/p&gt;
&lt;h3 id=&#34;33-合并多次写入避免重复的-sstore&#34;&gt;3.3 合并多次写入：避免重复的 SSTORE
&lt;/h3&gt;&lt;p&gt;另一类常见问题，是在同一个函数中多次写入同一个状态变量。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;update&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; x) &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    value &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; x;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; threshold) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        value &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; bonus;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;表面上看，这段代码逻辑清晰，但它可能会对 &lt;code&gt;value&lt;/code&gt; 执行多次 SSTORE。&lt;/p&gt;
&lt;p&gt;更合理的写法是先在内存中完成所有计算：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;update&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; x) &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; v &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; value;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    v &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; x;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; threshold) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        v &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; bonus;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; v;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;原则可以总结为一句话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;不要在逻辑分支中反复写 storage，先算清楚，再一次性写回。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;34-循环中的-storage-读写陷阱&#34;&gt;3.4 循环中的 storage 读写陷阱
&lt;/h3&gt;&lt;p&gt;循环是 storage 读写最容易被放大的地方。&lt;/p&gt;
&lt;p&gt;考虑下面的写法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sum&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;[] calldata arr) &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; arr.length; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        total &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; arr[i];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在这个循环中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每次迭代都会读取并写入 &lt;code&gt;total&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果数组长度为 n，就会触发 n 次 SLOAD 和 n 次 SSTORE&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更高效的写法是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sum&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;[] calldata arr) &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; t &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; total;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; arr.length;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; len; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        t &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; arr[i];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    total &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; t;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这种写法的改动非常小，但对 Gas 的影响会随着数组长度线性放大。&lt;/p&gt;
&lt;h3 id=&#34;35-避免在循环中写-storage-的设计思路&#34;&gt;3.5 避免在循环中写 storage 的设计思路
&lt;/h3&gt;&lt;p&gt;在设计合约时，应当尽量避免以下模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在不受限的循环中写 storage&lt;/li&gt;
&lt;li&gt;每次迭代都更新状态&lt;/li&gt;
&lt;li&gt;循环次数由外部输入完全控制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更好的替代方案包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先在内存中计算，再一次性写回&lt;/li&gt;
&lt;li&gt;设计批处理接口，但限制每次调用的最大数量&lt;/li&gt;
&lt;li&gt;将复杂计算移到链下，只在链上验证结果&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些并不是“写法技巧”，而是&lt;strong&gt;设计阶段就应当考虑的结构性问题&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;36-用-mapping-替代数组&#34;&gt;3.6 用 mapping 替代数组
&lt;/h3&gt;&lt;p&gt;在合约里，“数组还是 mapping”并不只是编码风格差异，而是成本模型差异：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组常见操作（查找、去重、删除某个元素）通常需要遍历，成本是 &lt;strong&gt;O(n)&lt;/strong&gt;，并且容易触发不受限循环&lt;/li&gt;
&lt;li&gt;mapping 的读写是按 key 直接定位，成本接近 &lt;strong&gt;O(1)&lt;/strong&gt;，更稳定、更可控&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;场景-1成员判断contains&#34;&gt;场景 1：成员判断（contains）
&lt;/h4&gt;&lt;p&gt;不推荐：用数组存储成员并在链上查找&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;address&lt;/span&gt;[] &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; members;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;isMember&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;address&lt;/span&gt; a) &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;view&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;returns&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; members.length; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (members[i] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; a) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每次判断都要遍历&lt;/li&gt;
&lt;li&gt;成员越多越贵&lt;/li&gt;
&lt;li&gt;最坏情况下可能 Out of Gas&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;推荐：用 mapping 做存在性判断&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mapping&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;address&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; isMember;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;addMember&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;address&lt;/span&gt; a) &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    isMember[a] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;removeMember&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;address&lt;/span&gt; a) &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    isMember[a] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;判断存在性是 O(1)&lt;/li&gt;
&lt;li&gt;成本可预测&lt;/li&gt;
&lt;li&gt;不需要循环&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;场景-2需要可枚举的集合既要-o1-判断又要列出所有成员&#34;&gt;场景 2：需要“可枚举”的集合（既要 O(1) 判断，又要列出所有成员）
&lt;/h4&gt;&lt;p&gt;很多业务既需要 &lt;code&gt;isMember[a]&lt;/code&gt; 这种 O(1) 判断，也需要枚举所有成员（给前端展示）。这时可以用“mapping + 数组”组合结构：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mapping&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;address&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; isMember;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;address&lt;/span&gt;[] &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; memberList;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mapping&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;address&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; indexPlusOne; &lt;span style=&#34;color:#75715e&#34;&gt;// 下标+1，0 表示不存在
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;addMember&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;address&lt;/span&gt; a) &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (indexPlusOne[a] &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 已存在
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    isMember[a] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    memberList.push(a);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    indexPlusOne[a] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; memberList.length; &lt;span style=&#34;color:#75715e&#34;&gt;// 存的是 index+1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;removeMember&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;address&lt;/span&gt; a) &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; idxPlusOne &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; indexPlusOne[a];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (idxPlusOne &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; idx &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; idxPlusOne &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; memberList.length &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (idx &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; last) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;address&lt;/span&gt; lastAddr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; memberList[last];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        memberList[idx] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; lastAddr;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        indexPlusOne[lastAddr] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; idx &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    memberList.pop();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    indexPlusOne[a] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    isMember[a] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mapping&lt;/code&gt; 负责 O(1) 判断与定位&lt;/li&gt;
&lt;li&gt;&lt;code&gt;array&lt;/code&gt; 负责枚举&lt;/li&gt;
&lt;li&gt;删除用 swap-and-pop，避免 O(n) 移动&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这种结构会引入额外存储（索引 mapping），但换来的是操作复杂度和成本可控，通常非常值得&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;什么时候不该用数组&#34;&gt;什么时候不该用数组
&lt;/h4&gt;&lt;p&gt;如果你发现你在数组上做这些操作，基本就该考虑 mapping：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;contains/查找&lt;/li&gt;
&lt;li&gt;去重&lt;/li&gt;
&lt;li&gt;删除指定元素&lt;/li&gt;
&lt;li&gt;防重复写入&lt;/li&gt;
&lt;li&gt;任何“长度可能增长且由用户输入驱动”的遍历逻辑&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一句话总结：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;数组适合“顺序数据”和“按下标访问”，mapping 适合“按 key 查询/去重/存在性判断”。当你需要查找或删除时，mapping 往往更省 Gas，也更安全。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;4-数据位置与函数接口设计&#34;&gt;4. 数据位置与函数接口设计
&lt;/h2&gt;&lt;p&gt;在减少了不必要的 storage 读写之后，下一类非常值得关注的优化点是：
&lt;strong&gt;函数的接口设计，包括参数的数据位置（data location）和函数的可见性（visibility）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这些选择通常不会改变业务逻辑，但却会直接影响：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是否发生不必要的数据拷贝&lt;/li&gt;
&lt;li&gt;是否触发额外的编码 / 解码&lt;/li&gt;
&lt;li&gt;函数调用在 EVM 中走的是哪条路径&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;合理的接口设计，往往是“低风险、高收益”的 Gas 优化。&lt;/p&gt;
&lt;h3 id=&#34;41-三种数据位置的成本直觉&#34;&gt;4.1 三种数据位置的成本直觉
&lt;/h3&gt;&lt;p&gt;在 Solidity 中，引用类型（数组、struct、string、bytes）必须显式或隐式指定数据位置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;calldata&lt;/strong&gt;：只读，位于调用数据中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;memory&lt;/strong&gt;：可读写，函数执行期间存在&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;storage&lt;/strong&gt;：永久存储在链上&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从成本角度，可以建立一个简单直觉：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;calldata 读取：便宜&lt;/li&gt;
&lt;li&gt;memory 读写：中等&lt;/li&gt;
&lt;li&gt;storage 读写：昂贵&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，一个基本原则是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;能用 calldata 就不要用 memory，能用 memory 就不要用 storage。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;42-external-函数与-calldata&#34;&gt;4.2 external 函数与 calldata
&lt;/h3&gt;&lt;p&gt;对于只从外部调用的函数，最推荐的写法是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;process&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;[] calldata data) &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 使用 data
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;原因在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;external 函数的参数天然来自 calldata&lt;/li&gt;
&lt;li&gt;使用 calldata 不需要将参数复制到 memory&lt;/li&gt;
&lt;li&gt;对于大数组或复杂结构，拷贝成本差异非常明显&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相反，如果写成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;process&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;[] &lt;span style=&#34;color:#66d9ef&#34;&gt;memory&lt;/span&gt; data) &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 使用 data
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;即使你并未修改 &lt;code&gt;data&lt;/code&gt;，编译器仍然需要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将 calldata 中的数据完整复制到 memory&lt;/li&gt;
&lt;li&gt;为此支付额外的 Gas 成本&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;43-什么时候必须使用-memory&#34;&gt;4.3 什么时候必须使用 memory
&lt;/h3&gt;&lt;p&gt;calldata 的限制也非常明确：&lt;strong&gt;只读&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一旦你的函数需要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;修改数组内容&lt;/li&gt;
&lt;li&gt;排序&lt;/li&gt;
&lt;li&gt;去重&lt;/li&gt;
&lt;li&gt;动态构造新数组&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;就必须使用 memory。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;normalize&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;[] calldata data) &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;returns&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;[] &lt;span style=&#34;color:#66d9ef&#34;&gt;memory&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;[] &lt;span style=&#34;color:#66d9ef&#34;&gt;memory&lt;/span&gt; result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;[](data.length);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; data.length; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        result[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; data[i] &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; result;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里的关键点是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入参数使用 calldata（避免拷贝）&lt;/li&gt;
&lt;li&gt;输出结果使用 memory（必须可写）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是一种非常常见、也非常合理的组合。&lt;/p&gt;
&lt;h3 id=&#34;44-函数可见性的-gas-含义&#34;&gt;4.4 函数可见性的 Gas 含义
&lt;/h3&gt;&lt;p&gt;函数可见性不仅影响可调用范围，也会影响 Gas。&lt;/p&gt;
&lt;p&gt;可以从以下角度理解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;external&lt;/strong&gt;：直接从 calldata 读取参数，最省 Gas&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;public&lt;/strong&gt;：参数会被复制到 memory，成本更高&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;internal&lt;/strong&gt;：编译期内联或直接跳转，最便宜&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;private&lt;/strong&gt;：与 internal 类似，但仅限当前合约&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个重要结论是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;public 并不是“内外通用的最优选择”。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;45-external-入口--internal-实现&#34;&gt;4.5 external 入口 + internal 实现
&lt;/h3&gt;&lt;p&gt;在实际工程中，最推荐的模式是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对外暴露的函数使用 &lt;code&gt;external&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将核心逻辑提取到 &lt;code&gt;internal&lt;/code&gt; 函数中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;update&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; x) &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    _update(x);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;_update&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; x) &lt;span style=&#34;color:#66d9ef&#34;&gt;internal&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 核心逻辑
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样做的好处包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;external 函数使用 calldata，参数拷贝最少&lt;/li&gt;
&lt;li&gt;internal 函数调用成本极低&lt;/li&gt;
&lt;li&gt;内部调用和外部调用共享同一份逻辑&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种模式几乎没有副作用，却能避免很多隐性的 Gas 浪费。&lt;/p&gt;
&lt;h3 id=&#34;46-为什么要避免-this-调用当前合约&#34;&gt;4.6 为什么要避免 this 调用当前合约
&lt;/h3&gt;&lt;p&gt;一个非常隐蔽但代价很高的写法是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;this.update(x);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;即使 &lt;code&gt;update&lt;/code&gt; 定义在当前合约中，这种写法也会：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;触发一次完整的 external call&lt;/li&gt;
&lt;li&gt;进行 ABI 编码和解码&lt;/li&gt;
&lt;li&gt;走 CALL 指令路径&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这意味着：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更高的 Gas 成本&lt;/li&gt;
&lt;li&gt;更复杂的执行路径&lt;/li&gt;
&lt;li&gt;潜在的可重入风险&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你发现自己需要 &lt;code&gt;this.foo()&lt;/code&gt;，通常意味着：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;逻辑划分不合理&lt;/li&gt;
&lt;li&gt;internal 函数抽象不充分&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;正确的重构方式，是将逻辑提取为 internal 函数，并在 external 函数中调用它。&lt;/p&gt;
&lt;h3 id=&#34;47-一个对比示例&#34;&gt;4.7 一个对比示例
&lt;/h3&gt;&lt;p&gt;对比下面两种实现：&lt;/p&gt;
&lt;p&gt;不推荐的写法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;foo&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;[] &lt;span style=&#34;color:#66d9ef&#34;&gt;memory&lt;/span&gt; data) &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 使用 data
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bar&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;[] &lt;span style=&#34;color:#66d9ef&#34;&gt;memory&lt;/span&gt; data) &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    foo(data);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;推荐的写法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;foo&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;[] calldata data) &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    _foo(data);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bar&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;[] calldata data) &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    _foo(data);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;_foo&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;[] calldata data) &lt;span style=&#34;color:#66d9ef&#34;&gt;internal&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 使用 data
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;第二种写法在以下方面更优：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参数不被重复拷贝&lt;/li&gt;
&lt;li&gt;逻辑集中，避免重复&lt;/li&gt;
&lt;li&gt;internal 调用成本更低&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;5-状态布局设计storage-packing&#34;&gt;5. 状态布局设计：Storage Packing
&lt;/h2&gt;&lt;p&gt;在前几节中，我们讨论的优化大多发生在“如何使用状态变量”。
这一节关注一个更偏设计层面的问题：&lt;strong&gt;状态变量是如何被放进 storage 的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;很多 Gas 浪费并不是来自频繁读写，而是来自&lt;strong&gt;状态布局本身不合理&lt;/strong&gt;，导致：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用了更多的 storage slot&lt;/li&gt;
&lt;li&gt;每次读写都触发更多的 SLOAD / SSTORE&lt;/li&gt;
&lt;li&gt;合约长期运行成本被放大&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;51-storage-slot-与-32-字节对齐&#34;&gt;5.1 Storage slot 与 32 字节对齐
&lt;/h3&gt;&lt;p&gt;从 EVM 的角度看，storage 是以 &lt;strong&gt;32 字节（256 bit）为一个 slot&lt;/strong&gt; 来组织的。&lt;/p&gt;
&lt;p&gt;Solidity 的状态变量会按照声明顺序，依次放入这些 slot 中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果变量大小小于 32 字节，编译器会尝试将多个变量放进同一个 slot&lt;/li&gt;
&lt;li&gt;如果当前 slot 剩余空间不足，变量会被放到下一个 slot&lt;/li&gt;
&lt;li&gt;一旦一个 slot 被填满，就不会再继续向其中塞变量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这一机制被称为 &lt;strong&gt;storage packing&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;52-一个最基础的打包示例&#34;&gt;5.2 一个最基础的打包示例
&lt;/h3&gt;&lt;p&gt;考虑下面的变量声明：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;uint128&lt;/span&gt; a;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;uint128&lt;/span&gt; b;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; c;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;每个 &lt;code&gt;uint128&lt;/code&gt; 占 16 字节，因此这两个变量可以共享同一个 storage slot。&lt;code&gt;uint256&lt;/code&gt; 独占 16 字节，因此这三个变量总共使用了 2 个 slot。&lt;/p&gt;
&lt;p&gt;但如果顺序稍有不同：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;uint128&lt;/span&gt; a;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; c;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;uint128&lt;/span&gt; b;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;那么：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a&lt;/code&gt; 占用 slot0 的前 16 字节&lt;/li&gt;
&lt;li&gt;&lt;code&gt;c&lt;/code&gt; 独占 slot1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;b&lt;/code&gt; 由于 slot0 剩余空间不足，只能进入 slot2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在这三个变量总共使用了 3 个 slot。仅仅因为声明顺序不同，就多消耗了一个 slot。&lt;/p&gt;
&lt;h3 id=&#34;53-为什么-slot-数量直接影响-gas&#34;&gt;5.3 为什么 slot 数量直接影响 Gas
&lt;/h3&gt;&lt;p&gt;每一个额外的 storage slot，都会带来长期成本：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读取更多 slot → 更多 SLOAD&lt;/li&gt;
&lt;li&gt;写入更多 slot → 更多 SSTORE&lt;/li&gt;
&lt;li&gt;结构体整体读写成本上升&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;尤其是在：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高频调用函数&lt;/li&gt;
&lt;li&gt;需要整体复制或更新 struct 的场景中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;slot 数量的差异，会直接体现在 Gas 消耗上。&lt;/p&gt;
&lt;h3 id=&#34;54-小类型并不总是越小越好&#34;&gt;5.4 小类型并不总是“越小越好”
&lt;/h3&gt;&lt;p&gt;需要注意的是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择小于 256 bit 的类型，并不一定自动省 Gas&lt;/li&gt;
&lt;li&gt;只有在&lt;strong&gt;成功打包&lt;/strong&gt;的前提下，小类型才有意义&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;uint128&lt;/span&gt; a;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; b;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;即使 &lt;code&gt;a&lt;/code&gt; 是 &lt;code&gt;uint128&lt;/code&gt;，它依然会独占一个 slot，因为后面紧跟着一个 &lt;code&gt;uint256&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;因此，类型选择和声明顺序应当结合考虑，而不是孤立决策。&lt;/p&gt;
&lt;h3 id=&#34;55-什么时候应该关心-storage-packing&#34;&gt;5.5 什么时候应该关心 storage packing
&lt;/h3&gt;&lt;p&gt;并不是所有合约都需要精细打包。
storage packing 不仅适用于合约级变量，也同样适用于 struct。&lt;/p&gt;
&lt;p&gt;storage packing 尤其适合以下场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;状态变量数量较多&lt;/li&gt;
&lt;li&gt;使用大量 struct&lt;/li&gt;
&lt;li&gt;状态会被频繁读写&lt;/li&gt;
&lt;li&gt;合约生命周期较长&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而在状态极少、只部署一次、很少交互的合约中，过度调整字段顺序的收益可能有限。&lt;/p&gt;
&lt;h2 id=&#34;6-循环与批处理&#34;&gt;6. 循环与批处理
&lt;/h2&gt;&lt;p&gt;在前几节中，我们已经看到：
storage 读写本身很贵，而&lt;strong&gt;循环会把这种成本按次数放大&lt;/strong&gt;。
因此，循环往往不是 Gas 的来源，但却是 Gas 的“放大器”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不是所有循环都是问题，但不受控制的循环几乎一定会成为问题。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;61-为什么循环容易成为-gas-黑洞&#34;&gt;6.1 为什么循环容易成为 Gas 黑洞
&lt;/h3&gt;&lt;p&gt;从 EVM 的角度看，循环并不是一个特殊结构，它只是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重复执行一段指令序列&lt;/li&gt;
&lt;li&gt;每一次迭代都会完整支付指令成本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果循环体中包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;storage 读写&lt;/li&gt;
&lt;li&gt;昂贵的计算&lt;/li&gt;
&lt;li&gt;外部调用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么 Gas 消耗就会与循环次数线性增长。&lt;/p&gt;
&lt;p&gt;当循环次数由外部输入控制时，风险尤其明显。&lt;/p&gt;
&lt;h3 id=&#34;62-缓存数组-length-与中间结果&#34;&gt;6.2 缓存数组 length 与中间结果
&lt;/h3&gt;&lt;p&gt;一个非常常见、也非常基础的优化点，是缓存数组的长度。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sum&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;[] calldata arr) &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; arr.length; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        s &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; arr[i];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;虽然 &lt;code&gt;arr.length&lt;/code&gt; 看起来很轻量，但在每次循环判断中，都会被重新读取。&lt;/p&gt;
&lt;p&gt;更好的写法是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sum&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;[] calldata arr) &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; arr.length;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; len; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        s &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; arr[i];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这类优化在单次调用中节省的 Gas 不多，但在高频或大数组场景下，会逐渐显现差异。&lt;/p&gt;
&lt;h3 id=&#34;63-避免在循环中直接写-storage&#34;&gt;6.3 避免在循环中直接写 storage
&lt;/h3&gt;&lt;p&gt;如前几节所强调的，在循环中写 storage 是非常昂贵的。&lt;/p&gt;
&lt;p&gt;原则可以总结为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;循环中尽量只做内存计算，把 storage 写入放到循环之外。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;64-在安全前提下使用-unchecked&#34;&gt;6.4 在安全前提下使用 unchecked
&lt;/h3&gt;&lt;p&gt;从 Solidity 0.8 开始，整数运算默认包含溢出检查。
这对安全非常有价值，但在某些场景中，也会带来不必要的 Gas 开销。&lt;/p&gt;
&lt;p&gt;一个典型场景是 for 循环的计数器：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; len; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果你能明确保证：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt; 不会接近 &lt;code&gt;type(uint256).max&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;循环条件有明确上界&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么可以使用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; len; ) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;unchecked&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这类优化的收益不如减少 storage 读写明显，但在大循环中仍然是可测量的。&lt;/p&gt;
&lt;h3 id=&#34;65-避免无上限循环&#34;&gt;6.5 避免无上限循环
&lt;/h3&gt;&lt;p&gt;在设计合约接口时，应当尽量避免：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;循环次数完全由用户输入决定&lt;/li&gt;
&lt;li&gt;没有任何上界或约束&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;process&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;[] calldata items) &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; items.length; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果 &lt;code&gt;items.length&lt;/code&gt; 没有被限制，调用者可以传入极大的数组，导致：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用失败（Out of Gas）&lt;/li&gt;
&lt;li&gt;合约在某些情况下“不可用”&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;常见的改进方式包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;明确限制最大长度&lt;/li&gt;
&lt;li&gt;将操作拆分为多次调用&lt;/li&gt;
&lt;li&gt;提供分页或游标式接口&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;66-批处理batch设计的取舍&#34;&gt;6.6 批处理（Batch）设计的取舍
&lt;/h3&gt;&lt;p&gt;批处理是减少交易次数、摊薄固定成本的常见手段，但它并不是没有代价。&lt;/p&gt;
&lt;p&gt;优点包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减少外部调用次数&lt;/li&gt;
&lt;li&gt;摊薄函数入口和校验成本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;风险包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单笔交易 Gas 不可控&lt;/li&gt;
&lt;li&gt;更容易触发 OOG&lt;/li&gt;
&lt;li&gt;更难估算 Gas 上限&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，批处理接口通常应当具备：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;明确的单次处理上限&lt;/li&gt;
&lt;li&gt;可预期的最坏情况成本&lt;/li&gt;
&lt;li&gt;清晰的失败行为&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;67-一个批处理示例&#34;&gt;6.7 一个批处理示例
&lt;/h3&gt;&lt;p&gt;不推荐的写法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;batchUpdate&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;[] calldata ids) &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; ids.length; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        update(ids[i]);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;改进后的写法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;constant&lt;/span&gt; MAX_BATCH &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;batchUpdate&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;[] calldata ids) &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ids.length;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    require(len &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; MAX_BATCH, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;too many items&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; len; ) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        _update(ids[i]);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;unchecked&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里的关键不是“省多少 Gas”，而是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;成本可控&lt;/li&gt;
&lt;li&gt;行为可预测&lt;/li&gt;
&lt;li&gt;接口对调用者友好&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;7-错误处理与字节码体积优化&#34;&gt;7. 错误处理与字节码体积优化
&lt;/h2&gt;&lt;p&gt;在讨论 Gas 优化时，很多人会把注意力集中在“成功执行路径”上，而忽略了&lt;strong&gt;失败路径和合约本身体积&lt;/strong&gt;的成本。
实际上，错误处理方式不仅影响交易失败时的 Gas 消耗，也会影响：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;合约部署成本&lt;/li&gt;
&lt;li&gt;每次调用的基础开销&lt;/li&gt;
&lt;li&gt;字节码大小与可维护性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这一节将聚焦一个非常具体但收益稳定的优化点：&lt;strong&gt;如何更高效地处理错误和回滚。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;71-revert-本身并不是免费的&#34;&gt;7.1 revert 本身并不是“免费”的
&lt;/h3&gt;&lt;p&gt;当一笔交易 &lt;code&gt;revert&lt;/code&gt; 时，状态会被回滚，但 Gas 并不会全部返还。
尤其是以下几类成本：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;已执行指令消耗的 Gas&lt;/li&gt;
&lt;li&gt;错误信息本身携带的数据&lt;/li&gt;
&lt;li&gt;与 ABI 编码相关的开销&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，一个频繁触发的校验逻辑，其失败路径的成本，同样值得认真对待。&lt;/p&gt;
&lt;h3 id=&#34;72-requirestring-的真实代价&#34;&gt;7.2 require(string) 的真实代价
&lt;/h3&gt;&lt;p&gt;最传统、也最常见的错误处理方式是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;require(msg.sender &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; owner, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Not owner&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这种写法的问题不在于功能，而在于成本：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;错误字符串会被编译进合约字节码&lt;/li&gt;
&lt;li&gt;每一次 revert 都需要返回这段字符串数据&lt;/li&gt;
&lt;li&gt;字符串越长，部署成本和失败成本越高&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在复杂合约中，大量使用 &lt;code&gt;require(string)&lt;/code&gt; 会显著增加 bytecode 体积。&lt;/p&gt;
&lt;h3 id=&#34;73-使用-custom-error-的动机&#34;&gt;7.3 使用 custom error 的动机
&lt;/h3&gt;&lt;p&gt;从 Solidity 0.8.4 开始，引入了 &lt;strong&gt;custom error&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;error NotOwner();
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;并配合：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (msg.sender &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; owner) revert NotOwner();
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这种写法的优势在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不需要存储字符串&lt;/li&gt;
&lt;li&gt;错误标识以 selector 形式存在&lt;/li&gt;
&lt;li&gt;revert 时返回的数据更小&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从成本角度看，它同时降低了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;部署 Gas&lt;/li&gt;
&lt;li&gt;revert 路径的 Gas&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;74-对比示例&#34;&gt;7.4 对比示例
&lt;/h3&gt;&lt;p&gt;考虑一个最简单的权限校验。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;require(string)&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;withdraw&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    require(msg.sender &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; owner, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Not owner&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用 custom error：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;error NotOwner();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;withdraw&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (msg.sender &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; owner) revert NotOwner();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;两种写法在成功路径上的 Gas 几乎相同，但在以下方面存在差异：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;合约部署体积&lt;/li&gt;
&lt;li&gt;revert 时的 Gas 消耗&lt;/li&gt;
&lt;li&gt;错误信息的编码方式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在高频调用或复杂合约中，这种差异会逐渐积累。&lt;/p&gt;
&lt;h3 id=&#34;75-错误信息该写多详细&#34;&gt;7.5 错误信息该写多“详细”
&lt;/h3&gt;&lt;p&gt;一个常见误区是：
&lt;strong&gt;错误信息越详细越好。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从链上执行的角度看，这并不总是成立。&lt;/p&gt;
&lt;p&gt;更合理的分工是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;链上：提供简洁、结构化的错误标识&lt;/li&gt;
&lt;li&gt;链下：通过文档或映射表解释错误含义&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;custom error 非常适合这种模式，因为它：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本身就是结构化的&lt;/li&gt;
&lt;li&gt;可携带参数&lt;/li&gt;
&lt;li&gt;便于前端或 SDK 解码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;error InsufficientBalance(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; available, &lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; required);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;76-字节码体积为什么值得关注&#34;&gt;7.6 字节码体积为什么值得关注
&lt;/h3&gt;&lt;p&gt;合约字节码体积会直接影响：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;部署成本&lt;/li&gt;
&lt;li&gt;部署是否成功（有大小上限）&lt;/li&gt;
&lt;li&gt;每次调用的基础 Gas（代码越大，加载成本越高）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下写法都会增加字节码体积：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大量字符串常量&lt;/li&gt;
&lt;li&gt;重复的逻辑分支&lt;/li&gt;
&lt;li&gt;冗长的错误信息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，Gas 优化不仅是“执行时优化”，也包括&lt;strong&gt;部署时优化&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;77-错误处理与可读性的平衡&#34;&gt;7.7 错误处理与可读性的平衡
&lt;/h3&gt;&lt;p&gt;需要强调的是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;custom error 并不是为了“压缩到极限”&lt;/li&gt;
&lt;li&gt;也不意味着完全放弃可读性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;合理的做法是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对外暴露的核心接口：使用清晰的 custom error&lt;/li&gt;
&lt;li&gt;内部断言或开发阶段检查：适度使用 require&lt;/li&gt;
&lt;li&gt;避免在错误信息中携带冗长文本&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;8-事件与返回值设计&#34;&gt;8. 事件与返回值设计
&lt;/h2&gt;&lt;p&gt;在智能合约中，事件（event）和函数返回值常被用于“对外提供信息”。
但如果设计不当，它们很容易成为 &lt;strong&gt;隐性的 Gas 消耗来源&lt;/strong&gt;，尤其是在高频调用或数据量较大的场景中。&lt;/p&gt;
&lt;p&gt;这一节的核心观点可以先给出：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;区块链擅长做状态验证，不擅长做数据查询。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;理解这一点，有助于你在事件和返回值设计上做出更经济的选择。&lt;/p&gt;
&lt;h3 id=&#34;81-事件的作用边界&#34;&gt;8.1 事件的作用边界
&lt;/h3&gt;&lt;p&gt;事件的主要用途是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;供链下系统监听和索引&lt;/li&gt;
&lt;li&gt;记录重要的状态变化&lt;/li&gt;
&lt;li&gt;作为审计和分析的依据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事件&lt;strong&gt;不会&lt;/strong&gt;被合约在链上读取，也不会影响后续执行逻辑。
因此，从合约执行的角度看，事件是“写一次、只给链下用”的数据。&lt;/p&gt;
&lt;p&gt;这意味着一个设计原则：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;事件应当服务于链下，而不是替代链上状态查询。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;82-事件的-gas-成本构成&#34;&gt;8.2 事件的 Gas 成本构成
&lt;/h3&gt;&lt;p&gt;一个事件的 Gas 成本主要由两部分组成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;topics&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;包括事件签名&lt;/li&gt;
&lt;li&gt;以及最多 3 个 &lt;code&gt;indexed&lt;/code&gt; 参数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;data&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非 indexed 的参数&lt;/li&gt;
&lt;li&gt;按字节数计费&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;直觉上可以这样理解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;indexed&lt;/code&gt; 参数更利于过滤和查询&lt;/li&gt;
&lt;li&gt;但 &lt;code&gt;indexed&lt;/code&gt; 并不是“免费”的&lt;/li&gt;
&lt;li&gt;data 部分越大，Gas 成本越高&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，事件设计需要在&lt;strong&gt;可查询性&lt;/strong&gt;和&lt;strong&gt;成本&lt;/strong&gt;之间取舍。&lt;/p&gt;
&lt;h3 id=&#34;83-indexed-的合理使用&#34;&gt;8.3 indexed 的合理使用
&lt;/h3&gt;&lt;p&gt;考虑一个转账事件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;event&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Transfer&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;address&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;indexed&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;from&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;address&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;indexed&lt;/span&gt; to, &lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; amount);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这种设计是合理的，因为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;from&lt;/code&gt; 和 &lt;code&gt;to&lt;/code&gt; 是最常用的查询条件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;amount&lt;/code&gt; 通常不用于过滤&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但如果写成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;event&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Transfer&lt;/span&gt;(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;address&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;indexed&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;from&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;address&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;indexed&lt;/span&gt; to,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;indexed&lt;/span&gt; amount
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;那么：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查询能力并没有显著提升&lt;/li&gt;
&lt;li&gt;Gas 成本却增加了&lt;/li&gt;
&lt;li&gt;而且 indexed 参数最多只能有 3 个&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个实用原则是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;只为“经常作为过滤条件”的字段加 indexed。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;84-避免在事件中携带大数据&#34;&gt;8.4 避免在事件中携带大数据
&lt;/h3&gt;&lt;p&gt;一个常见但代价很高的做法，是在事件中携带大量数据：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;event&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;DataUpdated&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;[] values);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这种设计的问题包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组会被完整写入日志&lt;/li&gt;
&lt;li&gt;Gas 成本随数据量线性增长&lt;/li&gt;
&lt;li&gt;链上执行成本和链下存储成本都很高&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更合理的替代方案是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只记录关键信息（如 ID、hash、计数）&lt;/li&gt;
&lt;li&gt;将完整数据存储在链下&lt;/li&gt;
&lt;li&gt;通过 hash 或索引进行关联&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;event&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;DataUpdated&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;bytes32&lt;/span&gt; dataHash);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;85-避免在链上返回大数组&#34;&gt;8.5 避免在链上返回大数组
&lt;/h3&gt;&lt;p&gt;在 Solidity 中，函数返回数组或结构体在语法上是完全合法的，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;getUsers&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;view&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;returns&lt;/span&gt; (User[] &lt;span style=&#34;color:#66d9ef&#34;&gt;memory&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;从接口设计的角度看，这样的函数非常直观：
“调用一次，就能拿到所有用户数据。”&lt;/p&gt;
&lt;p&gt;问题在于，这种直观并不等于便宜。&lt;/p&gt;
&lt;h4 id=&#34;链上调用时会发生什么&#34;&gt;链上调用时会发生什么
&lt;/h4&gt;&lt;p&gt;如果这个函数被 &lt;strong&gt;另一个合约&lt;/strong&gt; 调用，那么即使它是 &lt;code&gt;view&lt;/code&gt; 函数，也会真实消耗 Gas。
在这种情况下，EVM 需要做的事情包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从 storage 中逐个读取所有 &lt;code&gt;User&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将这些数据复制到 memory&lt;/li&gt;
&lt;li&gt;按 ABI 规则编码整个数组&lt;/li&gt;
&lt;li&gt;将编码后的字节作为返回值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些操作的成本，都会随着数组长度线性增长。&lt;/p&gt;
&lt;p&gt;也就是说，&lt;strong&gt;返回的数据越多，Gas 消耗越高，而且没有上限。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;这类成本往往是没必要的&#34;&gt;这类成本往往是“没必要的”
&lt;/h4&gt;&lt;p&gt;在实际项目中，完整的数据列表通常是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给前端或后端服务用的&lt;/li&gt;
&lt;li&gt;用于展示、统计或分析&lt;/li&gt;
&lt;li&gt;不会被其他合约在链上依赖&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而这些链下系统，完全可以通过 &lt;code&gt;eth_call&lt;/code&gt; 免费读取 view 函数的返回值。&lt;/p&gt;
&lt;p&gt;这就造成了一种常见的浪费：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;链上调用为返回数据付出了 Gas&lt;/li&gt;
&lt;li&gt;真正需要这些数据的是链下系统&lt;/li&gt;
&lt;li&gt;而链下系统本可以不花任何 Gas&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;更合理的设计思路&#34;&gt;更合理的设计思路
&lt;/h4&gt;&lt;p&gt;因此，在设计函数返回值时，应该明确区分两种使用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;链上调用的函数&lt;/strong&gt;
返回值应当尽量简单，甚至可以不返回任何数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;链下查询用的函数&lt;/strong&gt;
可以返回数组或结构体，但要意识到它们只适合通过 &lt;code&gt;eth_call&lt;/code&gt; 使用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果存在链上也需要读取部分数据的需求，那么分页或游标式接口通常是更安全的选择。&lt;/p&gt;
&lt;h3 id=&#34;86-用分页与游标来替代一次性返回&#34;&gt;8.6 用分页与游标来替代一次性返回
&lt;/h3&gt;&lt;p&gt;如果确实需要从合约中读取大量数据，更合理的方式是分页。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;getUsers&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; offset, &lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; limit)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;view&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;returns&lt;/span&gt; (User[] &lt;span style=&#34;color:#66d9ef&#34;&gt;memory&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 返回一部分数据
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这种设计的优势是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;链上调用时可以控制 Gas 上限&lt;/li&gt;
&lt;li&gt;链下系统可以逐页拉取&lt;/li&gt;
&lt;li&gt;接口行为更可预测&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;87-一个事件设计对比示例&#34;&gt;8.7 一个事件设计对比示例
&lt;/h3&gt;&lt;p&gt;不推荐的写法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;event&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OrderCreated&lt;/span&gt;(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;address&lt;/span&gt; user,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;[] itemIds,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;[] prices
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;改进后的写法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;event&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OrderCreated&lt;/span&gt;(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;address&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;indexed&lt;/span&gt; user,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;bytes32&lt;/span&gt; orderId
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;并在链下系统中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据 &lt;code&gt;orderId&lt;/code&gt; 关联完整订单数据&lt;/li&gt;
&lt;li&gt;使用事件作为“索引信号”，而不是数据载体&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种设计在可扩展性和成本上都更加合理。&lt;/p&gt;
&lt;h2 id=&#34;9-紧凑表示与低级优化谨慎使用&#34;&gt;9. 紧凑表示与低级优化（谨慎使用）
&lt;/h2&gt;&lt;p&gt;在前面的内容中，我们讨论的优化大多具备一个共同特点：
&lt;strong&gt;不牺牲可读性，风险可控，收益稳定。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在我们开始讨论一些进阶技巧，这些技巧&lt;strong&gt;确实可以省 Gas&lt;/strong&gt;，但同时也会带来：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可读性下降&lt;/li&gt;
&lt;li&gt;实现复杂度上升&lt;/li&gt;
&lt;li&gt;更高的审计和维护成本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，这一节的核心不是“教你一定要用”，而是回答：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;哪些低级优化在什么情况下值得用，什么时候应该果断放弃。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;91-位运算与-bitmap&#34;&gt;9.1 位运算与 bitmap
&lt;/h3&gt;&lt;p&gt;一个非常典型、也相对安全的进阶优化手段，是 &lt;strong&gt;bitmap（位图）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;假设你需要维护一组布尔状态，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;某个地址是否已完成某一步操作&lt;/li&gt;
&lt;li&gt;某些 ID 是否已被使用&lt;/li&gt;
&lt;li&gt;一组固定大小的开关位&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最直观的写法是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mapping&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;) used;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这种写法清晰、易懂，但每一个 &lt;code&gt;bool&lt;/code&gt; 实际上都会占用一个完整的 storage slot。&lt;/p&gt;
&lt;h4 id=&#34;使用-bitmap-的思路&#34;&gt;使用 bitmap 的思路
&lt;/h4&gt;&lt;p&gt;如果这些布尔值的 key 是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;连续的&lt;/li&gt;
&lt;li&gt;范围有限的&lt;/li&gt;
&lt;li&gt;数量较多的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么可以考虑用一个 &lt;code&gt;uint256&lt;/code&gt; 来存储 256 个布尔值：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; bitmap;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;第 n 位表示第 n 个状态&lt;/li&gt;
&lt;li&gt;通过位运算进行读写&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;isUsed&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; index) &lt;span style=&#34;color:#66d9ef&#34;&gt;internal&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;view&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;returns&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (bitmap &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; index)) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;setUsed&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; index) &lt;span style=&#34;color:#66d9ef&#34;&gt;internal&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    bitmap &lt;span style=&#34;color:#f92672&#34;&gt;|=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; index);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样做的直接收益是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用 1 个 storage slot 表示 256 个状态&lt;/li&gt;
&lt;li&gt;大幅减少 storage 读写次数&lt;/li&gt;
&lt;li&gt;在高频场景下节省可观的 Gas&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;92-bitmap-的适用边界&#34;&gt;9.2 bitmap 的适用边界
&lt;/h3&gt;&lt;p&gt;bitmap 并不是 mapping(bool) 的“全面替代”，它适合以下场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;状态数量上限明确&lt;/li&gt;
&lt;li&gt;index 可控且不来自任意用户输入&lt;/li&gt;
&lt;li&gt;逻辑相对稳定，不易变更&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不适合以下场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;key 是 address 或 hash&lt;/li&gt;
&lt;li&gt;状态数量不可预期&lt;/li&gt;
&lt;li&gt;逻辑频繁变动、需要高度可读性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个实用判断是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;如果你需要在文档中专门解释“这一位代表什么”，那就说明复杂度已经上升了。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;93-紧凑编码与省-slot思维&#34;&gt;9.3 紧凑编码与“省 slot”思维
&lt;/h3&gt;&lt;p&gt;除了 bitmap，一些项目还会尝试：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在一个 &lt;code&gt;uint256&lt;/code&gt; 中打包多个小字段&lt;/li&gt;
&lt;li&gt;用位移和掩码存储多个数值&lt;/li&gt;
&lt;li&gt;手动实现类似 storage packing 的逻辑&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; packed;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高 128 位表示余额&lt;/li&gt;
&lt;li&gt;低 128 位表示时间戳&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种写法在理论上可以减少 slot 数量，但需要注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每一次读写都需要位运算&lt;/li&gt;
&lt;li&gt;容易引入边界错误&lt;/li&gt;
&lt;li&gt;调试和审计难度明显增加&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这类优化通常只在以下情况下才值得考虑：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据结构极其稳定&lt;/li&gt;
&lt;li&gt;访问频率非常高&lt;/li&gt;
&lt;li&gt;已经确认 slot 数量是主要瓶颈&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;94-关于-assembly&#34;&gt;9.4 关于 assembly
&lt;/h3&gt;&lt;p&gt;Solidity 允许通过 &lt;code&gt;assembly&lt;/code&gt; 直接编写 EVM 指令，这意味着：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以跳过部分编译器生成的冗余逻辑&lt;/li&gt;
&lt;li&gt;在极端情况下获得更低的 Gas&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如，直接使用 &lt;code&gt;sload&lt;/code&gt;、&lt;code&gt;sstore&lt;/code&gt;、&lt;code&gt;calldataload&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;但需要非常谨慎：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;assembly 不做类型检查&lt;/li&gt;
&lt;li&gt;不提供溢出保护&lt;/li&gt;
&lt;li&gt;可读性和可维护性显著下降&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在大多数业务合约中，&lt;strong&gt;assembly 带来的收益往往小于它引入的风险&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;95-assembly-什么时候才值得用&#34;&gt;9.5 assembly 什么时候才值得用
&lt;/h3&gt;&lt;p&gt;相对合理的使用场景包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;经常被调用的“热路径”&lt;/li&gt;
&lt;li&gt;非常底层、逻辑稳定的工具函数&lt;/li&gt;
&lt;li&gt;已有充分测试覆盖&lt;/li&gt;
&lt;li&gt;有经验的开发者和审计支持&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不推荐的场景包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;业务逻辑核心&lt;/li&gt;
&lt;li&gt;权限、资金相关代码&lt;/li&gt;
&lt;li&gt;仅为了节省少量 Gas&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个保守但实用的原则是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;如果不用 assembly 也能把 Gas 控制在合理范围内，那就不要用 assembly。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;96-进阶优化的真实收益评估&#34;&gt;9.6 进阶优化的真实收益评估
&lt;/h3&gt;&lt;p&gt;需要特别强调的是，进阶优化的收益往往是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单次调用节省几十到几百 Gas&lt;/li&gt;
&lt;li&gt;只有在高频调用时才会显现价值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，在决定采用这些技巧之前，最好已经：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;完成了 storage、接口、循环等基础优化&lt;/li&gt;
&lt;li&gt;明确知道瓶颈在哪里&lt;/li&gt;
&lt;li&gt;有真实的 Gas 测试数据作为依据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;否则，很容易陷入“为优化而优化”。&lt;/p&gt;
&lt;h2 id=&#34;10-如何验证优化是否有效&#34;&gt;10. 如何验证优化是否有效
&lt;/h2&gt;&lt;p&gt;到目前为止，我们已经讨论了多种 Gas 优化手段。
但在真正的工程实践中，有一个问题始终比“怎么优化”更重要：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你怎么确定，这次优化真的有价值？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这一节的目标，是建立一种可执行的、数据驱动的优化方法，而不是依赖直觉或经验判断。&lt;/p&gt;
&lt;h3 id=&#34;101-为什么不能凭感觉判断-gas&#34;&gt;10.1 为什么不能凭感觉判断 Gas
&lt;/h3&gt;&lt;p&gt;Gas 成本并不总是和“代码复杂度”成正比：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有些看起来复杂的重构，几乎不影响 Gas&lt;/li&gt;
&lt;li&gt;有些只改了几行的调整，却能节省大量成本&lt;/li&gt;
&lt;li&gt;有些优化在小规模测试中无感，在大规模使用中差异巨大&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果没有量化数据，很容易出现两种极端：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;低估优化价值&lt;/strong&gt;：错过高收益改进&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;过度优化&lt;/strong&gt;：引入复杂性却几乎没有回报&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，Gas 优化必须是&lt;strong&gt;数据驱动的工程行为&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;102-什么是有效的-gas-优化&#34;&gt;10.2 什么是“有效的 Gas 优化”
&lt;/h3&gt;&lt;p&gt;一个优化是否有效，通常需要回答三个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;节省了多少 Gas&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;发生在多高频的执行路径上&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;引入了多少额外复杂度或风险&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;只有当节省的 Gas 与复杂度之间形成合理比例时，这次优化才是值得的。&lt;/p&gt;
&lt;h3 id=&#34;103-基准测试的基本思路&#34;&gt;10.3 基准测试的基本思路
&lt;/h3&gt;&lt;p&gt;最简单、也最可靠的方式，是对同一逻辑进行&lt;strong&gt;优化前 / 优化后对比测试&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;基本原则包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用相同的输入数据&lt;/li&gt;
&lt;li&gt;只改变你关心的那一处实现&lt;/li&gt;
&lt;li&gt;关注 &lt;code&gt;gas used&lt;/code&gt;，而不是交易费用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原始版本：函数 A&lt;/li&gt;
&lt;li&gt;优化版本：函数 A′&lt;/li&gt;
&lt;li&gt;对比两者在相同调用条件下的 Gas 消耗&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;104-一个概念级的对比示例&#34;&gt;10.4 一个概念级的对比示例
&lt;/h3&gt;&lt;p&gt;假设你有一个累加逻辑：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;[] calldata xs) &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; xs.length; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        total &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; xs[i];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;和一个优化版本：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;addOptimized&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;[] calldata xs) &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; t &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; total;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; xs.length;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; len; ) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        t &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; xs[i];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;unchecked&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    total &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; t;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;你关心的不是“哪一个看起来更好”，而是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 &lt;code&gt;xs.length = 10&lt;/code&gt;、&lt;code&gt;100&lt;/code&gt;、&lt;code&gt;1000&lt;/code&gt; 时&lt;/li&gt;
&lt;li&gt;两者的 Gas 消耗曲线是否明显分离&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种对比，才能真正说明问题。&lt;/p&gt;
&lt;h3 id=&#34;105-关注最坏情况而不仅是平均值&#34;&gt;10.5 关注“最坏情况”，而不仅是平均值
&lt;/h3&gt;&lt;p&gt;在智能合约中，最坏情况往往比平均情况更重要。&lt;/p&gt;
&lt;p&gt;原因包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Gas 不够会直接导致交易失败&lt;/li&gt;
&lt;li&gt;用户更容易遇到极端输入&lt;/li&gt;
&lt;li&gt;批处理和循环的风险集中在最坏情况&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，在测试时，应当：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尝试最大允许输入&lt;/li&gt;
&lt;li&gt;覆盖边界条件&lt;/li&gt;
&lt;li&gt;关注 Gas 是否接近区块限制或函数预期上限&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;106-工具并不重要方法才重要&#34;&gt;10.6 工具并不重要，方法才重要
&lt;/h3&gt;&lt;p&gt;不同团队可能使用不同工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hardhat&lt;/li&gt;
&lt;li&gt;Foundry&lt;/li&gt;
&lt;li&gt;Truffle&lt;/li&gt;
&lt;li&gt;自定义脚本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但无论使用什么工具，核心方法都是一致的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;固定输入&lt;/li&gt;
&lt;li&gt;重复测试&lt;/li&gt;
&lt;li&gt;对比 gas used&lt;/li&gt;
&lt;li&gt;用数据支撑决策&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不要为了“用工具而用工具”，而是让工具服务于结论。&lt;/p&gt;
&lt;h3 id=&#34;107-什么时候应该停止优化&#34;&gt;10.7 什么时候应该停止优化
&lt;/h3&gt;&lt;p&gt;一个容易忽视的问题是：&lt;strong&gt;什么时候该停下来？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以考虑以下信号：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;继续优化只能节省极少量 Gas&lt;/li&gt;
&lt;li&gt;代码复杂度明显上升&lt;/li&gt;
&lt;li&gt;已经覆盖了高频和高成本路径&lt;/li&gt;
&lt;li&gt;优化收益无法抵消审计和维护成本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Gas 优化不是无止境的，而是一种平衡。&lt;/p&gt;
&lt;h2 id=&#34;11-一份可执行的-gas-优化清单&#34;&gt;11. 一份可执行的 Gas 优化清单
&lt;/h2&gt;&lt;p&gt;到这里，我们已经从 EVM 成本模型出发，系统地讨论了 Gas 优化在设计和实现层面的主要原则。
我们现在可以把前面的内容&lt;strong&gt;收敛成一份可以直接使用的清单&lt;/strong&gt;，用于日常开发和代码评审。&lt;/p&gt;
&lt;p&gt;这份清单并不是“必须全部满足”的规则集合，而是一种&lt;strong&gt;优先级导向的检查顺序&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;111-设计阶段优先检查项&#34;&gt;11.1 设计阶段优先检查项
&lt;/h3&gt;&lt;p&gt;在写代码之前，优先思考以下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是否真的需要存储这个状态，还是可以通过计算或事件获得&lt;/li&gt;
&lt;li&gt;状态变量是否会被频繁读写&lt;/li&gt;
&lt;li&gt;是否存在不受限的循环或批处理接口&lt;/li&gt;
&lt;li&gt;数据结构是否有明确的规模上限&lt;/li&gt;
&lt;li&gt;是否存在“查找/去重/删除元素”需求&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果这些问题在设计阶段就能被回答，很多 Gas 问题可以被直接避免。&lt;/p&gt;
&lt;h3 id=&#34;112-storage-相关检查项最高优先级&#34;&gt;11.2 Storage 相关检查项（最高优先级）
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;是否存在在同一函数中多次读取同一个 storage 变量的情况&lt;/li&gt;
&lt;li&gt;是否在循环中直接写 storage&lt;/li&gt;
&lt;li&gt;是否可以通过缓存变量减少 SLOAD / SSTORE&lt;/li&gt;
&lt;li&gt;状态变量和 struct 字段顺序是否合理，避免浪费 slot&lt;/li&gt;
&lt;li&gt;不再使用的状态是否及时 &lt;code&gt;delete&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;是否用 mapping 替代数组进行存在性判断、去重、按 key 查询，避免 O(n) 遍历&lt;/li&gt;
&lt;li&gt;若必须可枚举，是否使用 mapping + array + index（swap-and-pop）实现 O(1) 增删与枚举&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是最值得投入精力的优化区域。&lt;/p&gt;
&lt;h3 id=&#34;113-函数接口与参数检查项&#34;&gt;11.3 函数接口与参数检查项
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;对外接口是否优先使用 &lt;code&gt;external&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;external 函数参数是否使用 &lt;code&gt;calldata&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;是否避免了不必要的 &lt;code&gt;public&lt;/code&gt; 函数&lt;/li&gt;
&lt;li&gt;是否存在 &lt;code&gt;this&lt;/code&gt; 调用当前合约的情况&lt;/li&gt;
&lt;li&gt;是否采用了 external 入口 + internal 实现的模式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些优化通常风险低、收益稳定。&lt;/p&gt;
&lt;h3 id=&#34;114-循环与批处理检查项&#34;&gt;11.4 循环与批处理检查项
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;是否缓存了数组 length 和中间结果&lt;/li&gt;
&lt;li&gt;循环中是否避免了 storage 读写&lt;/li&gt;
&lt;li&gt;是否避免在循环中做 O(n) 查找&lt;/li&gt;
&lt;li&gt;是否在安全前提下使用 &lt;code&gt;unchecked&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;循环是否存在明确的上限&lt;/li&gt;
&lt;li&gt;批处理接口是否限制了单次处理数量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;循环是 Gas 放大器，尤其需要从“最坏情况”角度审视。&lt;/p&gt;
&lt;h3 id=&#34;115-错误处理与字节码体积&#34;&gt;11.5 错误处理与字节码体积
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;是否使用 custom error 替代 &lt;code&gt;require(string)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;错误信息是否简洁、结构化&lt;/li&gt;
&lt;li&gt;是否避免在字节码中嵌入大量字符串&lt;/li&gt;
&lt;li&gt;合约体积是否接近部署限制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些优化往往在合约复杂后才显现价值，但越早统一越好。&lt;/p&gt;
&lt;h3 id=&#34;116-事件与返回值设计&#34;&gt;11.6 事件与返回值设计
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;事件是否只记录必要信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;indexed&lt;/code&gt; 参数是否只用于高频过滤字段&lt;/li&gt;
&lt;li&gt;是否避免在事件中携带大数组或字符串&lt;/li&gt;
&lt;li&gt;是否避免链上返回大量数据&lt;/li&gt;
&lt;li&gt;是否通过分页或链下索引替代一次性查询&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里的目标是：&lt;strong&gt;不把链当数据库使用。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;117-进阶优化谨慎项&#34;&gt;11.7 进阶优化（谨慎项）
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;是否已经完成基础优化&lt;/li&gt;
&lt;li&gt;是否明确瓶颈来自 slot 数量或高频调用&lt;/li&gt;
&lt;li&gt;位运算或 bitmap 是否真的降低了 storage 使用&lt;/li&gt;
&lt;li&gt;是否避免在核心业务逻辑中滥用 assembly&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些优化应当是“有数据支撑的例外”，而不是常规手段。&lt;/p&gt;
&lt;h3 id=&#34;118-用数据驱动最终决策&#34;&gt;11.8 用数据驱动最终决策
&lt;/h3&gt;&lt;p&gt;在合并任何 Gas 优化之前，建议确认：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是否有明确的 Gas 对比数据&lt;/li&gt;
&lt;li&gt;优化是否发生在高频或关键路径&lt;/li&gt;
&lt;li&gt;引入的复杂度是否可被测试和审计覆盖&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果优化的收益无法清晰说明，那通常意味着它并不重要。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
