<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>区块链 on 王离谱的小破站</title>
        <link>https://yearsuns-github-io.vercel.app/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/</link>
        <description>Recent content in 区块链 on 王离谱的小破站</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-CN</language>
        <copyright>王离谱</copyright>
        <lastBuildDate>Sat, 20 Sep 2025 14:59:56 +0800</lastBuildDate><atom:link href="https://yearsuns-github-io.vercel.app/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Solidity中的Gas优化最佳实践</title>
        <link>https://yearsuns-github-io.vercel.app/p/best-practices-for-gas-optimization-in-solidity/</link>
        <pubDate>Sat, 20 Sep 2025 14:59:56 +0800</pubDate>
        
        <guid>https://yearsuns-github-io.vercel.app/p/best-practices-for-gas-optimization-in-solidity/</guid>
        <description>&lt;h2 id=&#34;1-为什么需要-gas-优化&#34;&gt;1. 为什么需要 Gas 优化
&lt;/h2&gt;&lt;p&gt;在以太坊上开发智能合约时，Gas 是一个绕不开的概念。
它既不是单纯的“手续费”，也不仅仅是网络拥堵时的临时成本，而是&lt;strong&gt;对合约设计质量的一种长期约束&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;很多开发者第一次关注 Gas，往往是在以下场景中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;合约部署费用异常高&lt;/li&gt;
&lt;li&gt;用户调用某个函数时频繁 Out of Gas&lt;/li&gt;
&lt;li&gt;同样的功能，不同实现方式的成本差异明显&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些问题通常并非出现在业务逻辑上，而是源于&lt;strong&gt;对 EVM 成本模型缺乏直觉&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;11-gas-的两层含义&#34;&gt;1.1 Gas 的两层含义
&lt;/h3&gt;&lt;p&gt;在讨论优化之前，必须先区分两个容易混淆的概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;gas used&lt;/strong&gt;：执行一笔交易实际消耗的 Gas 单位数量&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;gas price&lt;/strong&gt;：你愿意为每个 Gas 单位支付的价格&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;合约代码本身只能影响 &lt;strong&gt;gas used&lt;/strong&gt;，而无法控制 gas price。&lt;/p&gt;
&lt;p&gt;这意味着：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;网络拥堵会推高 gas price，但不会改变合约的 gas used&lt;/li&gt;
&lt;li&gt;一个设计不佳的合约，在任何网络环境下都会更贵&lt;/li&gt;
&lt;li&gt;在 gas price 较高的时期，低效设计的成本差距会被进一步放大&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，Gas 优化并不是为了“赌网络状况”，而是为了&lt;strong&gt;让每次执行尽可能少地消耗 Gas 单位&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;12-为什么功能正确并不等于成本合理&#34;&gt;1.2 为什么“功能正确”并不等于“成本合理”
&lt;/h3&gt;&lt;p&gt;在传统软件中，只要程序运行正确，性能问题往往可以后置优化。
但在智能合约中，&lt;strong&gt;性能就是成本&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一个合约即使：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没有安全漏洞&lt;/li&gt;
&lt;li&gt;功能完全符合预期&lt;/li&gt;
&lt;li&gt;能通过所有测试&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;仍然可能因为以下原因变得难以使用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;某些函数在链上执行成本过高&lt;/li&gt;
&lt;li&gt;高峰期交易失败率上升&lt;/li&gt;
&lt;li&gt;长期来看，用户为相同功能支付了不必要的费用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这类问题往往不是“写错了代码”，而是&lt;strong&gt;在设计阶段忽略了 Gas 的结构性成本&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;13-gas-优化的目标是什么&#34;&gt;1.3 Gas 优化的目标是什么
&lt;/h3&gt;&lt;p&gt;Gas 优化并不是追求“极致便宜”，而是服务于三个更现实的目标：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;降低长期使用成本&lt;/strong&gt;
高频调用的函数，哪怕节省几百 Gas，长期也会累积显著差异。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;提高交易成功率&lt;/strong&gt;
Gas 消耗越可控，越不容易在复杂路径中触发 Out of Gas。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;提升成本的可预测性&lt;/strong&gt;
让调用者更容易估算所需 Gas，减少不确定性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这也是为什么 Gas 优化通常应当优先作用在：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高频路径&lt;/li&gt;
&lt;li&gt;核心业务逻辑&lt;/li&gt;
&lt;li&gt;用户直接支付成本的函数&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;14-何时不应该过度优化&#34;&gt;1.4 何时不应该过度优化
&lt;/h3&gt;&lt;p&gt;需要明确的是，&lt;strong&gt;Gas 优化有明显的边际递减效应&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;以下情况通常不值得：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为了节省极少量 Gas，引入复杂且晦涩的写法&lt;/li&gt;
&lt;li&gt;在低频、冷路径上做大量微优化&lt;/li&gt;
&lt;li&gt;牺牲安全检查或可读性来换取微小收益&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;合理的原则是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;先写出安全、清晰、可维护的代码，再在“真正昂贵的地方”做优化。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在大多数情况下，理解并避免高成本结构，比记住零散技巧更重要。&lt;/p&gt;
&lt;h3 id=&#34;15-接下来要做什么&#34;&gt;1.5 接下来要做什么
&lt;/h3&gt;&lt;p&gt;接下来的章节将从最基础的问题开始：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;EVM 到底在为什么操作收费&lt;/li&gt;
&lt;li&gt;哪些指令最贵，哪些几乎可以忽略&lt;/li&gt;
&lt;li&gt;为什么 storage 读写是 Gas 成本的核心&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;理解这些原理之后，后续的所有优化实践都会变得自然，而不是依赖记忆规则。&lt;/p&gt;
&lt;h2 id=&#34;2-gas-成本模型&#34;&gt;2. Gas 成本模型
&lt;/h2&gt;&lt;p&gt;在讨论具体的优化技巧之前，有必要先建立一个清晰的成本直觉：&lt;strong&gt;EVM 并不是所有操作都同样昂贵&lt;/strong&gt;。
很多看起来“简单”的 Solidity 代码，之所以 Gas 消耗很高，原因往往不在业务逻辑本身，而在于它触发了高成本的底层指令。&lt;/p&gt;
&lt;p&gt;理解这一节内容的目标只有一个：
&lt;strong&gt;知道哪些操作值得被重点避免或合并，哪些操作几乎可以忽略不计。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;21-什么是指令级收费&#34;&gt;2.1 什么是指令级收费
&lt;/h3&gt;&lt;p&gt;EVM 是一台基于栈的虚拟机。Solidity 代码在部署或调用前，会被编译为一系列 EVM 指令（opcode），例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ADD、SUB、LT 等算术或比较指令&lt;/li&gt;
&lt;li&gt;MLOAD、MSTORE 等内存操作&lt;/li&gt;
&lt;li&gt;SLOAD、SSTORE 等 storage 操作&lt;/li&gt;
&lt;li&gt;CALL、DELEGATECALL 等外部调用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Gas 的计算完全发生在指令层面&lt;/strong&gt;，而不是在 Solidity 语法层面。这意味着：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一行 Solidity 代码可能对应多条指令&lt;/li&gt;
&lt;li&gt;不同写法即使“看起来一样”，编译后的指令序列也可能不同&lt;/li&gt;
&lt;li&gt;Gas 的差异，来自指令类型和数量，而不是代码长度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，Gas 优化本质上是在做一件事：
&lt;strong&gt;让高成本指令执行得更少。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;22-成本层级&#34;&gt;2.2 成本层级
&lt;/h3&gt;&lt;p&gt;从成本角度，可以粗略把 EVM 中的操作分为几个层级（从低到高）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;纯计算（算术、比较、位运算）&lt;/li&gt;
&lt;li&gt;内存（memory）读写&lt;/li&gt;
&lt;li&gt;calldata 读取&lt;/li&gt;
&lt;li&gt;storage 读取（SLOAD）&lt;/li&gt;
&lt;li&gt;storage 写入（SSTORE）&lt;/li&gt;
&lt;li&gt;外部调用与返回大量数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中最重要的一点是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;storage 操作的成本，远高于绝大多数计算操作。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这也是为什么很多 Gas 优化最终都会指向同一个方向：
&lt;strong&gt;减少 storage 的访问次数。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;23-storage-是什么为什么这么贵&#34;&gt;2.3 Storage 是什么，为什么这么贵
&lt;/h3&gt;&lt;p&gt;在 Solidity 中，所有状态变量都会存储在 storage 中。
从 EVM 的视角来看，storage 是一张巨大的键值表：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;key：storage slot 的位置&lt;/li&gt;
&lt;li&gt;value：32 字节的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;storage 的特点是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据是永久存在的&lt;/li&gt;
&lt;li&gt;会影响全局状态树&lt;/li&gt;
&lt;li&gt;所有全节点都必须对其状态达成共识&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每一次 storage 的写入，都意味着对整个系统状态的一次修改，这正是它昂贵的根本原因。&lt;/p&gt;
&lt;h3 id=&#34;24-读取-storage-的真实成本&#34;&gt;2.4 读取 storage 的真实成本
&lt;/h3&gt;&lt;p&gt;当你读取一个状态变量时，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; count;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;编译后的关键指令是 &lt;code&gt;SLOAD&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;自 EIP-2929 之后，SLOAD 的成本分为两种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;冷访问（cold access）&lt;/strong&gt;：
在一次交易中，第一次访问某个 storage slot&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;热访问（warm access）&lt;/strong&gt;：
在同一交易中，再次访问已经读过的 slot&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;直觉上可以理解为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一次读取某个状态变量，EVM 需要“把它带进来”&lt;/li&gt;
&lt;li&gt;后续再读同一个变量，成本会降低，但仍然不便宜&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;即使是热访问，SLOAD 的成本也明显高于内存或算术操作。&lt;/p&gt;
&lt;h3 id=&#34;25-为什么写-storage-是最贵的操作之一&#34;&gt;2.5 为什么写 storage 是最贵的操作之一
&lt;/h3&gt;&lt;p&gt;当你修改一个状态变量时，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; count &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这并不是一次简单的“加一”，而是一个完整的读–改–写过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;SLOAD：读取原始值&lt;/li&gt;
&lt;li&gt;执行加法&lt;/li&gt;
&lt;li&gt;SSTORE：写入新值&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;SSTORE 的成本取决于写入前后的状态，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从 0 写成非 0：成本最高&lt;/li&gt;
&lt;li&gt;从非 0 改为非 0：次之&lt;/li&gt;
&lt;li&gt;从非 0 改为 0：成本较低，并可能获得退款&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些规则的存在，本质上是为了鼓励合约释放不再使用的状态。&lt;/p&gt;
&lt;h3 id=&#34;26-一行-solidity-代码背后的真实执行过程&#34;&gt;2.6 一行 Solidity 代码背后的真实执行过程
&lt;/h3&gt;&lt;p&gt;来看一个非常常见的写法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;count &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;从 Solidity 的角度看，它只是一次简单的自增。
但从 EVM 的角度看，它通常意味着：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一次 SLOAD&lt;/li&gt;
&lt;li&gt;一次加法指令&lt;/li&gt;
&lt;li&gt;一次 SSTORE&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果在同一个函数中多次写出类似代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;count &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;count &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;count &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;你并不是做了三次加法，而是触发了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;3 次 SLOAD&lt;/li&gt;
&lt;li&gt;3 次 SSTORE&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这正是 Gas 消耗迅速放大的原因。&lt;/p&gt;
&lt;h3 id=&#34;27-建立一个关键直觉&#34;&gt;2.7 建立一个关键直觉
&lt;/h3&gt;&lt;p&gt;到这里，可以总结出一个非常重要的直觉：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;算术和逻辑运算通常不是 Gas 的瓶颈&lt;/li&gt;
&lt;li&gt;storage 的读写，才是 Gas 成本的核心来源&lt;/li&gt;
&lt;li&gt;多次重复访问同一个 storage slot，是最常见也最容易忽视的浪费&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一旦你建立起这个直觉，后续关于缓存变量、合并写入、storage packing 等优化方式，都会显得顺理成章，而不是技巧堆砌。&lt;/p&gt;
&lt;h2 id=&#34;3-减少-storage-读写&#34;&gt;3. 减少 Storage 读写
&lt;/h2&gt;&lt;p&gt;在理解了 EVM 的成本模型之后，Gas 优化的优先级其实已经非常清晰：
&lt;strong&gt;只要能减少 storage 的读写次数，几乎一定能获得显著的 Gas 收益。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所有的gas优化技巧大多围绕一个核心目标展开：
&lt;strong&gt;让 SLOAD 和 SSTORE 尽可能少地执行。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;31-为什么-storage-优化具有最高性价比&#34;&gt;3.1 为什么 Storage 优化具有最高性价比
&lt;/h3&gt;&lt;p&gt;前面我们讨论过：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;算术运算非常便宜&lt;/li&gt;
&lt;li&gt;内存操作成本中等&lt;/li&gt;
&lt;li&gt;storage 写入是最昂贵的操作之一&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这意味着：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;省掉一次 SSTORE，往往比优化十几行计算代码更有价值&lt;/li&gt;
&lt;li&gt;优化 storage 访问，收益通常是数量级上的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，在实际工程中，Gas 优化的顺序应当是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先看是否能减少 storage 读写&lt;/li&gt;
&lt;li&gt;再考虑循环、参数、位运算等次级优化&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;32-缓存多次读取把多次-sload-变成一次&#34;&gt;3.2 缓存多次读取：把多次 SLOAD 变成一次
&lt;/h3&gt;&lt;p&gt;最常见、也最容易忽视的低效写法，是在同一个函数中多次读取同一个状态变量。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;increment&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    require(count &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; max, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;too large&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; count &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    emit Updated(count);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在这段代码中，&lt;code&gt;count&lt;/code&gt; 实际上被读取了多次：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;require&lt;/code&gt; 中读取一次&lt;/li&gt;
&lt;li&gt;自增时读取一次&lt;/li&gt;
&lt;li&gt;事件参数中再读取一次&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更高效的写法是先将其缓存到局部变量：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;increment&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; count;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    require(c &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; max, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;too large&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; c &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; c;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    emit Updated(c);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样做的结果是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;storage 只读一次&lt;/li&gt;
&lt;li&gt;storage 只写一次&lt;/li&gt;
&lt;li&gt;后续操作都在内存中完成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种改动几乎不影响可读性，却能显著减少 Gas。&lt;/p&gt;
&lt;h3 id=&#34;33-合并多次写入避免重复的-sstore&#34;&gt;3.3 合并多次写入：避免重复的 SSTORE
&lt;/h3&gt;&lt;p&gt;另一类常见问题，是在同一个函数中多次写入同一个状态变量。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;update&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; x) &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    value &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; x;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; threshold) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        value &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; bonus;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;表面上看，这段代码逻辑清晰，但它可能会对 &lt;code&gt;value&lt;/code&gt; 执行多次 SSTORE。&lt;/p&gt;
&lt;p&gt;更合理的写法是先在内存中完成所有计算：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;update&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; x) &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; v &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; value;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    v &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; x;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; threshold) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        v &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; bonus;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; v;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;原则可以总结为一句话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;不要在逻辑分支中反复写 storage，先算清楚，再一次性写回。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;34-循环中的-storage-读写陷阱&#34;&gt;3.4 循环中的 storage 读写陷阱
&lt;/h3&gt;&lt;p&gt;循环是 storage 读写最容易被放大的地方。&lt;/p&gt;
&lt;p&gt;考虑下面的写法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sum&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;[] calldata arr) &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; arr.length; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        total &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; arr[i];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在这个循环中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每次迭代都会读取并写入 &lt;code&gt;total&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果数组长度为 n，就会触发 n 次 SLOAD 和 n 次 SSTORE&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更高效的写法是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sum&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;[] calldata arr) &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; t &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; total;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; arr.length;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; len; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        t &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; arr[i];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    total &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; t;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这种写法的改动非常小，但对 Gas 的影响会随着数组长度线性放大。&lt;/p&gt;
&lt;h3 id=&#34;35-避免在循环中写-storage-的设计思路&#34;&gt;3.5 避免在循环中写 storage 的设计思路
&lt;/h3&gt;&lt;p&gt;在设计合约时，应当尽量避免以下模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在不受限的循环中写 storage&lt;/li&gt;
&lt;li&gt;每次迭代都更新状态&lt;/li&gt;
&lt;li&gt;循环次数由外部输入完全控制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更好的替代方案包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先在内存中计算，再一次性写回&lt;/li&gt;
&lt;li&gt;设计批处理接口，但限制每次调用的最大数量&lt;/li&gt;
&lt;li&gt;将复杂计算移到链下，只在链上验证结果&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些并不是“写法技巧”，而是&lt;strong&gt;设计阶段就应当考虑的结构性问题&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;36-用-mapping-替代数组&#34;&gt;3.6 用 mapping 替代数组
&lt;/h3&gt;&lt;p&gt;在合约里，“数组还是 mapping”并不只是编码风格差异，而是成本模型差异：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组常见操作（查找、去重、删除某个元素）通常需要遍历，成本是 &lt;strong&gt;O(n)&lt;/strong&gt;，并且容易触发不受限循环&lt;/li&gt;
&lt;li&gt;mapping 的读写是按 key 直接定位，成本接近 &lt;strong&gt;O(1)&lt;/strong&gt;，更稳定、更可控&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;场景-1成员判断contains&#34;&gt;场景 1：成员判断（contains）
&lt;/h4&gt;&lt;p&gt;不推荐：用数组存储成员并在链上查找&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;address&lt;/span&gt;[] &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; members;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;isMember&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;address&lt;/span&gt; a) &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;view&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;returns&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; members.length; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (members[i] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; a) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每次判断都要遍历&lt;/li&gt;
&lt;li&gt;成员越多越贵&lt;/li&gt;
&lt;li&gt;最坏情况下可能 Out of Gas&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;推荐：用 mapping 做存在性判断&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mapping&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;address&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; isMember;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;addMember&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;address&lt;/span&gt; a) &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    isMember[a] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;removeMember&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;address&lt;/span&gt; a) &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    isMember[a] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;判断存在性是 O(1)&lt;/li&gt;
&lt;li&gt;成本可预测&lt;/li&gt;
&lt;li&gt;不需要循环&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;场景-2需要可枚举的集合既要-o1-判断又要列出所有成员&#34;&gt;场景 2：需要“可枚举”的集合（既要 O(1) 判断，又要列出所有成员）
&lt;/h4&gt;&lt;p&gt;很多业务既需要 &lt;code&gt;isMember[a]&lt;/code&gt; 这种 O(1) 判断，也需要枚举所有成员（给前端展示）。这时可以用“mapping + 数组”组合结构：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mapping&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;address&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; isMember;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;address&lt;/span&gt;[] &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; memberList;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mapping&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;address&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; indexPlusOne; &lt;span style=&#34;color:#75715e&#34;&gt;// 下标+1，0 表示不存在
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;addMember&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;address&lt;/span&gt; a) &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (indexPlusOne[a] &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 已存在
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    isMember[a] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    memberList.push(a);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    indexPlusOne[a] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; memberList.length; &lt;span style=&#34;color:#75715e&#34;&gt;// 存的是 index+1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;removeMember&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;address&lt;/span&gt; a) &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; idxPlusOne &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; indexPlusOne[a];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (idxPlusOne &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; idx &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; idxPlusOne &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; memberList.length &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (idx &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; last) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;address&lt;/span&gt; lastAddr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; memberList[last];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        memberList[idx] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; lastAddr;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        indexPlusOne[lastAddr] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; idx &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    memberList.pop();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    indexPlusOne[a] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    isMember[a] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mapping&lt;/code&gt; 负责 O(1) 判断与定位&lt;/li&gt;
&lt;li&gt;&lt;code&gt;array&lt;/code&gt; 负责枚举&lt;/li&gt;
&lt;li&gt;删除用 swap-and-pop，避免 O(n) 移动&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这种结构会引入额外存储（索引 mapping），但换来的是操作复杂度和成本可控，通常非常值得&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;什么时候不该用数组&#34;&gt;什么时候不该用数组
&lt;/h4&gt;&lt;p&gt;如果你发现你在数组上做这些操作，基本就该考虑 mapping：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;contains/查找&lt;/li&gt;
&lt;li&gt;去重&lt;/li&gt;
&lt;li&gt;删除指定元素&lt;/li&gt;
&lt;li&gt;防重复写入&lt;/li&gt;
&lt;li&gt;任何“长度可能增长且由用户输入驱动”的遍历逻辑&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一句话总结：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;数组适合“顺序数据”和“按下标访问”，mapping 适合“按 key 查询/去重/存在性判断”。当你需要查找或删除时，mapping 往往更省 Gas，也更安全。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;4-数据位置与函数接口设计&#34;&gt;4. 数据位置与函数接口设计
&lt;/h2&gt;&lt;p&gt;在减少了不必要的 storage 读写之后，下一类非常值得关注的优化点是：
&lt;strong&gt;函数的接口设计，包括参数的数据位置（data location）和函数的可见性（visibility）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这些选择通常不会改变业务逻辑，但却会直接影响：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是否发生不必要的数据拷贝&lt;/li&gt;
&lt;li&gt;是否触发额外的编码 / 解码&lt;/li&gt;
&lt;li&gt;函数调用在 EVM 中走的是哪条路径&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;合理的接口设计，往往是“低风险、高收益”的 Gas 优化。&lt;/p&gt;
&lt;h3 id=&#34;41-三种数据位置的成本直觉&#34;&gt;4.1 三种数据位置的成本直觉
&lt;/h3&gt;&lt;p&gt;在 Solidity 中，引用类型（数组、struct、string、bytes）必须显式或隐式指定数据位置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;calldata&lt;/strong&gt;：只读，位于调用数据中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;memory&lt;/strong&gt;：可读写，函数执行期间存在&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;storage&lt;/strong&gt;：永久存储在链上&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从成本角度，可以建立一个简单直觉：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;calldata 读取：便宜&lt;/li&gt;
&lt;li&gt;memory 读写：中等&lt;/li&gt;
&lt;li&gt;storage 读写：昂贵&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，一个基本原则是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;能用 calldata 就不要用 memory，能用 memory 就不要用 storage。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;42-external-函数与-calldata&#34;&gt;4.2 external 函数与 calldata
&lt;/h3&gt;&lt;p&gt;对于只从外部调用的函数，最推荐的写法是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;process&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;[] calldata data) &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 使用 data
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;原因在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;external 函数的参数天然来自 calldata&lt;/li&gt;
&lt;li&gt;使用 calldata 不需要将参数复制到 memory&lt;/li&gt;
&lt;li&gt;对于大数组或复杂结构，拷贝成本差异非常明显&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相反，如果写成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;process&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;[] &lt;span style=&#34;color:#66d9ef&#34;&gt;memory&lt;/span&gt; data) &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 使用 data
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;即使你并未修改 &lt;code&gt;data&lt;/code&gt;，编译器仍然需要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将 calldata 中的数据完整复制到 memory&lt;/li&gt;
&lt;li&gt;为此支付额外的 Gas 成本&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;43-什么时候必须使用-memory&#34;&gt;4.3 什么时候必须使用 memory
&lt;/h3&gt;&lt;p&gt;calldata 的限制也非常明确：&lt;strong&gt;只读&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一旦你的函数需要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;修改数组内容&lt;/li&gt;
&lt;li&gt;排序&lt;/li&gt;
&lt;li&gt;去重&lt;/li&gt;
&lt;li&gt;动态构造新数组&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;就必须使用 memory。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;normalize&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;[] calldata data) &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;returns&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;[] &lt;span style=&#34;color:#66d9ef&#34;&gt;memory&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;[] &lt;span style=&#34;color:#66d9ef&#34;&gt;memory&lt;/span&gt; result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;[](data.length);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; data.length; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        result[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; data[i] &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; result;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里的关键点是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入参数使用 calldata（避免拷贝）&lt;/li&gt;
&lt;li&gt;输出结果使用 memory（必须可写）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是一种非常常见、也非常合理的组合。&lt;/p&gt;
&lt;h3 id=&#34;44-函数可见性的-gas-含义&#34;&gt;4.4 函数可见性的 Gas 含义
&lt;/h3&gt;&lt;p&gt;函数可见性不仅影响可调用范围，也会影响 Gas。&lt;/p&gt;
&lt;p&gt;可以从以下角度理解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;external&lt;/strong&gt;：直接从 calldata 读取参数，最省 Gas&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;public&lt;/strong&gt;：参数会被复制到 memory，成本更高&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;internal&lt;/strong&gt;：编译期内联或直接跳转，最便宜&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;private&lt;/strong&gt;：与 internal 类似，但仅限当前合约&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个重要结论是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;public 并不是“内外通用的最优选择”。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;45-external-入口--internal-实现&#34;&gt;4.5 external 入口 + internal 实现
&lt;/h3&gt;&lt;p&gt;在实际工程中，最推荐的模式是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对外暴露的函数使用 &lt;code&gt;external&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将核心逻辑提取到 &lt;code&gt;internal&lt;/code&gt; 函数中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;update&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; x) &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    _update(x);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;_update&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; x) &lt;span style=&#34;color:#66d9ef&#34;&gt;internal&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 核心逻辑
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样做的好处包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;external 函数使用 calldata，参数拷贝最少&lt;/li&gt;
&lt;li&gt;internal 函数调用成本极低&lt;/li&gt;
&lt;li&gt;内部调用和外部调用共享同一份逻辑&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种模式几乎没有副作用，却能避免很多隐性的 Gas 浪费。&lt;/p&gt;
&lt;h3 id=&#34;46-为什么要避免-this-调用当前合约&#34;&gt;4.6 为什么要避免 this 调用当前合约
&lt;/h3&gt;&lt;p&gt;一个非常隐蔽但代价很高的写法是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;this.update(x);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;即使 &lt;code&gt;update&lt;/code&gt; 定义在当前合约中，这种写法也会：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;触发一次完整的 external call&lt;/li&gt;
&lt;li&gt;进行 ABI 编码和解码&lt;/li&gt;
&lt;li&gt;走 CALL 指令路径&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这意味着：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更高的 Gas 成本&lt;/li&gt;
&lt;li&gt;更复杂的执行路径&lt;/li&gt;
&lt;li&gt;潜在的可重入风险&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你发现自己需要 &lt;code&gt;this.foo()&lt;/code&gt;，通常意味着：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;逻辑划分不合理&lt;/li&gt;
&lt;li&gt;internal 函数抽象不充分&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;正确的重构方式，是将逻辑提取为 internal 函数，并在 external 函数中调用它。&lt;/p&gt;
&lt;h3 id=&#34;47-一个对比示例&#34;&gt;4.7 一个对比示例
&lt;/h3&gt;&lt;p&gt;对比下面两种实现：&lt;/p&gt;
&lt;p&gt;不推荐的写法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;foo&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;[] &lt;span style=&#34;color:#66d9ef&#34;&gt;memory&lt;/span&gt; data) &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 使用 data
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bar&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;[] &lt;span style=&#34;color:#66d9ef&#34;&gt;memory&lt;/span&gt; data) &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    foo(data);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;推荐的写法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;foo&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;[] calldata data) &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    _foo(data);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bar&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;[] calldata data) &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    _foo(data);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;_foo&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;[] calldata data) &lt;span style=&#34;color:#66d9ef&#34;&gt;internal&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 使用 data
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;第二种写法在以下方面更优：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参数不被重复拷贝&lt;/li&gt;
&lt;li&gt;逻辑集中，避免重复&lt;/li&gt;
&lt;li&gt;internal 调用成本更低&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;5-状态布局设计storage-packing&#34;&gt;5. 状态布局设计：Storage Packing
&lt;/h2&gt;&lt;p&gt;在前几节中，我们讨论的优化大多发生在“如何使用状态变量”。
这一节关注一个更偏设计层面的问题：&lt;strong&gt;状态变量是如何被放进 storage 的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;很多 Gas 浪费并不是来自频繁读写，而是来自&lt;strong&gt;状态布局本身不合理&lt;/strong&gt;，导致：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用了更多的 storage slot&lt;/li&gt;
&lt;li&gt;每次读写都触发更多的 SLOAD / SSTORE&lt;/li&gt;
&lt;li&gt;合约长期运行成本被放大&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;51-storage-slot-与-32-字节对齐&#34;&gt;5.1 Storage slot 与 32 字节对齐
&lt;/h3&gt;&lt;p&gt;从 EVM 的角度看，storage 是以 &lt;strong&gt;32 字节（256 bit）为一个 slot&lt;/strong&gt; 来组织的。&lt;/p&gt;
&lt;p&gt;Solidity 的状态变量会按照声明顺序，依次放入这些 slot 中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果变量大小小于 32 字节，编译器会尝试将多个变量放进同一个 slot&lt;/li&gt;
&lt;li&gt;如果当前 slot 剩余空间不足，变量会被放到下一个 slot&lt;/li&gt;
&lt;li&gt;一旦一个 slot 被填满，就不会再继续向其中塞变量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这一机制被称为 &lt;strong&gt;storage packing&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;52-一个最基础的打包示例&#34;&gt;5.2 一个最基础的打包示例
&lt;/h3&gt;&lt;p&gt;考虑下面的变量声明：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;uint128&lt;/span&gt; a;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;uint128&lt;/span&gt; b;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; c;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;每个 &lt;code&gt;uint128&lt;/code&gt; 占 16 字节，因此这两个变量可以共享同一个 storage slot。&lt;code&gt;uint256&lt;/code&gt; 独占 16 字节，因此这三个变量总共使用了 2 个 slot。&lt;/p&gt;
&lt;p&gt;但如果顺序稍有不同：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;uint128&lt;/span&gt; a;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; c;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;uint128&lt;/span&gt; b;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;那么：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a&lt;/code&gt; 占用 slot0 的前 16 字节&lt;/li&gt;
&lt;li&gt;&lt;code&gt;c&lt;/code&gt; 独占 slot1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;b&lt;/code&gt; 由于 slot0 剩余空间不足，只能进入 slot2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在这三个变量总共使用了 3 个 slot。仅仅因为声明顺序不同，就多消耗了一个 slot。&lt;/p&gt;
&lt;h3 id=&#34;53-为什么-slot-数量直接影响-gas&#34;&gt;5.3 为什么 slot 数量直接影响 Gas
&lt;/h3&gt;&lt;p&gt;每一个额外的 storage slot，都会带来长期成本：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读取更多 slot → 更多 SLOAD&lt;/li&gt;
&lt;li&gt;写入更多 slot → 更多 SSTORE&lt;/li&gt;
&lt;li&gt;结构体整体读写成本上升&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;尤其是在：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高频调用函数&lt;/li&gt;
&lt;li&gt;需要整体复制或更新 struct 的场景中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;slot 数量的差异，会直接体现在 Gas 消耗上。&lt;/p&gt;
&lt;h3 id=&#34;54-小类型并不总是越小越好&#34;&gt;5.4 小类型并不总是“越小越好”
&lt;/h3&gt;&lt;p&gt;需要注意的是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择小于 256 bit 的类型，并不一定自动省 Gas&lt;/li&gt;
&lt;li&gt;只有在&lt;strong&gt;成功打包&lt;/strong&gt;的前提下，小类型才有意义&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;uint128&lt;/span&gt; a;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; b;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;即使 &lt;code&gt;a&lt;/code&gt; 是 &lt;code&gt;uint128&lt;/code&gt;，它依然会独占一个 slot，因为后面紧跟着一个 &lt;code&gt;uint256&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;因此，类型选择和声明顺序应当结合考虑，而不是孤立决策。&lt;/p&gt;
&lt;h3 id=&#34;55-什么时候应该关心-storage-packing&#34;&gt;5.5 什么时候应该关心 storage packing
&lt;/h3&gt;&lt;p&gt;并不是所有合约都需要精细打包。
storage packing 不仅适用于合约级变量，也同样适用于 struct。&lt;/p&gt;
&lt;p&gt;storage packing 尤其适合以下场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;状态变量数量较多&lt;/li&gt;
&lt;li&gt;使用大量 struct&lt;/li&gt;
&lt;li&gt;状态会被频繁读写&lt;/li&gt;
&lt;li&gt;合约生命周期较长&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而在状态极少、只部署一次、很少交互的合约中，过度调整字段顺序的收益可能有限。&lt;/p&gt;
&lt;h2 id=&#34;6-循环与批处理&#34;&gt;6. 循环与批处理
&lt;/h2&gt;&lt;p&gt;在前几节中，我们已经看到：
storage 读写本身很贵，而&lt;strong&gt;循环会把这种成本按次数放大&lt;/strong&gt;。
因此，循环往往不是 Gas 的来源，但却是 Gas 的“放大器”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不是所有循环都是问题，但不受控制的循环几乎一定会成为问题。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;61-为什么循环容易成为-gas-黑洞&#34;&gt;6.1 为什么循环容易成为 Gas 黑洞
&lt;/h3&gt;&lt;p&gt;从 EVM 的角度看，循环并不是一个特殊结构，它只是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重复执行一段指令序列&lt;/li&gt;
&lt;li&gt;每一次迭代都会完整支付指令成本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果循环体中包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;storage 读写&lt;/li&gt;
&lt;li&gt;昂贵的计算&lt;/li&gt;
&lt;li&gt;外部调用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么 Gas 消耗就会与循环次数线性增长。&lt;/p&gt;
&lt;p&gt;当循环次数由外部输入控制时，风险尤其明显。&lt;/p&gt;
&lt;h3 id=&#34;62-缓存数组-length-与中间结果&#34;&gt;6.2 缓存数组 length 与中间结果
&lt;/h3&gt;&lt;p&gt;一个非常常见、也非常基础的优化点，是缓存数组的长度。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sum&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;[] calldata arr) &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; arr.length; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        s &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; arr[i];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;虽然 &lt;code&gt;arr.length&lt;/code&gt; 看起来很轻量，但在每次循环判断中，都会被重新读取。&lt;/p&gt;
&lt;p&gt;更好的写法是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sum&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;[] calldata arr) &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; arr.length;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; len; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        s &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; arr[i];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这类优化在单次调用中节省的 Gas 不多，但在高频或大数组场景下，会逐渐显现差异。&lt;/p&gt;
&lt;h3 id=&#34;63-避免在循环中直接写-storage&#34;&gt;6.3 避免在循环中直接写 storage
&lt;/h3&gt;&lt;p&gt;如前几节所强调的，在循环中写 storage 是非常昂贵的。&lt;/p&gt;
&lt;p&gt;原则可以总结为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;循环中尽量只做内存计算，把 storage 写入放到循环之外。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;64-在安全前提下使用-unchecked&#34;&gt;6.4 在安全前提下使用 unchecked
&lt;/h3&gt;&lt;p&gt;从 Solidity 0.8 开始，整数运算默认包含溢出检查。
这对安全非常有价值，但在某些场景中，也会带来不必要的 Gas 开销。&lt;/p&gt;
&lt;p&gt;一个典型场景是 for 循环的计数器：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; len; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果你能明确保证：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt; 不会接近 &lt;code&gt;type(uint256).max&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;循环条件有明确上界&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么可以使用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; len; ) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;unchecked&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这类优化的收益不如减少 storage 读写明显，但在大循环中仍然是可测量的。&lt;/p&gt;
&lt;h3 id=&#34;65-避免无上限循环&#34;&gt;6.5 避免无上限循环
&lt;/h3&gt;&lt;p&gt;在设计合约接口时，应当尽量避免：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;循环次数完全由用户输入决定&lt;/li&gt;
&lt;li&gt;没有任何上界或约束&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;process&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;[] calldata items) &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; items.length; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果 &lt;code&gt;items.length&lt;/code&gt; 没有被限制，调用者可以传入极大的数组，导致：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用失败（Out of Gas）&lt;/li&gt;
&lt;li&gt;合约在某些情况下“不可用”&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;常见的改进方式包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;明确限制最大长度&lt;/li&gt;
&lt;li&gt;将操作拆分为多次调用&lt;/li&gt;
&lt;li&gt;提供分页或游标式接口&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;66-批处理batch设计的取舍&#34;&gt;6.6 批处理（Batch）设计的取舍
&lt;/h3&gt;&lt;p&gt;批处理是减少交易次数、摊薄固定成本的常见手段，但它并不是没有代价。&lt;/p&gt;
&lt;p&gt;优点包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减少外部调用次数&lt;/li&gt;
&lt;li&gt;摊薄函数入口和校验成本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;风险包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单笔交易 Gas 不可控&lt;/li&gt;
&lt;li&gt;更容易触发 OOG&lt;/li&gt;
&lt;li&gt;更难估算 Gas 上限&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，批处理接口通常应当具备：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;明确的单次处理上限&lt;/li&gt;
&lt;li&gt;可预期的最坏情况成本&lt;/li&gt;
&lt;li&gt;清晰的失败行为&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;67-一个批处理示例&#34;&gt;6.7 一个批处理示例
&lt;/h3&gt;&lt;p&gt;不推荐的写法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;batchUpdate&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;[] calldata ids) &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; ids.length; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        update(ids[i]);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;改进后的写法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;constant&lt;/span&gt; MAX_BATCH &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;batchUpdate&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;[] calldata ids) &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ids.length;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    require(len &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; MAX_BATCH, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;too many items&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; len; ) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        _update(ids[i]);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;unchecked&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里的关键不是“省多少 Gas”，而是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;成本可控&lt;/li&gt;
&lt;li&gt;行为可预测&lt;/li&gt;
&lt;li&gt;接口对调用者友好&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;7-错误处理与字节码体积优化&#34;&gt;7. 错误处理与字节码体积优化
&lt;/h2&gt;&lt;p&gt;在讨论 Gas 优化时，很多人会把注意力集中在“成功执行路径”上，而忽略了&lt;strong&gt;失败路径和合约本身体积&lt;/strong&gt;的成本。
实际上，错误处理方式不仅影响交易失败时的 Gas 消耗，也会影响：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;合约部署成本&lt;/li&gt;
&lt;li&gt;每次调用的基础开销&lt;/li&gt;
&lt;li&gt;字节码大小与可维护性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这一节将聚焦一个非常具体但收益稳定的优化点：&lt;strong&gt;如何更高效地处理错误和回滚。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;71-revert-本身并不是免费的&#34;&gt;7.1 revert 本身并不是“免费”的
&lt;/h3&gt;&lt;p&gt;当一笔交易 &lt;code&gt;revert&lt;/code&gt; 时，状态会被回滚，但 Gas 并不会全部返还。
尤其是以下几类成本：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;已执行指令消耗的 Gas&lt;/li&gt;
&lt;li&gt;错误信息本身携带的数据&lt;/li&gt;
&lt;li&gt;与 ABI 编码相关的开销&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，一个频繁触发的校验逻辑，其失败路径的成本，同样值得认真对待。&lt;/p&gt;
&lt;h3 id=&#34;72-requirestring-的真实代价&#34;&gt;7.2 require(string) 的真实代价
&lt;/h3&gt;&lt;p&gt;最传统、也最常见的错误处理方式是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;require(msg.sender &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; owner, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Not owner&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这种写法的问题不在于功能，而在于成本：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;错误字符串会被编译进合约字节码&lt;/li&gt;
&lt;li&gt;每一次 revert 都需要返回这段字符串数据&lt;/li&gt;
&lt;li&gt;字符串越长，部署成本和失败成本越高&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在复杂合约中，大量使用 &lt;code&gt;require(string)&lt;/code&gt; 会显著增加 bytecode 体积。&lt;/p&gt;
&lt;h3 id=&#34;73-使用-custom-error-的动机&#34;&gt;7.3 使用 custom error 的动机
&lt;/h3&gt;&lt;p&gt;从 Solidity 0.8.4 开始，引入了 &lt;strong&gt;custom error&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;error NotOwner();
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;并配合：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (msg.sender &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; owner) revert NotOwner();
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这种写法的优势在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不需要存储字符串&lt;/li&gt;
&lt;li&gt;错误标识以 selector 形式存在&lt;/li&gt;
&lt;li&gt;revert 时返回的数据更小&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从成本角度看，它同时降低了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;部署 Gas&lt;/li&gt;
&lt;li&gt;revert 路径的 Gas&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;74-对比示例&#34;&gt;7.4 对比示例
&lt;/h3&gt;&lt;p&gt;考虑一个最简单的权限校验。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;require(string)&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;withdraw&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    require(msg.sender &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; owner, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Not owner&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用 custom error：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;error NotOwner();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;withdraw&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (msg.sender &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; owner) revert NotOwner();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;两种写法在成功路径上的 Gas 几乎相同，但在以下方面存在差异：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;合约部署体积&lt;/li&gt;
&lt;li&gt;revert 时的 Gas 消耗&lt;/li&gt;
&lt;li&gt;错误信息的编码方式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在高频调用或复杂合约中，这种差异会逐渐积累。&lt;/p&gt;
&lt;h3 id=&#34;75-错误信息该写多详细&#34;&gt;7.5 错误信息该写多“详细”
&lt;/h3&gt;&lt;p&gt;一个常见误区是：
&lt;strong&gt;错误信息越详细越好。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从链上执行的角度看，这并不总是成立。&lt;/p&gt;
&lt;p&gt;更合理的分工是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;链上：提供简洁、结构化的错误标识&lt;/li&gt;
&lt;li&gt;链下：通过文档或映射表解释错误含义&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;custom error 非常适合这种模式，因为它：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本身就是结构化的&lt;/li&gt;
&lt;li&gt;可携带参数&lt;/li&gt;
&lt;li&gt;便于前端或 SDK 解码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;error InsufficientBalance(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; available, &lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; required);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;76-字节码体积为什么值得关注&#34;&gt;7.6 字节码体积为什么值得关注
&lt;/h3&gt;&lt;p&gt;合约字节码体积会直接影响：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;部署成本&lt;/li&gt;
&lt;li&gt;部署是否成功（有大小上限）&lt;/li&gt;
&lt;li&gt;每次调用的基础 Gas（代码越大，加载成本越高）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下写法都会增加字节码体积：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大量字符串常量&lt;/li&gt;
&lt;li&gt;重复的逻辑分支&lt;/li&gt;
&lt;li&gt;冗长的错误信息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，Gas 优化不仅是“执行时优化”，也包括&lt;strong&gt;部署时优化&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;77-错误处理与可读性的平衡&#34;&gt;7.7 错误处理与可读性的平衡
&lt;/h3&gt;&lt;p&gt;需要强调的是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;custom error 并不是为了“压缩到极限”&lt;/li&gt;
&lt;li&gt;也不意味着完全放弃可读性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;合理的做法是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对外暴露的核心接口：使用清晰的 custom error&lt;/li&gt;
&lt;li&gt;内部断言或开发阶段检查：适度使用 require&lt;/li&gt;
&lt;li&gt;避免在错误信息中携带冗长文本&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;8-事件与返回值设计&#34;&gt;8. 事件与返回值设计
&lt;/h2&gt;&lt;p&gt;在智能合约中，事件（event）和函数返回值常被用于“对外提供信息”。
但如果设计不当，它们很容易成为 &lt;strong&gt;隐性的 Gas 消耗来源&lt;/strong&gt;，尤其是在高频调用或数据量较大的场景中。&lt;/p&gt;
&lt;p&gt;这一节的核心观点可以先给出：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;区块链擅长做状态验证，不擅长做数据查询。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;理解这一点，有助于你在事件和返回值设计上做出更经济的选择。&lt;/p&gt;
&lt;h3 id=&#34;81-事件的作用边界&#34;&gt;8.1 事件的作用边界
&lt;/h3&gt;&lt;p&gt;事件的主要用途是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;供链下系统监听和索引&lt;/li&gt;
&lt;li&gt;记录重要的状态变化&lt;/li&gt;
&lt;li&gt;作为审计和分析的依据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事件&lt;strong&gt;不会&lt;/strong&gt;被合约在链上读取，也不会影响后续执行逻辑。
因此，从合约执行的角度看，事件是“写一次、只给链下用”的数据。&lt;/p&gt;
&lt;p&gt;这意味着一个设计原则：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;事件应当服务于链下，而不是替代链上状态查询。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;82-事件的-gas-成本构成&#34;&gt;8.2 事件的 Gas 成本构成
&lt;/h3&gt;&lt;p&gt;一个事件的 Gas 成本主要由两部分组成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;topics&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;包括事件签名&lt;/li&gt;
&lt;li&gt;以及最多 3 个 &lt;code&gt;indexed&lt;/code&gt; 参数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;data&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非 indexed 的参数&lt;/li&gt;
&lt;li&gt;按字节数计费&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;直觉上可以这样理解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;indexed&lt;/code&gt; 参数更利于过滤和查询&lt;/li&gt;
&lt;li&gt;但 &lt;code&gt;indexed&lt;/code&gt; 并不是“免费”的&lt;/li&gt;
&lt;li&gt;data 部分越大，Gas 成本越高&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，事件设计需要在&lt;strong&gt;可查询性&lt;/strong&gt;和&lt;strong&gt;成本&lt;/strong&gt;之间取舍。&lt;/p&gt;
&lt;h3 id=&#34;83-indexed-的合理使用&#34;&gt;8.3 indexed 的合理使用
&lt;/h3&gt;&lt;p&gt;考虑一个转账事件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;event&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Transfer&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;address&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;indexed&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;from&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;address&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;indexed&lt;/span&gt; to, &lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; amount);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这种设计是合理的，因为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;from&lt;/code&gt; 和 &lt;code&gt;to&lt;/code&gt; 是最常用的查询条件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;amount&lt;/code&gt; 通常不用于过滤&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但如果写成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;event&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Transfer&lt;/span&gt;(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;address&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;indexed&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;from&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;address&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;indexed&lt;/span&gt; to,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;indexed&lt;/span&gt; amount
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;那么：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查询能力并没有显著提升&lt;/li&gt;
&lt;li&gt;Gas 成本却增加了&lt;/li&gt;
&lt;li&gt;而且 indexed 参数最多只能有 3 个&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个实用原则是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;只为“经常作为过滤条件”的字段加 indexed。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;84-避免在事件中携带大数据&#34;&gt;8.4 避免在事件中携带大数据
&lt;/h3&gt;&lt;p&gt;一个常见但代价很高的做法，是在事件中携带大量数据：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;event&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;DataUpdated&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;[] values);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这种设计的问题包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组会被完整写入日志&lt;/li&gt;
&lt;li&gt;Gas 成本随数据量线性增长&lt;/li&gt;
&lt;li&gt;链上执行成本和链下存储成本都很高&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更合理的替代方案是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只记录关键信息（如 ID、hash、计数）&lt;/li&gt;
&lt;li&gt;将完整数据存储在链下&lt;/li&gt;
&lt;li&gt;通过 hash 或索引进行关联&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;event&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;DataUpdated&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;bytes32&lt;/span&gt; dataHash);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;85-避免在链上返回大数组&#34;&gt;8.5 避免在链上返回大数组
&lt;/h3&gt;&lt;p&gt;在 Solidity 中，函数返回数组或结构体在语法上是完全合法的，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;getUsers&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;view&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;returns&lt;/span&gt; (User[] &lt;span style=&#34;color:#66d9ef&#34;&gt;memory&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;从接口设计的角度看，这样的函数非常直观：
“调用一次，就能拿到所有用户数据。”&lt;/p&gt;
&lt;p&gt;问题在于，这种直观并不等于便宜。&lt;/p&gt;
&lt;h4 id=&#34;链上调用时会发生什么&#34;&gt;链上调用时会发生什么
&lt;/h4&gt;&lt;p&gt;如果这个函数被 &lt;strong&gt;另一个合约&lt;/strong&gt; 调用，那么即使它是 &lt;code&gt;view&lt;/code&gt; 函数，也会真实消耗 Gas。
在这种情况下，EVM 需要做的事情包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从 storage 中逐个读取所有 &lt;code&gt;User&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将这些数据复制到 memory&lt;/li&gt;
&lt;li&gt;按 ABI 规则编码整个数组&lt;/li&gt;
&lt;li&gt;将编码后的字节作为返回值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些操作的成本，都会随着数组长度线性增长。&lt;/p&gt;
&lt;p&gt;也就是说，&lt;strong&gt;返回的数据越多，Gas 消耗越高，而且没有上限。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;这类成本往往是没必要的&#34;&gt;这类成本往往是“没必要的”
&lt;/h4&gt;&lt;p&gt;在实际项目中，完整的数据列表通常是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给前端或后端服务用的&lt;/li&gt;
&lt;li&gt;用于展示、统计或分析&lt;/li&gt;
&lt;li&gt;不会被其他合约在链上依赖&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而这些链下系统，完全可以通过 &lt;code&gt;eth_call&lt;/code&gt; 免费读取 view 函数的返回值。&lt;/p&gt;
&lt;p&gt;这就造成了一种常见的浪费：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;链上调用为返回数据付出了 Gas&lt;/li&gt;
&lt;li&gt;真正需要这些数据的是链下系统&lt;/li&gt;
&lt;li&gt;而链下系统本可以不花任何 Gas&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;更合理的设计思路&#34;&gt;更合理的设计思路
&lt;/h4&gt;&lt;p&gt;因此，在设计函数返回值时，应该明确区分两种使用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;链上调用的函数&lt;/strong&gt;
返回值应当尽量简单，甚至可以不返回任何数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;链下查询用的函数&lt;/strong&gt;
可以返回数组或结构体，但要意识到它们只适合通过 &lt;code&gt;eth_call&lt;/code&gt; 使用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果存在链上也需要读取部分数据的需求，那么分页或游标式接口通常是更安全的选择。&lt;/p&gt;
&lt;h3 id=&#34;86-用分页与游标来替代一次性返回&#34;&gt;8.6 用分页与游标来替代一次性返回
&lt;/h3&gt;&lt;p&gt;如果确实需要从合约中读取大量数据，更合理的方式是分页。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;getUsers&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; offset, &lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; limit)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;view&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;returns&lt;/span&gt; (User[] &lt;span style=&#34;color:#66d9ef&#34;&gt;memory&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 返回一部分数据
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这种设计的优势是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;链上调用时可以控制 Gas 上限&lt;/li&gt;
&lt;li&gt;链下系统可以逐页拉取&lt;/li&gt;
&lt;li&gt;接口行为更可预测&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;87-一个事件设计对比示例&#34;&gt;8.7 一个事件设计对比示例
&lt;/h3&gt;&lt;p&gt;不推荐的写法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;event&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OrderCreated&lt;/span&gt;(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;address&lt;/span&gt; user,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;[] itemIds,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;[] prices
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;改进后的写法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;event&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OrderCreated&lt;/span&gt;(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;address&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;indexed&lt;/span&gt; user,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;bytes32&lt;/span&gt; orderId
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;并在链下系统中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据 &lt;code&gt;orderId&lt;/code&gt; 关联完整订单数据&lt;/li&gt;
&lt;li&gt;使用事件作为“索引信号”，而不是数据载体&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种设计在可扩展性和成本上都更加合理。&lt;/p&gt;
&lt;h2 id=&#34;9-紧凑表示与低级优化谨慎使用&#34;&gt;9. 紧凑表示与低级优化（谨慎使用）
&lt;/h2&gt;&lt;p&gt;在前面的内容中，我们讨论的优化大多具备一个共同特点：
&lt;strong&gt;不牺牲可读性，风险可控，收益稳定。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在我们开始讨论一些进阶技巧，这些技巧&lt;strong&gt;确实可以省 Gas&lt;/strong&gt;，但同时也会带来：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可读性下降&lt;/li&gt;
&lt;li&gt;实现复杂度上升&lt;/li&gt;
&lt;li&gt;更高的审计和维护成本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，这一节的核心不是“教你一定要用”，而是回答：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;哪些低级优化在什么情况下值得用，什么时候应该果断放弃。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;91-位运算与-bitmap&#34;&gt;9.1 位运算与 bitmap
&lt;/h3&gt;&lt;p&gt;一个非常典型、也相对安全的进阶优化手段，是 &lt;strong&gt;bitmap（位图）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;假设你需要维护一组布尔状态，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;某个地址是否已完成某一步操作&lt;/li&gt;
&lt;li&gt;某些 ID 是否已被使用&lt;/li&gt;
&lt;li&gt;一组固定大小的开关位&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最直观的写法是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mapping&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;) used;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这种写法清晰、易懂，但每一个 &lt;code&gt;bool&lt;/code&gt; 实际上都会占用一个完整的 storage slot。&lt;/p&gt;
&lt;h4 id=&#34;使用-bitmap-的思路&#34;&gt;使用 bitmap 的思路
&lt;/h4&gt;&lt;p&gt;如果这些布尔值的 key 是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;连续的&lt;/li&gt;
&lt;li&gt;范围有限的&lt;/li&gt;
&lt;li&gt;数量较多的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么可以考虑用一个 &lt;code&gt;uint256&lt;/code&gt; 来存储 256 个布尔值：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; bitmap;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;第 n 位表示第 n 个状态&lt;/li&gt;
&lt;li&gt;通过位运算进行读写&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;isUsed&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; index) &lt;span style=&#34;color:#66d9ef&#34;&gt;internal&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;view&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;returns&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (bitmap &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; index)) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;setUsed&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; index) &lt;span style=&#34;color:#66d9ef&#34;&gt;internal&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    bitmap &lt;span style=&#34;color:#f92672&#34;&gt;|=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; index);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样做的直接收益是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用 1 个 storage slot 表示 256 个状态&lt;/li&gt;
&lt;li&gt;大幅减少 storage 读写次数&lt;/li&gt;
&lt;li&gt;在高频场景下节省可观的 Gas&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;92-bitmap-的适用边界&#34;&gt;9.2 bitmap 的适用边界
&lt;/h3&gt;&lt;p&gt;bitmap 并不是 mapping(bool) 的“全面替代”，它适合以下场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;状态数量上限明确&lt;/li&gt;
&lt;li&gt;index 可控且不来自任意用户输入&lt;/li&gt;
&lt;li&gt;逻辑相对稳定，不易变更&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不适合以下场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;key 是 address 或 hash&lt;/li&gt;
&lt;li&gt;状态数量不可预期&lt;/li&gt;
&lt;li&gt;逻辑频繁变动、需要高度可读性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个实用判断是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;如果你需要在文档中专门解释“这一位代表什么”，那就说明复杂度已经上升了。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;93-紧凑编码与省-slot思维&#34;&gt;9.3 紧凑编码与“省 slot”思维
&lt;/h3&gt;&lt;p&gt;除了 bitmap，一些项目还会尝试：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在一个 &lt;code&gt;uint256&lt;/code&gt; 中打包多个小字段&lt;/li&gt;
&lt;li&gt;用位移和掩码存储多个数值&lt;/li&gt;
&lt;li&gt;手动实现类似 storage packing 的逻辑&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; packed;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高 128 位表示余额&lt;/li&gt;
&lt;li&gt;低 128 位表示时间戳&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种写法在理论上可以减少 slot 数量，但需要注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每一次读写都需要位运算&lt;/li&gt;
&lt;li&gt;容易引入边界错误&lt;/li&gt;
&lt;li&gt;调试和审计难度明显增加&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这类优化通常只在以下情况下才值得考虑：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据结构极其稳定&lt;/li&gt;
&lt;li&gt;访问频率非常高&lt;/li&gt;
&lt;li&gt;已经确认 slot 数量是主要瓶颈&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;94-关于-assembly&#34;&gt;9.4 关于 assembly
&lt;/h3&gt;&lt;p&gt;Solidity 允许通过 &lt;code&gt;assembly&lt;/code&gt; 直接编写 EVM 指令，这意味着：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以跳过部分编译器生成的冗余逻辑&lt;/li&gt;
&lt;li&gt;在极端情况下获得更低的 Gas&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如，直接使用 &lt;code&gt;sload&lt;/code&gt;、&lt;code&gt;sstore&lt;/code&gt;、&lt;code&gt;calldataload&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;但需要非常谨慎：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;assembly 不做类型检查&lt;/li&gt;
&lt;li&gt;不提供溢出保护&lt;/li&gt;
&lt;li&gt;可读性和可维护性显著下降&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在大多数业务合约中，&lt;strong&gt;assembly 带来的收益往往小于它引入的风险&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;95-assembly-什么时候才值得用&#34;&gt;9.5 assembly 什么时候才值得用
&lt;/h3&gt;&lt;p&gt;相对合理的使用场景包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;经常被调用的“热路径”&lt;/li&gt;
&lt;li&gt;非常底层、逻辑稳定的工具函数&lt;/li&gt;
&lt;li&gt;已有充分测试覆盖&lt;/li&gt;
&lt;li&gt;有经验的开发者和审计支持&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不推荐的场景包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;业务逻辑核心&lt;/li&gt;
&lt;li&gt;权限、资金相关代码&lt;/li&gt;
&lt;li&gt;仅为了节省少量 Gas&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个保守但实用的原则是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;如果不用 assembly 也能把 Gas 控制在合理范围内，那就不要用 assembly。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;96-进阶优化的真实收益评估&#34;&gt;9.6 进阶优化的真实收益评估
&lt;/h3&gt;&lt;p&gt;需要特别强调的是，进阶优化的收益往往是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单次调用节省几十到几百 Gas&lt;/li&gt;
&lt;li&gt;只有在高频调用时才会显现价值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，在决定采用这些技巧之前，最好已经：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;完成了 storage、接口、循环等基础优化&lt;/li&gt;
&lt;li&gt;明确知道瓶颈在哪里&lt;/li&gt;
&lt;li&gt;有真实的 Gas 测试数据作为依据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;否则，很容易陷入“为优化而优化”。&lt;/p&gt;
&lt;h2 id=&#34;10-如何验证优化是否有效&#34;&gt;10. 如何验证优化是否有效
&lt;/h2&gt;&lt;p&gt;到目前为止，我们已经讨论了多种 Gas 优化手段。
但在真正的工程实践中，有一个问题始终比“怎么优化”更重要：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你怎么确定，这次优化真的有价值？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这一节的目标，是建立一种可执行的、数据驱动的优化方法，而不是依赖直觉或经验判断。&lt;/p&gt;
&lt;h3 id=&#34;101-为什么不能凭感觉判断-gas&#34;&gt;10.1 为什么不能凭感觉判断 Gas
&lt;/h3&gt;&lt;p&gt;Gas 成本并不总是和“代码复杂度”成正比：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有些看起来复杂的重构，几乎不影响 Gas&lt;/li&gt;
&lt;li&gt;有些只改了几行的调整，却能节省大量成本&lt;/li&gt;
&lt;li&gt;有些优化在小规模测试中无感，在大规模使用中差异巨大&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果没有量化数据，很容易出现两种极端：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;低估优化价值&lt;/strong&gt;：错过高收益改进&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;过度优化&lt;/strong&gt;：引入复杂性却几乎没有回报&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，Gas 优化必须是&lt;strong&gt;数据驱动的工程行为&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;102-什么是有效的-gas-优化&#34;&gt;10.2 什么是“有效的 Gas 优化”
&lt;/h3&gt;&lt;p&gt;一个优化是否有效，通常需要回答三个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;节省了多少 Gas&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;发生在多高频的执行路径上&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;引入了多少额外复杂度或风险&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;只有当节省的 Gas 与复杂度之间形成合理比例时，这次优化才是值得的。&lt;/p&gt;
&lt;h3 id=&#34;103-基准测试的基本思路&#34;&gt;10.3 基准测试的基本思路
&lt;/h3&gt;&lt;p&gt;最简单、也最可靠的方式，是对同一逻辑进行&lt;strong&gt;优化前 / 优化后对比测试&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;基本原则包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用相同的输入数据&lt;/li&gt;
&lt;li&gt;只改变你关心的那一处实现&lt;/li&gt;
&lt;li&gt;关注 &lt;code&gt;gas used&lt;/code&gt;，而不是交易费用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原始版本：函数 A&lt;/li&gt;
&lt;li&gt;优化版本：函数 A′&lt;/li&gt;
&lt;li&gt;对比两者在相同调用条件下的 Gas 消耗&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;104-一个概念级的对比示例&#34;&gt;10.4 一个概念级的对比示例
&lt;/h3&gt;&lt;p&gt;假设你有一个累加逻辑：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;[] calldata xs) &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; xs.length; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        total &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; xs[i];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;和一个优化版本：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;addOptimized&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt;[] calldata xs) &lt;span style=&#34;color:#66d9ef&#34;&gt;external&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; t &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; total;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; xs.length;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;uint256&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; len; ) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        t &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; xs[i];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;unchecked&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    total &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; t;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;你关心的不是“哪一个看起来更好”，而是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 &lt;code&gt;xs.length = 10&lt;/code&gt;、&lt;code&gt;100&lt;/code&gt;、&lt;code&gt;1000&lt;/code&gt; 时&lt;/li&gt;
&lt;li&gt;两者的 Gas 消耗曲线是否明显分离&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种对比，才能真正说明问题。&lt;/p&gt;
&lt;h3 id=&#34;105-关注最坏情况而不仅是平均值&#34;&gt;10.5 关注“最坏情况”，而不仅是平均值
&lt;/h3&gt;&lt;p&gt;在智能合约中，最坏情况往往比平均情况更重要。&lt;/p&gt;
&lt;p&gt;原因包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Gas 不够会直接导致交易失败&lt;/li&gt;
&lt;li&gt;用户更容易遇到极端输入&lt;/li&gt;
&lt;li&gt;批处理和循环的风险集中在最坏情况&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，在测试时，应当：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尝试最大允许输入&lt;/li&gt;
&lt;li&gt;覆盖边界条件&lt;/li&gt;
&lt;li&gt;关注 Gas 是否接近区块限制或函数预期上限&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;106-工具并不重要方法才重要&#34;&gt;10.6 工具并不重要，方法才重要
&lt;/h3&gt;&lt;p&gt;不同团队可能使用不同工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hardhat&lt;/li&gt;
&lt;li&gt;Foundry&lt;/li&gt;
&lt;li&gt;Truffle&lt;/li&gt;
&lt;li&gt;自定义脚本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但无论使用什么工具，核心方法都是一致的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;固定输入&lt;/li&gt;
&lt;li&gt;重复测试&lt;/li&gt;
&lt;li&gt;对比 gas used&lt;/li&gt;
&lt;li&gt;用数据支撑决策&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不要为了“用工具而用工具”，而是让工具服务于结论。&lt;/p&gt;
&lt;h3 id=&#34;107-什么时候应该停止优化&#34;&gt;10.7 什么时候应该停止优化
&lt;/h3&gt;&lt;p&gt;一个容易忽视的问题是：&lt;strong&gt;什么时候该停下来？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以考虑以下信号：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;继续优化只能节省极少量 Gas&lt;/li&gt;
&lt;li&gt;代码复杂度明显上升&lt;/li&gt;
&lt;li&gt;已经覆盖了高频和高成本路径&lt;/li&gt;
&lt;li&gt;优化收益无法抵消审计和维护成本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Gas 优化不是无止境的，而是一种平衡。&lt;/p&gt;
&lt;h2 id=&#34;11-一份可执行的-gas-优化清单&#34;&gt;11. 一份可执行的 Gas 优化清单
&lt;/h2&gt;&lt;p&gt;到这里，我们已经从 EVM 成本模型出发，系统地讨论了 Gas 优化在设计和实现层面的主要原则。
我们现在可以把前面的内容&lt;strong&gt;收敛成一份可以直接使用的清单&lt;/strong&gt;，用于日常开发和代码评审。&lt;/p&gt;
&lt;p&gt;这份清单并不是“必须全部满足”的规则集合，而是一种&lt;strong&gt;优先级导向的检查顺序&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;111-设计阶段优先检查项&#34;&gt;11.1 设计阶段优先检查项
&lt;/h3&gt;&lt;p&gt;在写代码之前，优先思考以下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是否真的需要存储这个状态，还是可以通过计算或事件获得&lt;/li&gt;
&lt;li&gt;状态变量是否会被频繁读写&lt;/li&gt;
&lt;li&gt;是否存在不受限的循环或批处理接口&lt;/li&gt;
&lt;li&gt;数据结构是否有明确的规模上限&lt;/li&gt;
&lt;li&gt;是否存在“查找/去重/删除元素”需求&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果这些问题在设计阶段就能被回答，很多 Gas 问题可以被直接避免。&lt;/p&gt;
&lt;h3 id=&#34;112-storage-相关检查项最高优先级&#34;&gt;11.2 Storage 相关检查项（最高优先级）
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;是否存在在同一函数中多次读取同一个 storage 变量的情况&lt;/li&gt;
&lt;li&gt;是否在循环中直接写 storage&lt;/li&gt;
&lt;li&gt;是否可以通过缓存变量减少 SLOAD / SSTORE&lt;/li&gt;
&lt;li&gt;状态变量和 struct 字段顺序是否合理，避免浪费 slot&lt;/li&gt;
&lt;li&gt;不再使用的状态是否及时 &lt;code&gt;delete&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;是否用 mapping 替代数组进行存在性判断、去重、按 key 查询，避免 O(n) 遍历&lt;/li&gt;
&lt;li&gt;若必须可枚举，是否使用 mapping + array + index（swap-and-pop）实现 O(1) 增删与枚举&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是最值得投入精力的优化区域。&lt;/p&gt;
&lt;h3 id=&#34;113-函数接口与参数检查项&#34;&gt;11.3 函数接口与参数检查项
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;对外接口是否优先使用 &lt;code&gt;external&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;external 函数参数是否使用 &lt;code&gt;calldata&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;是否避免了不必要的 &lt;code&gt;public&lt;/code&gt; 函数&lt;/li&gt;
&lt;li&gt;是否存在 &lt;code&gt;this&lt;/code&gt; 调用当前合约的情况&lt;/li&gt;
&lt;li&gt;是否采用了 external 入口 + internal 实现的模式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些优化通常风险低、收益稳定。&lt;/p&gt;
&lt;h3 id=&#34;114-循环与批处理检查项&#34;&gt;11.4 循环与批处理检查项
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;是否缓存了数组 length 和中间结果&lt;/li&gt;
&lt;li&gt;循环中是否避免了 storage 读写&lt;/li&gt;
&lt;li&gt;是否避免在循环中做 O(n) 查找&lt;/li&gt;
&lt;li&gt;是否在安全前提下使用 &lt;code&gt;unchecked&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;循环是否存在明确的上限&lt;/li&gt;
&lt;li&gt;批处理接口是否限制了单次处理数量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;循环是 Gas 放大器，尤其需要从“最坏情况”角度审视。&lt;/p&gt;
&lt;h3 id=&#34;115-错误处理与字节码体积&#34;&gt;11.5 错误处理与字节码体积
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;是否使用 custom error 替代 &lt;code&gt;require(string)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;错误信息是否简洁、结构化&lt;/li&gt;
&lt;li&gt;是否避免在字节码中嵌入大量字符串&lt;/li&gt;
&lt;li&gt;合约体积是否接近部署限制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些优化往往在合约复杂后才显现价值，但越早统一越好。&lt;/p&gt;
&lt;h3 id=&#34;116-事件与返回值设计&#34;&gt;11.6 事件与返回值设计
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;事件是否只记录必要信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;indexed&lt;/code&gt; 参数是否只用于高频过滤字段&lt;/li&gt;
&lt;li&gt;是否避免在事件中携带大数组或字符串&lt;/li&gt;
&lt;li&gt;是否避免链上返回大量数据&lt;/li&gt;
&lt;li&gt;是否通过分页或链下索引替代一次性查询&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里的目标是：&lt;strong&gt;不把链当数据库使用。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;117-进阶优化谨慎项&#34;&gt;11.7 进阶优化（谨慎项）
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;是否已经完成基础优化&lt;/li&gt;
&lt;li&gt;是否明确瓶颈来自 slot 数量或高频调用&lt;/li&gt;
&lt;li&gt;位运算或 bitmap 是否真的降低了 storage 使用&lt;/li&gt;
&lt;li&gt;是否避免在核心业务逻辑中滥用 assembly&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些优化应当是“有数据支撑的例外”，而不是常规手段。&lt;/p&gt;
&lt;h3 id=&#34;118-用数据驱动最终决策&#34;&gt;11.8 用数据驱动最终决策
&lt;/h3&gt;&lt;p&gt;在合并任何 Gas 优化之前，建议确认：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是否有明确的 Gas 对比数据&lt;/li&gt;
&lt;li&gt;优化是否发生在高频或关键路径&lt;/li&gt;
&lt;li&gt;引入的复杂度是否可被测试和审计覆盖&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果优化的收益无法清晰说明，那通常意味着它并不重要。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>深入理解Uniswap的集中流动性基本原理</title>
        <link>https://yearsuns-github-io.vercel.app/p/a-deep-dive-into-the-fundamental-principles-of-uniswaps-concentrated-liquidity/</link>
        <pubDate>Sat, 02 Aug 2025 14:59:56 +0800</pubDate>
        
        <guid>https://yearsuns-github-io.vercel.app/p/a-deep-dive-into-the-fundamental-principles-of-uniswaps-concentrated-liquidity/</guid>
        <description>&lt;p&gt;如果你了解过 Uniswap V2，你一定知道它最大的优点是“完全自动化”，最大的问题也是“完全自动化”。资金一旦进入，都会机械地分布在从0到∞的整个价格区间。&lt;/p&gt;
&lt;p&gt;这本来很公平，却非常低效：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;大多数时间，资产都在远离市场价格的位置“睡觉”，没有人交易到那里，也不产生手续费。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;于是，Uniswap V3 提出一个革命性的概念：集中流动性（Concentrated Liquidity）。&lt;/p&gt;
&lt;p&gt;它让 LP 可以把资金“集中”在自己认为合适的价格范围内，让“活钱干活”。&lt;/p&gt;
&lt;h2 id=&#34;一什么是集中流动性背景与要解决的问题&#34;&gt;&lt;strong&gt;一、什么是集中流动性：背景与要解决的问题&lt;/strong&gt;
&lt;/h2&gt;&lt;p&gt;去中心化交易合约 Uniswap 采用自动做市商（AMM）模型，用户无需挂单，也无需寻找对手方，只要向池子中注入两种代币，就可以成为流动性提供者。这种模式非常简洁，但也带来了一个不易察觉的问题：大部分流动性并没有发挥作用。&lt;/p&gt;
&lt;p&gt;为了说明这一点，我们需要先回顾 Uniswap v2 的机制。&lt;/p&gt;
&lt;h3 id=&#34;1-传统-amm恒定乘积与全价格区间&#34;&gt;&lt;strong&gt;1. 传统 AMM：恒定乘积与“全价格区间”&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;在 v2 的恒定乘积模型中，交易池中维持一个恒定公式：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;x · y = k&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里的 x 和 y，是池中两种资产的数量，k 是常数。无论市场价格如何波动，这个公式总是成立。&lt;/p&gt;
&lt;p&gt;但这个模型隐含一个设定：&lt;strong&gt;池子的流动性分布在从 0 到 ∞ 的整个价格范围上&lt;/strong&gt;。理论上无论价格涨到多高、跌到多低，这个池子都“准备好”提供流动性。&lt;/p&gt;
&lt;p&gt;问题是：&lt;strong&gt;真实市场的价格从来不会走到 0 或无穷大&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;换句话说，流动性被被动地散布在一个几乎永远用不上的超级宽区间里。&lt;/p&gt;
&lt;h3 id=&#34;2-流动性利用率的问题&#34;&gt;&lt;strong&gt;2. 流动性利用率的问题&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;如果流动性分布在一个过大的范围上，会造成一个非常直接的后果：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;绝大部分资金是在“睡觉”。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现实中，价格通常在一个较窄范围内波动，因此真正参与交易的，只是这个范围以内的资金。而其他资金只是静静地躺着，却仍然需要占用资本。&lt;/p&gt;
&lt;p&gt;于是就出现两个影响：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对交易者来说，主动成交的深度有限，滑点高；&lt;/li&gt;
&lt;li&gt;对 LP 来说，明明投入很多资金，收益却并不成比例。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;换句话说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;资金利用率低。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;3-为什么需要集中流动性&#34;&gt;&lt;strong&gt;3. 为什么需要集中流动性&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;Uniswap 在 v3 版本提出集中流动性（Concentrated Liquidity），核心思想非常直接：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;流动性应当放在实际会发生交易的价格区间里。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果价格长期在一个区域波动，那 LP 就可以把流动性集中在这个区域，不再浪费在可能根本不会出现的极端价格上。&lt;/p&gt;
&lt;p&gt;这样带来的效果是显著的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同样的资金，提供更深的流动性&lt;/li&gt;
&lt;li&gt;对大额交易的价格冲击减小&lt;/li&gt;
&lt;li&gt;手续费收入提高&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这实际上把 AMM 从“广泛分布”改成了“局部有效分布”。&lt;/p&gt;
&lt;h3 id=&#34;4-集中流动性的定义&#34;&gt;&lt;strong&gt;4. 集中流动性的定义&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;严格来说，集中流动性是指：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;LP 只在自己设定的价格区间 \([P_{lower}, P_{upper}]\) 内提供流动性，一旦价格超出范围，就不再参与交易，也不再赚费。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这意味着，每一个 LP 不再是一个简单的资金池，而变成一个“带有条件的流动性头寸”。&lt;/p&gt;
&lt;p&gt;从合约的角度看，是把一个大池子拆成很多小区间，把流动性分别放入这些区间，交易发生在哪个区间，哪个区间的 LP 就得到手续费。&lt;/p&gt;
&lt;h3 id=&#34;5-它解决的到底是什么问题&#34;&gt;&lt;strong&gt;5. 它解决的到底是什么问题&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;如果用一句话概括：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;用同样的资本，获得更高的有效深度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但具体来说，它带来三项核心改进：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;提高资本效率&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;降低滑点&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提高 LP 的费收益率&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些优点都来自同一个事实：流动性终于可以集中，而不是无边界地稀释。&lt;/p&gt;
&lt;h3 id=&#34;6-但它并不是免费的优化&#34;&gt;&lt;strong&gt;6. 但它并不是免费的优化&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;集中流动性并没有改变 AMM 的基本逻辑，而是引入一个新的维度：&lt;strong&gt;价格区间&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这让 LP 的岗位变得更像需要判断价格趋势的“策略性角色”。因此，集中流动性同时带来了一个新的风险：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果价格突破区间，头寸会变成单边资产，并停止产生收益。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了获得更高的收益，需要承担更多管理与判断成本。这是一种典型的“收益与风险互换”关系。&lt;/p&gt;
&lt;h2 id=&#34;二集中流动性是如何运行的&#34;&gt;&lt;strong&gt;二、集中流动性是如何运行的&lt;/strong&gt;
&lt;/h2&gt;&lt;h3 id=&#34;1-提供流动性需要输入什么&#34;&gt;&lt;strong&gt;1. 提供流动性需要输入什么&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;假设我们向 ETH/USDC 池子提供流动性，合约会要求我们输入：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;币对：ETH / USDC&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;价格区间&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lower price 例：2000 USDC/ETH&lt;/li&gt;
&lt;li&gt;upper price 例：3000 USDC/ETH&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;想提供多少 ETH 或多少 USDC&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;也就是说，我们其实是在告诉合约三件事：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我想参与 ETH / USDC 交易对的做市&lt;/li&gt;
&lt;li&gt;在 2000～3000 这个区间&lt;/li&gt;
&lt;li&gt;我愿意提供多少币&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-需要提供什么代币&#34;&gt;&lt;strong&gt;2. 需要提供什么代币&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;假设当前 ETH/USDC 价格是 2500，那么系统判断为：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;2000 &amp;lt; 2500 &amp;lt; 3000
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也就是“价格在区间内”。&lt;/p&gt;
&lt;p&gt;这个判断非常重要，因为它直接影响我们需要提供的资产结构：&lt;/p&gt;
&lt;h4 id=&#34;三种情况&#34;&gt;三种情况
&lt;/h4&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;当前价格&lt;/th&gt;
          &lt;th&gt;需要提供&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;在区间内&lt;/td&gt;
          &lt;td&gt;需要同时提供 ETH 和 USDC&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;当前价格低于区间&lt;/td&gt;
          &lt;td&gt;只会用到 USDC&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;当前价格高于区间&lt;/td&gt;
          &lt;td&gt;只会用到 ETH&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;为什么会这样？它不是策略，而是数学决定的：&lt;strong&gt;AMM 会在不同价格状态下，自动将持仓偏向一种资产，这由模型决定，不是策略行为。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简单地理解就是，物以稀为贵。当价格较低时，交易池需要更多的 USDC，当价格较高时，交易池需要更多的 ETH。&lt;/p&gt;
&lt;h3 id=&#34;3-理解流动性&#34;&gt;&lt;strong&gt;3. 理解流动性&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;虽然我们给的是资产（ETH/USDC），但合约内部记录的是一个抽象量 L（流动性单位）。&lt;/p&gt;
&lt;p&gt;理解要点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们投入的是资产&lt;/li&gt;
&lt;li&gt;合约记录的是 L&lt;/li&gt;
&lt;li&gt;我们未来赚的钱与 L 成正比&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更直观说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;L 就像我们在这个价格区间的“份额大小”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而 ETH / USDC 的数量，会随着价格变化自动调整。&lt;/p&gt;
&lt;h3 id=&#34;4-价格区间离散化&#34;&gt;&lt;strong&gt;4. 价格区间离散化&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;我们给的区间是连续价格（比如 2000→3000），但合约内部用 tick 记录价格。&lt;/p&gt;
&lt;p&gt;合约会把它们转成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;\(tick_{Lower}\)&lt;/li&gt;
&lt;li&gt;\(tick_{Upper}\)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;tick 是一个离散价格，用来标记区间边界。&lt;/p&gt;
&lt;p&gt;这一步之后，合约会为这个区间范围增加相应的流动性，实际记录方式为只记录边界状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 \(tick_{Lower}\) 位置把流动性 +L&lt;/li&gt;
&lt;li&gt;在 \(tick_{Upper}\) 位置把流动性 -L&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样，当前活跃的流动性等于所有当前价格以下的净流动性之和：&lt;/p&gt;
\[
   activeLiquidity = \sum (netLiquidity &lt; \text{current tick})
\]&lt;p&gt;比如 \(tick_{Lower}=100\), \(tick_{Upper}=200\)，合约会记录为&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;netLiquidity[100] += 10
netLiquidity[200] -= 10
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果当前价格 tick 是 150，那么 activeLiquidity 等于所有 tick &amp;lt; 150 的 netLiquidity 之和，也就是10&lt;/p&gt;
&lt;p&gt;如果当前价格 tick 是 205，那么 activeLiquidity 等于所有 tick &amp;lt; 205 的 netLiquidity 之和，也就是0&lt;/p&gt;
&lt;p&gt;所以，当价格穿过这些 tick 时，系统就知道应该在什么时候开始、什么时候结束使用我们的流动性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么在存储区间时，要对价格进行离散处理？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果用线性划分，当 ETH/USDC 的价格在 2000～3000 区间时，简单切 1000 段，每段 1USDC，当然可以，看起来也很自然。&lt;/p&gt;
&lt;p&gt;但是如果价格区间变为 0.2~0.3 或者更低呢？还是按照切 1000 段，就会导致每段区间过小，整体刻度是极不均匀的。&lt;/p&gt;
&lt;p&gt;而且真实情况下，不同代币的价格可能跨越几个数量级，从 0.0000001 到 10000000 都可能，因此也无法为所有的币统一刻度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何进行离散处理呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们设定每个刻度对应的价格是前一个刻度对应价格的固定倍数 \(r\)，那么对于tick+1刻度的价格 \(P_{tick+1}\) 有以下公式&lt;/p&gt;
&lt;blockquote&gt;
\[
   P_{tick+1} = P_{tick} \times r
  \]&lt;/blockquote&gt;
&lt;p&gt;由此就很容易推导出以下公式&lt;/p&gt;
&lt;blockquote&gt;
\[
   P_{tick} = P_0 \times r^{tick}
  \]&lt;/blockquote&gt;
&lt;p&gt;如果设定初始值 \(P_0=1\)，常量 \(r=1.0001\)，则可以得到&lt;/p&gt;
&lt;blockquote&gt;
\[
   P_{tick} = 1.0001^{tick}
  \]&lt;/blockquote&gt;
&lt;p&gt;这意味着每次 tick 移动，价格变 0.01%。&lt;/p&gt;
&lt;p&gt;现在我们就可以将任意价格使用tick表示&lt;/p&gt;
&lt;blockquote&gt;
\[
   tick = log_{1.0001}P
  \]&lt;/blockquote&gt;
&lt;p&gt;比如&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;\(P=0.25\) 对应的 \(tick\approx-13864\)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;\(P=2500\) 对应的 \(tick\approx78244\)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么我们的均匀刻度就设计好了，它可以适用于任意价格的代币（只要价格不是负数🤪）&lt;/p&gt;
&lt;h3 id=&#34;5-保存流动性状态&#34;&gt;&lt;strong&gt;5. 保存流动性状态&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;当我们添加流动性时，系统会给我们分配一个 NFT，它记录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择的区间（2000～3000）&lt;/li&gt;
&lt;li&gt;L 的大小&lt;/li&gt;
&lt;li&gt;已经累计能够领取的手续费&lt;/li&gt;
&lt;li&gt;后续计算手续费需要用到的当前 fee 状态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;做市行为不再是池子的一部分，而是一个 NFT 记录的独立头寸。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;6-持仓变化&#34;&gt;&lt;strong&gt;6. 持仓变化&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;当价格在区间内：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同时持有 ETH 和 USDC&lt;/li&gt;
&lt;li&gt;随着交易发生，两者互相转换&lt;/li&gt;
&lt;li&gt;参与撮合并赚手续费&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果价格跌破 &lt;strong&gt;2000&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;头寸会变成全部 USDC&lt;/li&gt;
&lt;li&gt;不再参与做市，也停止赚手续费&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果价格突破 &lt;strong&gt;3000&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;头寸会变成全部 ETH&lt;/li&gt;
&lt;li&gt;同样退出做市&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;换句话说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ETH 涨，头寸更偏 ETH；ETH 跌，头寸更偏 USDC。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个行为不是策略，而是 AMM 自动完成的结果。&lt;/p&gt;
&lt;h3 id=&#34;7-手续费结算&#34;&gt;&lt;strong&gt;7. 手续费结算&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;交易发生在区间内（2500在内），就会累积手续费。合约内部会把手续费累计到该区间的 feeGrowth 中。&lt;/p&gt;
&lt;p&gt;提现时合约会做两件事：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;返回当前持仓（可能是 ETH+USDC，可能是单币）&lt;/li&gt;
&lt;li&gt;返回累计所得手续费&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不需要手动领，提现时自动结算。&lt;/p&gt;
&lt;h2 id=&#34;三主要公式推导&#34;&gt;&lt;strong&gt;三、主要公式推导&lt;/strong&gt;
&lt;/h2&gt;&lt;h3 id=&#34;1-官方白皮书&#34;&gt;&lt;strong&gt;1. 官方白皮书&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;v2链接： &lt;a class=&#34;link&#34; href=&#34;https://docs.uniswap.org/whitepaper.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.uniswap.org/whitepaper.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;v3链接： &lt;a class=&#34;link&#34; href=&#34;https://app.uniswap.org/whitepaper-v3.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://app.uniswap.org/whitepaper-v3.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;v4链接： &lt;a class=&#34;link&#34; href=&#34;https://app.uniswap.org/whitepaper-v4.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://app.uniswap.org/whitepaper-v4.pdf&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-基础公式&#34;&gt;&lt;strong&gt;2. 基础公式&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;虚拟资金池曲线（交易模型）&lt;/p&gt;
\[
   x \times y = k \tag{1}
\]&lt;p&gt;流动性&lt;/p&gt;
\[
   L = \sqrt{xy} \tag{2}
\]&lt;p&gt;价格&lt;/p&gt;
\[
   P = \frac{y}{x} \tag{3}
\]&lt;p&gt;有效资金池曲线&lt;/p&gt;
\[
   (x+\dfrac{L}{\sqrt{p_{b}}})(y+L\sqrt{p_{a}})=L^{2} \tag{4}
\]&lt;h3 id=&#34;2-有效资金池曲线推导&#34;&gt;&lt;strong&gt;2. 有效资金池曲线推导&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://yearsuns-github-io.vercel.app/p/a-deep-dive-into-the-fundamental-principles-of-uniswaps-concentrated-liquidity/virtual_reserves.png&#34;
	width=&#34;1880&#34;
	height=&#34;1466&#34;
	srcset=&#34;https://yearsuns-github-io.vercel.app/p/a-deep-dive-into-the-fundamental-principles-of-uniswaps-concentrated-liquidity/virtual_reserves_hu_7f2418a223292b52.png 480w, https://yearsuns-github-io.vercel.app/p/a-deep-dive-into-the-fundamental-principles-of-uniswaps-concentrated-liquidity/virtual_reserves_hu_577fb5efdb443dce.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;图1 虚拟资金池&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;128&#34;
		data-flex-basis=&#34;307px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;根据上图1所示，当前价格在 c 点，假设实际价格的波动范围为 [a,b]&lt;/p&gt;
&lt;p&gt;那么当价格从 c 点向 a 点滑动时，资金池的消耗最大为 \(y_{real}\) ，同理，当价格由 c 点向 b 点滑动时，资金池的消耗最大为 \(x_{real}\)&lt;/p&gt;
&lt;p&gt;因此，理论上只需要提供 \(x_{real}\) 和 \(y_{real}\) 就够了，其余的资金是永远都用不上的，这也说明了为什么xyk基础模型的资金利用率低&lt;/p&gt;
&lt;p&gt;那么问题来了，实际有效的资金池曲线应该是什么样的呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://yearsuns-github-io.vercel.app/p/a-deep-dive-into-the-fundamental-principles-of-uniswaps-concentrated-liquidity/effective_reserves.png&#34;
	width=&#34;720&#34;
	height=&#34;592&#34;
	srcset=&#34;https://yearsuns-github-io.vercel.app/p/a-deep-dive-into-the-fundamental-principles-of-uniswaps-concentrated-liquidity/effective_reserves_hu_7e45aaaa6c8583ea.png 480w, https://yearsuns-github-io.vercel.app/p/a-deep-dive-into-the-fundamental-principles-of-uniswaps-concentrated-liquidity/effective_reserves_hu_d0a3c978ce198002.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;图2 有效资金池&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;121&#34;
		data-flex-basis=&#34;291px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;如上图2所示，我们开始推导这个有效资金池曲线公式&lt;/p&gt;
\[
   L^2 = xy \\
   P = \frac{y}{x}
\]&lt;p&gt;对于攻读过初中数学学位的人来说，将等式两边相乘和相除就可以轻松推导出以下公式&lt;/p&gt;
\[
\begin{aligned}
   x=\dfrac{L}{\sqrt{P}} \\
   y=L\sqrt{P} \tag{4}
\end{aligned}
\]&lt;p&gt;由图1可知&lt;/p&gt;
\[
   x=x_{real}+x_b \\
   y=y_{real}+y_a
\]&lt;p&gt;代入公式 (1) 的 xyk 模型可得&lt;/p&gt;
\[
   (x_{real}+x_b)(y_{real}+y_a)=k=L^2
\]&lt;p&gt;再根据公式 (4) 将 \(x_b, y_a\) 替换可得&lt;/p&gt;
\[
   (x_{real}+\dfrac{L}{\sqrt{P_{b}}})(y_{real}+L\sqrt{P_{a}})=L^{2}
\]&lt;p&gt;这就是最终的有效资金池曲线了&lt;/p&gt;
&lt;h3 id=&#34;3-计算流动性变化&#34;&gt;&lt;strong&gt;3. 计算流动性变化&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;我们提供流动性后，合约开始进行各种交易行为，那么要如何计算当前我们提供的流动性中资产是如何分配的？&lt;/p&gt;
&lt;p&gt;根据上面的公式(4)：&lt;/p&gt;
\[
\begin{aligned}
   x=\dfrac{L}{\sqrt{p}} \\
   y=L\sqrt{P} \tag{4}
\end{aligned}
\]&lt;p&gt;令：&lt;/p&gt;
\[
\begin{aligned}
   S = \sqrt{P}
\end{aligned}
\]&lt;p&gt;则：&lt;/p&gt;
\[
\begin{aligned}
   x=\dfrac{L}{S} \\
   y=LS
\end{aligned}
\]&lt;p&gt;因为 L 不变，对 S 求微分：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对 x：&lt;/strong&gt;&lt;/p&gt;
\[
x = \frac{L}{S}
\Rightarrow dx = -L \frac{1}{S^2} dS
\]&lt;p&gt;&lt;strong&gt;对 y：&lt;/strong&gt;&lt;/p&gt;
\[
y = L S
\Rightarrow dy = L dS
\]&lt;p&gt;所以有两条很重要的微分关系：&lt;/p&gt;
\[
dx = -L \frac{1}{S^2} dS,\qquad dy = L dS
\]&lt;p&gt;假设一个 LP 的有效价格区间是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下界价格：\(P_a\)，对应 \(S_a = \sqrt{P_a}\)&lt;/li&gt;
&lt;li&gt;上界价格：\(P_b\)，对应 \(S_b = \sqrt{P_b}\)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;只看 \(token_y\) 的变化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在区间内，S 从 (S_a) 增长到 (S_b) 时：&lt;/p&gt;
\[
dy = L dS
\]&lt;p&gt;对 S 从 (S_a) 到 (S_b) 积分：&lt;/p&gt;
\[
\Delta y = \int_{S_a}^{S_b} L, dS
= L (S_b - S_a)
= L(\sqrt{P_b} - \sqrt{P_a})
\]&lt;p&gt;这就是 &lt;strong&gt;在整个 \([P_a, P_b]\) 区间里对应的 \(token_y\) 数量&lt;/strong&gt;：&lt;/p&gt;
\[
amount_y = L(\sqrt{P_b} - \sqrt{P_a})
\]&lt;p&gt;&lt;strong&gt;只看 \(token_x\)的变化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对 \(token_x\)：&lt;/p&gt;
\[
dx = -L \frac{1}{S^2} dS
\]&lt;p&gt;注意：
x 和 S 方向相反（价格上升 → \(token_x\) 减少），
我们要的是区间内总共的 \(token_x\) 数量，取绝对值来算：&lt;/p&gt;
\[
\Delta x = \int_{S_a}^{S_b} L \frac{1}{S^2} dS
\]&lt;p&gt;计算：&lt;/p&gt;
\[
\int \frac{1}{S^2} dS = -\frac{1}{S}
\]&lt;p&gt;所以：&lt;/p&gt;
\[
\Delta x
= L\left[-\frac{1}{S}\right]_{S_a}^{S_b}
= L\left(-\frac{1}{S_b} + \frac{1}{S_a}\right)
= L\left(\frac{1}{S_a} - \frac{1}{S_b}\right)
\]&lt;p&gt;代回 \(S = \sqrt{P}\)：&lt;/p&gt;
\[
amount_x = L\left(\frac{1}{\sqrt{P_a}} - \frac{1}{\sqrt{P_b}}\right)
\]&lt;p&gt;这就是 \(token_x\) 的区间公式。&lt;/p&gt;
&lt;p&gt;上面推导的是整个 \([P_a, P_b]\) 区间的总 x/y。
但实际情况取决于当前价格 (P) 在区间里的位置：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;情况 A：当前价格在区间内部（\(P_a &lt; P &lt; P_b\)）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这时的头寸是“部分在 token0，部分在 token1”：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对 \(token_x\)，有效区间是 [P, Pb]
（高价端还没被换走的 \(token_x\)）&lt;/p&gt;
\[
  amount_x = L\left(\frac{1}{\sqrt{P}} - \frac{1}{\sqrt{P_b}}\right)
  \]&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对 \(token_y\)，有效区间是 [Pa, P]
（从下界到现在已经变成 \(token_y\) 的部分）&lt;/p&gt;
&lt;p&gt;[
amount_y = L(\sqrt{P} - \sqrt{P_a})
]&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;情况 B：价格低于区间（\(P \le P_a\)）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;还没开始“向上走”，流动性全部在 \(token_x\) 形态：&lt;/p&gt;
\[
amount_x = L\left(\frac{1}{\sqrt{P_a}} - \frac{1}{\sqrt{P_b}}\right) \\
\quad amount_y = 0
\]&lt;p&gt;&lt;strong&gt;情况 C：价格高于区间（\(P \ge P_b\)）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;已经“完全向上走完”，全部变成 \(token_y\)：&lt;/p&gt;
\[
amount_x = 0 \\
\quad amount_y = L(\sqrt{P_b} - \sqrt{P_a})
\]&lt;h3 id=&#34;4-计算实际交易价格&#34;&gt;&lt;strong&gt;4. 计算实际交易价格&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;我们已经知道了交易原理和基本公式，那么当我们准备通过交易池兑换代币时，因为我们投入的资产也会影响交易池的资产比例，\(P=\dfrac{y}{x}\) 只是理论价格，那么应该如何计算实际交易价格呢？比如说1个 ETH 能换多少 USDC ？&lt;/p&gt;
&lt;p&gt;当我们往池子里投入 \(\Delta x\) 个 ETH 时，池中的 USDC 会减少 \(\Delta y\)，对应的价格也会从 \(P_0\) 下跌到 \(P_1\)，于是有以下关系&lt;/p&gt;
\[
\begin{aligned}
\Delta x &amp;= L\left(\frac{1}{\sqrt{P_1}} - \frac{1}{\sqrt{P_0}}\right) = L\left(\frac{1}{S_1} - \frac{1}{S_0}\right) 
\Rightarrow 
S_1 = \frac{1}{\dfrac{\Delta x}{L} + \dfrac{1}{S_0}} \\
\Delta y &amp;= L(\sqrt{P_0} - \sqrt{P_1}) = L(S_0 - S_1) = 
L\left(S_0 - \frac{1}{\dfrac{\Delta x}{L} + \dfrac{1}{S_0}}\right)
\end{aligned}
\]&lt;p&gt;其中，L为当前区间的流动性。&lt;/p&gt;
&lt;p&gt;如果交易量很大、会跨 tick，就把区间拆成多段，对每一段用同样的方法算一段，然后把每一段的 Δy 累加起来即可。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>深入理解Uniswap的XYK模型基本原理</title>
        <link>https://yearsuns-github-io.vercel.app/p/a-deep-dive-into-the-fundamental-principles-of-uniswaps-xyk-model/</link>
        <pubDate>Wed, 16 Jul 2025 14:59:56 +0800</pubDate>
        
        <guid>https://yearsuns-github-io.vercel.app/p/a-deep-dive-into-the-fundamental-principles-of-uniswaps-xyk-model/</guid>
        <description>&lt;blockquote&gt;
&lt;p&gt;XYK 就是：把一对资产放进一个“水池”，规定池里两种资产数量的乘积始终相等 &lt;code&gt;x * y = k&lt;/code&gt;；
所有交易都必须沿着这条规则移动，于是&lt;strong&gt;价格、滑点、收益、风险&lt;/strong&gt;都从这个公式里自然长出来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下来我们通过简单推导，一步一步厘清这其中的数学逻辑。&lt;/p&gt;
&lt;h2 id=&#34;一传统交易为什么非得有个订单簿&#34;&gt;一、传统交易：为什么非得有个订单簿？
&lt;/h2&gt;&lt;p&gt;在传统交易所里，核心是一个&lt;strong&gt;订单簿&lt;/strong&gt;（Order Book）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A 在 100 元挂买 1 个 ETH&lt;/li&gt;
&lt;li&gt;B 在 101 元挂卖 2 个 ETH&lt;/li&gt;
&lt;li&gt;系统把买单卖单匹配，&lt;strong&gt;撮合成交&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种模式有几个典型特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;需要专业做市商&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果没人挂单，普通人根本没法交易&lt;/li&gt;
&lt;li&gt;做市商需要 24 小时盯盘、调价&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;需要一个中心化撮合引擎&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由交易所运营&lt;/li&gt;
&lt;li&gt;你必须“相信”这个中间人&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;普通人难以参与做市&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提供流动性门槛很高&lt;/li&gt;
&lt;li&gt;很多收益只掌握在少数机构手里&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于区块链这种“人人都可以参与”的世界来说，这种设计太“中心化”了。&lt;/p&gt;
&lt;h2 id=&#34;二amm把做市变成一个资金池&#34;&gt;二、AMM：把做市变成一个资金池
&lt;/h2&gt;&lt;p&gt;AMM（自动做市商）最大的创新，是把交易市场从“挂单撮合 → 双边参与”变成了“资金池 → 任何人都能加入”。&lt;/p&gt;
&lt;p&gt;资金池（Liquidity Pool）里同时放入两种资产，例如 ETH 和 USDT。池子运行遵循一个数学规则：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;x * y = k
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这就是所谓的 &lt;strong&gt;XYK（x*y=k）恒定乘积做市模型&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;只要有人用 USDT 买 ETH，那么 ETH 减少、USDT 增多，就必须自动调整数值，使乘积保持不变。&lt;/p&gt;
&lt;p&gt;这个规则取代了订单簿：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无需挂买卖单&lt;/li&gt;
&lt;li&gt;无需专业做市商&lt;/li&gt;
&lt;li&gt;无需中心化撮合引擎&lt;/li&gt;
&lt;li&gt;任意用户都能参与&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以 AMM 的本质是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;用一个资金池 + 一个数学公式 替代传统撮合系统。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;价格、滑点、流动性深度等概念，全部从这个公式里自然推导出来。&lt;/p&gt;
&lt;h2 id=&#34;三价格是怎么算出来的&#34;&gt;三、价格是怎么算出来的？
&lt;/h2&gt;&lt;p&gt;先设定一个具体例子：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;池子里有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ETH：&lt;code&gt;x = 100&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;USDT：&lt;code&gt;y = 10000&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;那 ETH 的价格是什么？&lt;/p&gt;
&lt;p&gt;很自然的想法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;价格 = USDT 数量 / ETH 数量 = y / x = 10000 / 100 = 100 USDT
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;几点关键认识：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;价格不是“挂出来的”，而是由池子状态算出来的&lt;/li&gt;
&lt;li&gt;池子状态一变，价格就自动变化&lt;/li&gt;
&lt;li&gt;这个价格是“池内价格”，会被外部市场套利修正&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以在 AMM 中：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;价格 = 池内两种资产的数量比&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;四交易是怎么推动价格变动的&#34;&gt;四、交易是怎么推动价格变动的？
&lt;/h2&gt;&lt;p&gt;现在我们来做一个简单但非常重要的例子。&lt;/p&gt;
&lt;h3 id=&#34;41-初始状态&#34;&gt;4.1 初始状态
&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;x = 100 ETH
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;y = 10000 USDT
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;k = x * y = 100 * 10000 = 1,000,000
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;价格 P₀ = y / x = 100 USDT/ETH
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;有个用户想用 &lt;strong&gt;1000 USDT 买 ETH&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在 AMM 中，交易规则是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;交易前后都要满足：&lt;code&gt;x * y = k&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;42-交易后的新状态&#34;&gt;4.2 交易后的新状态
&lt;/h3&gt;&lt;p&gt;用户往池子里&lt;strong&gt;加入 1000 USDT&lt;/strong&gt;，记为 &lt;code&gt;Δy = +1000&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;交易后 USDT 数量：
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;y₂ = 10000 + 1000 = 11000
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;因为 x * y 要保持等于 1,000,000：
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;x₂ = k / y₂ = 1,000,000 / 11000 ≈ 90.909 ETH
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;那么，用户从池子里拿走的 ETH 是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Δx = x₁ - x₂ = 100 - 90.909 ≈ 9.091 ETH
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;他实际上用 1000 USDT 买到了约 9.091 ETH：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;平均买入价格 ≈ 1000 / 9.091 ≈ 110 USDT/ETH
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而此时新价格为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;P₁ = y₂ / x₂ ≈ 11000 / 90.909 ≈ 121 USDT/ETH
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;你会看到三件事：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户最后的平均买价 ≈ 110&lt;/li&gt;
&lt;li&gt;交易结束时的最新价格 ≈ 121&lt;/li&gt;
&lt;li&gt;一开始池子的价格是 100&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这就是现实里感受到的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“怎么我一买，价格就上去了，还越买越贵？”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这就是 &lt;strong&gt;滑点（Slippage）&lt;/strong&gt; 的来源。&lt;/p&gt;
&lt;h2 id=&#34;五滑点不是费用而是你自己推高的价格&#34;&gt;五、滑点：不是费用，而是你自己推高的价格
&lt;/h2&gt;&lt;p&gt;从上面的例子可以总结：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;滑点并不是额外收费&lt;/li&gt;
&lt;li&gt;而是：&lt;strong&gt;因为你的这笔交易改变了池子的价格&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以粗略理解为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;你在交易的过程中，从&lt;strong&gt;便宜 → 贵&lt;/strong&gt; 的一整条价格区间上买了一段货。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;交易越大，沿着曲线走得越远，平均买入价就比起点价格高得越多。&lt;/p&gt;
&lt;h2 id=&#34;六为什么池子越大滑点越小&#34;&gt;六、为什么池子越大，滑点越小？
&lt;/h2&gt;&lt;p&gt;做一个对比试验。&lt;/p&gt;
&lt;h3 id=&#34;61-小池子100-eth--10000-usdt&#34;&gt;6.1 小池子：100 ETH / 10000 USDT
&lt;/h3&gt;&lt;p&gt;还是刚才的池子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;100 ETH&lt;/li&gt;
&lt;li&gt;10000 USDT&lt;/li&gt;
&lt;li&gt;用 1000 USDT 买，价格从 100 → 121，变化很明显&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;62-大池子1000-eth--100000-usdt&#34;&gt;6.2 大池子：1000 ETH / 100000 USDT
&lt;/h3&gt;&lt;p&gt;换成一个更大的池子（&lt;strong&gt;放大 10 倍&lt;/strong&gt;）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;x = 1000
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;y = 100000
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;k = 1000 * 100000 = 100,000,000
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;初始价格 = 100,000 / 1000 = 100 USDT/ETH
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;同样用 1000 USDT 买：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;y₂ = 100000 + 1000 = 101000
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;x₂ = k / y₂ = 100,000,000 / 101000 ≈ 990.099 ETH
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Δx ≈ 1000 - 990.099 ≈ 9.901 ETH
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;平均买入价 ≈ 1000 / 9.901 ≈ 101.0 USDT/ETH
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;新价格 P₁ ≈ 101000 / 990.099 ≈ 102.0 USDT/ETH
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对比一下：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;池子大小&lt;/th&gt;
          &lt;th&gt;初始价&lt;/th&gt;
          &lt;th&gt;平均买价&lt;/th&gt;
          &lt;th&gt;最终价格&lt;/th&gt;
          &lt;th&gt;价格涨幅&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;小池（100 / 10000）&lt;/td&gt;
          &lt;td&gt;100&lt;/td&gt;
          &lt;td&gt;≈110&lt;/td&gt;
          &lt;td&gt;≈121&lt;/td&gt;
          &lt;td&gt;涨 21%&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;大池（1000 / 100000）&lt;/td&gt;
          &lt;td&gt;100&lt;/td&gt;
          &lt;td&gt;≈101&lt;/td&gt;
          &lt;td&gt;≈102&lt;/td&gt;
          &lt;td&gt;涨 2%&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;结论：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;池子越大，单笔交易对价格的影响越小，滑点就越低。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;直觉类比：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;小池子像一个脸盆，你舀一桶水进去，水位变化很明显&lt;/li&gt;
&lt;li&gt;大池子像一个湖，你舀一桶水进去，没啥感觉&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这就是“流动性深度”的直观意义。&lt;/p&gt;
&lt;h2 id=&#34;七流动性到底是什么&#34;&gt;七、流动性：到底是什么？
&lt;/h2&gt;&lt;p&gt;在 AMM 中，“流动性”不再是一个抽象词，而是&lt;strong&gt;池子里真实存在的资产数量&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;流动性越多 → 曲线越“平滑” → 价格越稳定&lt;/li&gt;
&lt;li&gt;流动性越少 → 曲线越“陡峭” → 价格更容易被推飞&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更重要的是：在 AMM 中，&lt;strong&gt;任何人都可以提供流动性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这意味着：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;原本只有专业做市商能干的事，现在所有用户都能做，而且还能赚手续费。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;八作为普通人你怎么参与这个池子&#34;&gt;八、作为普通人，你怎么参与这个池子？
&lt;/h2&gt;&lt;p&gt;假设现在有一个 ETH/USDT 池，状态是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;x = 100 ETH
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;y = 10000 USDT
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;价格是 100 USDT/ETH。&lt;/p&gt;
&lt;p&gt;你想成为 LP（流动性提供者），往里加一点资金。&lt;/p&gt;
&lt;h3 id=&#34;81-必须按当前价格比例存入&#34;&gt;8.1 必须按当前价格比例存入
&lt;/h3&gt;&lt;p&gt;因为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;池子里的资产比例本身就是价格&lt;/li&gt;
&lt;li&gt;如果你随便乱放，只放 ETH 不放 USDT，就会破坏价格&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以系统要求：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;你要&lt;strong&gt;按当前价格的比例&lt;/strong&gt;同时存入两种资产。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;想存入 &lt;code&gt;1 ETH&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当前价格是 &lt;code&gt;100 USDT/ETH&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;那就需要再存入 &lt;code&gt;100 USDT&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这时：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;x_new = 101 ETH
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;y_new = 10100 USDT
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;价格仍然 = 10100 / 101 = 100 USDT/ETH
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;价格没有被你改变，池子只是&lt;strong&gt;变大了一点&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;82-你获得份额凭证&#34;&gt;8.2 你获得“份额凭证”
&lt;/h3&gt;&lt;p&gt;每个 LP 存入资产后，会得到一个代表池子份额的代币（LP Token）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;整个池子好比一个“蛋糕”&lt;/li&gt;
&lt;li&gt;你按照你贡献的资产获得“蛋糕份额”&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将来你退出时：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;你拿回的是 &lt;strong&gt;当时池子里的一部分资产&lt;/strong&gt;，而不是你最初存进去的那一模一样的组合。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这一点，是理解“无常损失”的基础。&lt;/p&gt;
&lt;h2 id=&#34;九手续费lp-是怎么赚钱的&#34;&gt;九、手续费：LP 是怎么赚钱的？
&lt;/h2&gt;&lt;p&gt;每一笔交易，协议一般会收取一小部分手续费（比如 0.3%），这笔钱：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;不是给“平台”拿走&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;而是&lt;strong&gt;直接进入资金池&lt;/strong&gt;，按份额分给所有 LP&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以这样理解：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;交易者在用你的资产做交换，你从中抽取一点点“路费”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单模拟：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;你占池子 10% 的份额&lt;/li&gt;
&lt;li&gt;全池一共累积了 1000 USDT 的手续费&lt;/li&gt;
&lt;li&gt;你退出时，就拿到大约 100 USDT 的手续费收益（再加上池子里的资产变化）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以 LP 的收入来源主要有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;交易手续费&lt;/li&gt;
&lt;li&gt;某些协议发放的激励（比如奖励代币）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;十无常损失为什么-lp-会看起来亏了&#34;&gt;十、无常损失：为什么 LP 会看起来亏了？
&lt;/h2&gt;&lt;p&gt;虽然 LP 可以赚手续费，但也会面临一个著名问题：&lt;strong&gt;无常损失&lt;/strong&gt;（Impermanent Loss）。&lt;/p&gt;
&lt;p&gt;先看一个最直观、最典型、最容易理解的例子。&lt;/p&gt;
&lt;p&gt;假设池子里只有：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;1 ETH + 100 USDT
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这表示当前价格隐含为：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;1 ETH = 100 USDT
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在你作为 LP 存入等价的资产（即同样按照当前价格比例）：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;再存入 1 ETH + 100 USDT（价值 200 USDT）
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;池子变成：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;2 ETH + 200 USDT
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;总价值 400 USDT，而你贡献了其中 200 USDT，也就是：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;你占整个池子的 50%
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;101-lp-份额不会变但池子的资产会变&#34;&gt;10.1 LP 份额不会变，但池子的资产会变
&lt;/h3&gt;&lt;p&gt;注意：作为 LP，你拥有的是池子整体的 &lt;strong&gt;份额（%）&lt;/strong&gt;，不是具体资产数量。&lt;/p&gt;
&lt;p&gt;也就是说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;你拥有池子 50%，但未来那“50%”里面，ETH 和 USDT 的数量会变。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;102-假设市场发生变化&#34;&gt;10.2 假设市场发生变化
&lt;/h3&gt;&lt;p&gt;经过一段时间，如果 ETH 相对 USDT 的价格下降，为了维持恒定乘积规则，池子里的 ETH 会变多，USDT 会变少。&lt;/p&gt;
&lt;p&gt;假设最终池子变成：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;4 ETH + 100 USDT
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;别看：数量看起来好像多了，但我们来计算 LP 的实际资产。&lt;/p&gt;
&lt;p&gt;你拥有 50%，所以你取出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;2 ETH + 50 USDT
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;103-来算一下实际价值&#34;&gt;10.3 来算一下实际价值
&lt;/h3&gt;&lt;p&gt;现在池子隐含价格为：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;100 / 4 = 25 USDT/ETH
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因此你实际得到的价值是：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;2 ETH = 2 * 25 = 50 USDT
50 USDT + 50 USDT = 100 USDT
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也就是说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;你投入价值 200 USDT，最后只剩价值 100 USDT&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意这里还没算手续费，所以我们可以说你经历了一个典型的“无常损失”。&lt;/p&gt;
&lt;h3 id=&#34;104-为什么会这样&#34;&gt;10.4 为什么会这样？
&lt;/h3&gt;&lt;p&gt;仔细观察资产变化：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;项目&lt;/th&gt;
          &lt;th&gt;初始&lt;/th&gt;
          &lt;th&gt;退出&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;ETH&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;2&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;USDT&lt;/td&gt;
          &lt;td&gt;100&lt;/td&gt;
          &lt;td&gt;50&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;因为 ETH 比例增加、USDT 减少，说明市场认为 ETH “更不值钱”，套利者从池子里拿走 USDT、往池子里丢 ETH，让价格回归外部市场。&lt;/p&gt;
&lt;p&gt;最终表现是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;你成了“接盘 ETH”那部分人&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当价格下跌时，池子倾向变成“ETH 更多、USDT 更少”，而你的份额跟着变，因此导致资产缩水。&lt;/p&gt;
&lt;h3 id=&#34;105-最重要的理解&#34;&gt;10.5 最重要的理解
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;LP 不是持有一组固定数量的资产，而是持有池子的一段“动态资产组合”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而这个组合&lt;strong&gt;会自动调整方向&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ETH 上涨 → 资产组合偏向 USDT&lt;/li&gt;
&lt;li&gt;ETH 下跌 → 资产组合偏向 ETH&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;价格波动越大，无常损失越明显。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这才是无常损失本质。&lt;/p&gt;
&lt;h2 id=&#34;十一xyk-模型到底解决了什么&#34;&gt;十一、XYK 模型到底解决了什么？
&lt;/h2&gt;&lt;p&gt;总结一下 XYK 带来的改变：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;不再需要订单簿&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没有挂单，也没有撮合引擎&lt;/li&gt;
&lt;li&gt;一切都在一个池子里完成&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;价格靠算法决定&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;x * y = k&lt;/code&gt; + &lt;code&gt;价格 = y / x&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;所有价格变动都是公式推出来的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;任何人都能成为做市商&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只要照比例存入两种资产&lt;/li&gt;
&lt;li&gt;不需要 24 小时盯盘，也不需要写交易策略&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;交易基础设施变成公共的&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不是某个中心化机构专有&lt;/li&gt;
&lt;li&gt;而是任何人都能参与、共享收益&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;十二xyk-的局限与后续演进&#34;&gt;十二、XYK 的局限与后续演进
&lt;/h1&gt;&lt;p&gt;XYK 虽然经典，但也有明显缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;滑点较大&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于价格波动小、稳定币之间的交易，XYK 不够“省滑点”&lt;/li&gt;
&lt;li&gt;于是出现了像 Curve 那样的“稳定币专用曲线”&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;资本利用率不高&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;资金需要覆盖一个宽范围的价格区间，却不一定都被用到&lt;/li&gt;
&lt;li&gt;Uniswap v3 通过“集中流动性”优化了这一点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;无常损失&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LP 承担价格波动风险&lt;/li&gt;
&lt;li&gt;对只想“躺平持币”的人不够友好&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;尽管如此：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;XYK 仍然是所有后续 AMM 设计的&lt;strong&gt;入门钥匙&lt;/strong&gt;。
理解了 XYK，后面看 Uniswap v2/v3、Curve、Balancer 等模型都会轻松很多。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;十三总结再看一眼那条简单的公式&#34;&gt;十三、总结：再看一眼那条简单的公式
&lt;/h1&gt;&lt;p&gt;我们再回到那条看似朴素的公式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;x * y = k
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在这条公式之上，实际上生长出了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;价格&lt;/strong&gt;：&lt;code&gt;P = y / x&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;滑点&lt;/strong&gt;：交易沿曲线移动带来的价格变化&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;流动性深度&lt;/strong&gt;：池子大小决定曲线陡峭程度&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;LP 收益&lt;/strong&gt;：手续费分配机制&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无常损失&lt;/strong&gt;：LP 与单纯持币的结果对比差额&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你可以把 XYK 看成 DeFi 里的“F=ma”：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;它简单到一句话就能写完，但&lt;strong&gt;几乎整个去中心化交易市场，都建立在它的思想之上&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        </item>
        
    </channel>
</rss>
