[{"content":"努力为什么开始让人感到不安？\n很多人并不缺努力，他们缺的是确定感。\n如果努力真的在起作用，人不会反复怀疑自己。\n真正让人焦虑的，不是事情多，而是所有事情都在阻止你停下来思考。\n只要还在努力，一切就显得合理。\n但当一个人需要不断证明自己很努力，这件事本身，往往已经出了问题。\n因为有效的努力，不需要反复自证。\n那些真正需要被回答的问题，往往被刻意拖延了。\n因为一旦面对它们，就意味着改变，而改变比吃苦更让人害怕。\n于是，努力成了一种安全的选择。\n它让人看起来在前进，却可以暂时逃避那个本该做出的决定。\n很多时候，人并不是完全不知道自己在逃避什么。\n只是那些问题，被放在了一个不必立刻回答的位置上。\n如果把复杂的纠结拆到最底层，其实只剩下两个问题：喜不喜欢，适不适合。\n这两个问题看起来简单，却很少被同时认真对待。\n因为一旦正面回答，它们就会把人推到一个明确的位置上，而位置一旦清晰，很多努力就会显得多余，甚至不合理。\n站在合适的位置上，努力会带来反馈。站在错误的位置上，努力只会放大消耗。\n真正的问题也不在于是否足够拼，而在于是否愿意承认：有些位置，不适合长期投入。\n而逃避，往往就发生在这里，不是逃避行动，而是逃避对位置的判断。\n如果把所有的事情都按照喜不喜欢和适不适合拆分，那一切都会清晰明了。\n喜欢 + 适合： 这是最理想的位置。投入会带来反馈，努力会形成积累。在这里，努力很少需要被反复强调，因为结果本身就在说明问题。\n喜欢 + 不适合： 这是最容易被浪漫化的位置。投入感很强，情绪很满，但回报稀薄。努力在这里，常常被用来证明热爱，而不是验证能力。\n不喜欢 + 适合： 这是最容易被合理化的位置。做得不错，也能持续输出，但内心抗拒。努力在这里，更多是为了维持现状，而不是走向想要的方向。\n不喜欢 + 不适合： 这是最危险的位置。既没有动力，也缺乏反馈，却已经投入太多。努力在这里，几乎只剩下一个作用——证明自己没有放弃。\n当一个人站在合适的位置上，努力的存在感往往很低。\n不需要反复提醒自己在坚持，也不需要不断向他人证明付出，反馈会出现，路径会逐渐变窄，选择会越来越清晰。\n相反，当努力需要被反复强调，努力被作为推脱的借口，往往说明努力正在承担它不该承担的功能。\n判断努力是否有效，有一个简单标准：它是在减少问题，还是在推迟问题。\n停止逃避，并不是停下行动，而是停止用行动替代判断。\n想要避免用努力逃避判断，就必须给投入设定验证周期，给坚持设定退出条件。\n","date":"2025-10-15T14:59:56+08:00","permalink":"https://yearsuns-github-io.vercel.app/p/sometimes-effort-is-just-a-way-to-avoid-making-a-judgment/","title":"很多时候，我们不是在努力，而是在逃避判断"},{"content":"1. 为什么需要 Gas 优化 在以太坊上开发智能合约时，Gas 是一个绕不开的概念。 它既不是单纯的“手续费”，也不仅仅是网络拥堵时的临时成本，而是对合约设计质量的一种长期约束。\n很多开发者第一次关注 Gas，往往是在以下场景中：\n合约部署费用异常高 用户调用某个函数时频繁 Out of Gas 同样的功能，不同实现方式的成本差异明显 这些问题通常并非出现在业务逻辑上，而是源于对 EVM 成本模型缺乏直觉。\n1.1 Gas 的两层含义 在讨论优化之前，必须先区分两个容易混淆的概念：\ngas used：执行一笔交易实际消耗的 Gas 单位数量 gas price：你愿意为每个 Gas 单位支付的价格 合约代码本身只能影响 gas used，而无法控制 gas price。\n这意味着：\n网络拥堵会推高 gas price，但不会改变合约的 gas used 一个设计不佳的合约，在任何网络环境下都会更贵 在 gas price 较高的时期，低效设计的成本差距会被进一步放大 因此，Gas 优化并不是为了“赌网络状况”，而是为了让每次执行尽可能少地消耗 Gas 单位。\n1.2 为什么“功能正确”并不等于“成本合理” 在传统软件中，只要程序运行正确，性能问题往往可以后置优化。 但在智能合约中，性能就是成本。\n一个合约即使：\n没有安全漏洞 功能完全符合预期 能通过所有测试 仍然可能因为以下原因变得难以使用：\n某些函数在链上执行成本过高 高峰期交易失败率上升 长期来看，用户为相同功能支付了不必要的费用 这类问题往往不是“写错了代码”，而是在设计阶段忽略了 Gas 的结构性成本。\n1.3 Gas 优化的目标是什么 Gas 优化并不是追求“极致便宜”，而是服务于三个更现实的目标：\n降低长期使用成本 高频调用的函数，哪怕节省几百 Gas，长期也会累积显著差异。\n提高交易成功率 Gas 消耗越可控，越不容易在复杂路径中触发 Out of Gas。\n提升成本的可预测性 让调用者更容易估算所需 Gas，减少不确定性。\n这也是为什么 Gas 优化通常应当优先作用在：\n高频路径 核心业务逻辑 用户直接支付成本的函数 1.4 何时不应该过度优化 需要明确的是，Gas 优化有明显的边际递减效应。\n以下情况通常不值得：\n为了节省极少量 Gas，引入复杂且晦涩的写法 在低频、冷路径上做大量微优化 牺牲安全检查或可读性来换取微小收益 合理的原则是：\n先写出安全、清晰、可维护的代码，再在“真正昂贵的地方”做优化。\n在大多数情况下，理解并避免高成本结构，比记住零散技巧更重要。\n1.5 接下来要做什么 接下来的章节将从最基础的问题开始：\nEVM 到底在为什么操作收费 哪些指令最贵，哪些几乎可以忽略 为什么 storage 读写是 Gas 成本的核心 理解这些原理之后，后续的所有优化实践都会变得自然，而不是依赖记忆规则。\n2. Gas 成本模型 在讨论具体的优化技巧之前，有必要先建立一个清晰的成本直觉：EVM 并不是所有操作都同样昂贵。 很多看起来“简单”的 Solidity 代码，之所以 Gas 消耗很高，原因往往不在业务逻辑本身，而在于它触发了高成本的底层指令。\n理解这一节内容的目标只有一个： 知道哪些操作值得被重点避免或合并，哪些操作几乎可以忽略不计。\n2.1 什么是指令级收费 EVM 是一台基于栈的虚拟机。Solidity 代码在部署或调用前，会被编译为一系列 EVM 指令（opcode），例如：\nADD、SUB、LT 等算术或比较指令 MLOAD、MSTORE 等内存操作 SLOAD、SSTORE 等 storage 操作 CALL、DELEGATECALL 等外部调用 Gas 的计算完全发生在指令层面，而不是在 Solidity 语法层面。这意味着：\n一行 Solidity 代码可能对应多条指令 不同写法即使“看起来一样”，编译后的指令序列也可能不同 Gas 的差异，来自指令类型和数量，而不是代码长度 因此，Gas 优化本质上是在做一件事： 让高成本指令执行得更少。\n2.2 成本层级 从成本角度，可以粗略把 EVM 中的操作分为几个层级（从低到高）：\n纯计算（算术、比较、位运算） 内存（memory）读写 calldata 读取 storage 读取（SLOAD） storage 写入（SSTORE） 外部调用与返回大量数据 其中最重要的一点是：\nstorage 操作的成本，远高于绝大多数计算操作。\n这也是为什么很多 Gas 优化最终都会指向同一个方向： 减少 storage 的访问次数。\n2.3 Storage 是什么，为什么这么贵 在 Solidity 中，所有状态变量都会存储在 storage 中。 从 EVM 的视角来看，storage 是一张巨大的键值表：\nkey：storage slot 的位置 value：32 字节的数据 storage 的特点是：\n数据是永久存在的 会影响全局状态树 所有全节点都必须对其状态达成共识 每一次 storage 的写入，都意味着对整个系统状态的一次修改，这正是它昂贵的根本原因。\n2.4 读取 storage 的真实成本 当你读取一个状态变量时，例如：\nuint256 x = count; 编译后的关键指令是 SLOAD。\n自 EIP-2929 之后，SLOAD 的成本分为两种情况：\n冷访问（cold access）： 在一次交易中，第一次访问某个 storage slot 热访问（warm access）： 在同一交易中，再次访问已经读过的 slot 直觉上可以理解为：\n第一次读取某个状态变量，EVM 需要“把它带进来” 后续再读同一个变量，成本会降低，但仍然不便宜 即使是热访问，SLOAD 的成本也明显高于内存或算术操作。\n2.5 为什么写 storage 是最贵的操作之一 当你修改一个状态变量时，例如：\ncount = count + 1; 这并不是一次简单的“加一”，而是一个完整的读–改–写过程：\nSLOAD：读取原始值 执行加法 SSTORE：写入新值 SSTORE 的成本取决于写入前后的状态，例如：\n从 0 写成非 0：成本最高 从非 0 改为非 0：次之 从非 0 改为 0：成本较低，并可能获得退款 这些规则的存在，本质上是为了鼓励合约释放不再使用的状态。\n2.6 一行 Solidity 代码背后的真实执行过程 来看一个非常常见的写法：\ncount += 1; 从 Solidity 的角度看，它只是一次简单的自增。 但从 EVM 的角度看，它通常意味着：\n一次 SLOAD 一次加法指令 一次 SSTORE 如果在同一个函数中多次写出类似代码：\ncount += 1; count += 1; count += 1; 你并不是做了三次加法，而是触发了：\n3 次 SLOAD 3 次 SSTORE 这正是 Gas 消耗迅速放大的原因。\n2.7 建立一个关键直觉 到这里，可以总结出一个非常重要的直觉：\n算术和逻辑运算通常不是 Gas 的瓶颈 storage 的读写，才是 Gas 成本的核心来源 多次重复访问同一个 storage slot，是最常见也最容易忽视的浪费 一旦你建立起这个直觉，后续关于缓存变量、合并写入、storage packing 等优化方式，都会显得顺理成章，而不是技巧堆砌。\n3. 减少 Storage 读写 在理解了 EVM 的成本模型之后，Gas 优化的优先级其实已经非常清晰： 只要能减少 storage 的读写次数，几乎一定能获得显著的 Gas 收益。\n所有的gas优化技巧大多围绕一个核心目标展开： 让 SLOAD 和 SSTORE 尽可能少地执行。\n3.1 为什么 Storage 优化具有最高性价比 前面我们讨论过：\n算术运算非常便宜 内存操作成本中等 storage 写入是最昂贵的操作之一 这意味着：\n省掉一次 SSTORE，往往比优化十几行计算代码更有价值 优化 storage 访问，收益通常是数量级上的 因此，在实际工程中，Gas 优化的顺序应当是：\n先看是否能减少 storage 读写 再考虑循环、参数、位运算等次级优化 3.2 缓存多次读取：把多次 SLOAD 变成一次 最常见、也最容易忽视的低效写法，是在同一个函数中多次读取同一个状态变量。\n例如：\nfunction increment() external { require(count \u0026lt; max, \u0026#34;too large\u0026#34;); count = count + 1; emit Updated(count); } 在这段代码中，count 实际上被读取了多次：\nrequire 中读取一次 自增时读取一次 事件参数中再读取一次 更高效的写法是先将其缓存到局部变量：\nfunction increment() external { uint256 c = count; require(c \u0026lt; max, \u0026#34;too large\u0026#34;); c = c + 1; count = c; emit Updated(c); } 这样做的结果是：\nstorage 只读一次 storage 只写一次 后续操作都在内存中完成 这种改动几乎不影响可读性，却能显著减少 Gas。\n3.3 合并多次写入：避免重复的 SSTORE 另一类常见问题，是在同一个函数中多次写入同一个状态变量。\n例如：\nfunction update(uint256 x) external { value += x; if (x \u0026gt; threshold) { value += bonus; } } 表面上看，这段代码逻辑清晰，但它可能会对 value 执行多次 SSTORE。\n更合理的写法是先在内存中完成所有计算：\nfunction update(uint256 x) external { uint256 v = value; v += x; if (x \u0026gt; threshold) { v += bonus; } value = v; } 原则可以总结为一句话：\n不要在逻辑分支中反复写 storage，先算清楚，再一次性写回。\n3.4 循环中的 storage 读写陷阱 循环是 storage 读写最容易被放大的地方。\n考虑下面的写法：\nfunction sum(uint256[] calldata arr) external { for (uint256 i = 0; i \u0026lt; arr.length; i++) { total += arr[i]; } } 在这个循环中：\n每次迭代都会读取并写入 total 如果数组长度为 n，就会触发 n 次 SLOAD 和 n 次 SSTORE 更高效的写法是：\nfunction sum(uint256[] calldata arr) external { uint256 t = total; uint256 len = arr.length; for (uint256 i = 0; i \u0026lt; len; i++) { t += arr[i]; } total = t; } 这种写法的改动非常小，但对 Gas 的影响会随着数组长度线性放大。\n3.5 避免在循环中写 storage 的设计思路 在设计合约时，应当尽量避免以下模式：\n在不受限的循环中写 storage 每次迭代都更新状态 循环次数由外部输入完全控制 更好的替代方案包括：\n先在内存中计算，再一次性写回 设计批处理接口，但限制每次调用的最大数量 将复杂计算移到链下，只在链上验证结果 这些并不是“写法技巧”，而是设计阶段就应当考虑的结构性问题。\n3.6 用 mapping 替代数组 在合约里，“数组还是 mapping”并不只是编码风格差异，而是成本模型差异：\n数组常见操作（查找、去重、删除某个元素）通常需要遍历，成本是 O(n)，并且容易触发不受限循环 mapping 的读写是按 key 直接定位，成本接近 O(1)，更稳定、更可控 场景 1：成员判断（contains） 不推荐：用数组存储成员并在链上查找\naddress[] public members; function isMember(address a) public view returns (bool) { for (uint256 i = 0; i \u0026lt; members.length; i++) { if (members[i] == a) return true; } return false; } 问题：\n每次判断都要遍历 成员越多越贵 最坏情况下可能 Out of Gas 推荐：用 mapping 做存在性判断\nmapping(address =\u0026gt; bool) public isMember; function addMember(address a) external { isMember[a] = true; } function removeMember(address a) external { isMember[a] = false; } 优点：\n判断存在性是 O(1) 成本可预测 不需要循环 场景 2：需要“可枚举”的集合（既要 O(1) 判断，又要列出所有成员） 很多业务既需要 isMember[a] 这种 O(1) 判断，也需要枚举所有成员（给前端展示）。这时可以用“mapping + 数组”组合结构：\nmapping(address =\u0026gt; bool) public isMember; address[] public memberList; mapping(address =\u0026gt; uint256) private indexPlusOne; // 下标+1，0 表示不存在 function addMember(address a) external { if (indexPlusOne[a] != 0) return; // 已存在 isMember[a] = true; memberList.push(a); indexPlusOne[a] = memberList.length; // 存的是 index+1 } function removeMember(address a) external { uint256 idxPlusOne = indexPlusOne[a]; if (idxPlusOne == 0) return; uint256 idx = idxPlusOne - 1; uint256 last = memberList.length - 1; if (idx != last) { address lastAddr = memberList[last]; memberList[idx] = lastAddr; indexPlusOne[lastAddr] = idx + 1; } memberList.pop(); indexPlusOne[a] = 0; isMember[a] = false; } 解释：\nmapping 负责 O(1) 判断与定位 array 负责枚举 删除用 swap-and-pop，避免 O(n) 移动 注意：\n这种结构会引入额外存储（索引 mapping），但换来的是操作复杂度和成本可控，通常非常值得 什么时候不该用数组 如果你发现你在数组上做这些操作，基本就该考虑 mapping：\ncontains/查找 去重 删除指定元素 防重复写入 任何“长度可能增长且由用户输入驱动”的遍历逻辑 一句话总结：\n数组适合“顺序数据”和“按下标访问”，mapping 适合“按 key 查询/去重/存在性判断”。当你需要查找或删除时，mapping 往往更省 Gas，也更安全。\n4. 数据位置与函数接口设计 在减少了不必要的 storage 读写之后，下一类非常值得关注的优化点是： 函数的接口设计，包括参数的数据位置（data location）和函数的可见性（visibility）。\n这些选择通常不会改变业务逻辑，但却会直接影响：\n是否发生不必要的数据拷贝 是否触发额外的编码 / 解码 函数调用在 EVM 中走的是哪条路径 合理的接口设计，往往是“低风险、高收益”的 Gas 优化。\n4.1 三种数据位置的成本直觉 在 Solidity 中，引用类型（数组、struct、string、bytes）必须显式或隐式指定数据位置：\ncalldata：只读，位于调用数据中 memory：可读写，函数执行期间存在 storage：永久存储在链上 从成本角度，可以建立一个简单直觉：\ncalldata 读取：便宜 memory 读写：中等 storage 读写：昂贵 因此，一个基本原则是：\n能用 calldata 就不要用 memory，能用 memory 就不要用 storage。\n4.2 external 函数与 calldata 对于只从外部调用的函数，最推荐的写法是：\nfunction process(uint256[] calldata data) external { // 使用 data } 原因在于：\nexternal 函数的参数天然来自 calldata 使用 calldata 不需要将参数复制到 memory 对于大数组或复杂结构，拷贝成本差异非常明显 相反，如果写成：\nfunction process(uint256[] memory data) public { // 使用 data } 即使你并未修改 data，编译器仍然需要：\n将 calldata 中的数据完整复制到 memory 为此支付额外的 Gas 成本 4.3 什么时候必须使用 memory calldata 的限制也非常明确：只读。\n一旦你的函数需要：\n修改数组内容 排序 去重 动态构造新数组 就必须使用 memory。\n例如：\nfunction normalize(uint256[] calldata data) external returns (uint256[] memory) { uint256[] memory result = new uint256[](data.length); for (uint256 i = 0; i \u0026lt; data.length; i++) { result[i] = data[i] / 2; } return result; } 这里的关键点是：\n输入参数使用 calldata（避免拷贝） 输出结果使用 memory（必须可写） 这是一种非常常见、也非常合理的组合。\n4.4 函数可见性的 Gas 含义 函数可见性不仅影响可调用范围，也会影响 Gas。\n可以从以下角度理解：\nexternal：直接从 calldata 读取参数，最省 Gas public：参数会被复制到 memory，成本更高 internal：编译期内联或直接跳转，最便宜 private：与 internal 类似，但仅限当前合约 一个重要结论是：\npublic 并不是“内外通用的最优选择”。\n4.5 external 入口 + internal 实现 在实际工程中，最推荐的模式是：\n对外暴露的函数使用 external 将核心逻辑提取到 internal 函数中 例如：\nfunction update(uint256 x) external { _update(x); } function _update(uint256 x) internal { // 核心逻辑 } 这样做的好处包括：\nexternal 函数使用 calldata，参数拷贝最少 internal 函数调用成本极低 内部调用和外部调用共享同一份逻辑 这种模式几乎没有副作用，却能避免很多隐性的 Gas 浪费。\n4.6 为什么要避免 this 调用当前合约 一个非常隐蔽但代价很高的写法是：\nthis.update(x); 即使 update 定义在当前合约中，这种写法也会：\n触发一次完整的 external call 进行 ABI 编码和解码 走 CALL 指令路径 这意味着：\n更高的 Gas 成本 更复杂的执行路径 潜在的可重入风险 如果你发现自己需要 this.foo()，通常意味着：\n逻辑划分不合理 internal 函数抽象不充分 正确的重构方式，是将逻辑提取为 internal 函数，并在 external 函数中调用它。\n4.7 一个对比示例 对比下面两种实现：\n不推荐的写法：\nfunction foo(uint256[] memory data) public { // 使用 data } function bar(uint256[] memory data) public { foo(data); } 推荐的写法：\nfunction foo(uint256[] calldata data) external { _foo(data); } function bar(uint256[] calldata data) external { _foo(data); } function _foo(uint256[] calldata data) internal { // 使用 data } 第二种写法在以下方面更优：\n参数不被重复拷贝 逻辑集中，避免重复 internal 调用成本更低 5. 状态布局设计：Storage Packing 在前几节中，我们讨论的优化大多发生在“如何使用状态变量”。 这一节关注一个更偏设计层面的问题：状态变量是如何被放进 storage 的。\n很多 Gas 浪费并不是来自频繁读写，而是来自状态布局本身不合理，导致：\n使用了更多的 storage slot 每次读写都触发更多的 SLOAD / SSTORE 合约长期运行成本被放大 5.1 Storage slot 与 32 字节对齐 从 EVM 的角度看，storage 是以 32 字节（256 bit）为一个 slot 来组织的。\nSolidity 的状态变量会按照声明顺序，依次放入这些 slot 中：\n如果变量大小小于 32 字节，编译器会尝试将多个变量放进同一个 slot 如果当前 slot 剩余空间不足，变量会被放到下一个 slot 一旦一个 slot 被填满，就不会再继续向其中塞变量 这一机制被称为 storage packing。\n5.2 一个最基础的打包示例 考虑下面的变量声明：\nuint128 a; uint128 b; uint256 c; 每个 uint128 占 16 字节，因此这两个变量可以共享同一个 storage slot。uint256 独占 16 字节，因此这三个变量总共使用了 2 个 slot。\n但如果顺序稍有不同：\nuint128 a; uint256 c; uint128 b; 那么：\na 占用 slot0 的前 16 字节 c 独占 slot1 b 由于 slot0 剩余空间不足，只能进入 slot2 现在这三个变量总共使用了 3 个 slot。仅仅因为声明顺序不同，就多消耗了一个 slot。\n5.3 为什么 slot 数量直接影响 Gas 每一个额外的 storage slot，都会带来长期成本：\n读取更多 slot → 更多 SLOAD 写入更多 slot → 更多 SSTORE 结构体整体读写成本上升 尤其是在：\n高频调用函数 需要整体复制或更新 struct 的场景中 slot 数量的差异，会直接体现在 Gas 消耗上。\n5.4 小类型并不总是“越小越好” 需要注意的是：\n选择小于 256 bit 的类型，并不一定自动省 Gas 只有在成功打包的前提下，小类型才有意义 例如：\nuint128 a; uint256 b; 即使 a 是 uint128，它依然会独占一个 slot，因为后面紧跟着一个 uint256。\n因此，类型选择和声明顺序应当结合考虑，而不是孤立决策。\n5.5 什么时候应该关心 storage packing 并不是所有合约都需要精细打包。 storage packing 不仅适用于合约级变量，也同样适用于 struct。\nstorage packing 尤其适合以下场景：\n状态变量数量较多 使用大量 struct 状态会被频繁读写 合约生命周期较长 而在状态极少、只部署一次、很少交互的合约中，过度调整字段顺序的收益可能有限。\n6. 循环与批处理 在前几节中，我们已经看到： storage 读写本身很贵，而循环会把这种成本按次数放大。 因此，循环往往不是 Gas 的来源，但却是 Gas 的“放大器”。\n不是所有循环都是问题，但不受控制的循环几乎一定会成为问题。\n6.1 为什么循环容易成为 Gas 黑洞 从 EVM 的角度看，循环并不是一个特殊结构，它只是：\n重复执行一段指令序列 每一次迭代都会完整支付指令成本 如果循环体中包含：\nstorage 读写 昂贵的计算 外部调用 那么 Gas 消耗就会与循环次数线性增长。\n当循环次数由外部输入控制时，风险尤其明显。\n6.2 缓存数组 length 与中间结果 一个非常常见、也非常基础的优化点，是缓存数组的长度。\n例如：\nfunction sum(uint256[] calldata arr) external { uint256 s = 0; for (uint256 i = 0; i \u0026lt; arr.length; i++) { s += arr[i]; } } 虽然 arr.length 看起来很轻量，但在每次循环判断中，都会被重新读取。\n更好的写法是：\nfunction sum(uint256[] calldata arr) external { uint256 s = 0; uint256 len = arr.length; for (uint256 i = 0; i \u0026lt; len; i++) { s += arr[i]; } } 这类优化在单次调用中节省的 Gas 不多，但在高频或大数组场景下，会逐渐显现差异。\n6.3 避免在循环中直接写 storage 如前几节所强调的，在循环中写 storage 是非常昂贵的。\n原则可以总结为：\n循环中尽量只做内存计算，把 storage 写入放到循环之外。\n6.4 在安全前提下使用 unchecked 从 Solidity 0.8 开始，整数运算默认包含溢出检查。 这对安全非常有价值，但在某些场景中，也会带来不必要的 Gas 开销。\n一个典型场景是 for 循环的计数器：\nfor (uint256 i = 0; i \u0026lt; len; i++) { // ... } 如果你能明确保证：\ni 不会接近 type(uint256).max 循环条件有明确上界 那么可以使用：\nfor (uint256 i = 0; i \u0026lt; len; ) { // ... unchecked { i++; } } 这类优化的收益不如减少 storage 读写明显，但在大循环中仍然是可测量的。\n6.5 避免无上限循环 在设计合约接口时，应当尽量避免：\n循环次数完全由用户输入决定 没有任何上界或约束 例如：\nfunction process(uint256[] calldata items) external { for (uint256 i = 0; i \u0026lt; items.length; i++) { // ... } } 如果 items.length 没有被限制，调用者可以传入极大的数组，导致：\n调用失败（Out of Gas） 合约在某些情况下“不可用” 常见的改进方式包括：\n明确限制最大长度 将操作拆分为多次调用 提供分页或游标式接口 6.6 批处理（Batch）设计的取舍 批处理是减少交易次数、摊薄固定成本的常见手段，但它并不是没有代价。\n优点包括：\n减少外部调用次数 摊薄函数入口和校验成本 风险包括：\n单笔交易 Gas 不可控 更容易触发 OOG 更难估算 Gas 上限 因此，批处理接口通常应当具备：\n明确的单次处理上限 可预期的最坏情况成本 清晰的失败行为 6.7 一个批处理示例 不推荐的写法：\nfunction batchUpdate(uint256[] calldata ids) external { for (uint256 i = 0; i \u0026lt; ids.length; i++) { update(ids[i]); } } 改进后的写法：\nuint256 constant MAX_BATCH = 100; function batchUpdate(uint256[] calldata ids) external { uint256 len = ids.length; require(len \u0026lt;= MAX_BATCH, \u0026#34;too many items\u0026#34;); for (uint256 i = 0; i \u0026lt; len; ) { _update(ids[i]); unchecked { i++; } } } 这里的关键不是“省多少 Gas”，而是：\n成本可控 行为可预测 接口对调用者友好 7. 错误处理与字节码体积优化 在讨论 Gas 优化时，很多人会把注意力集中在“成功执行路径”上，而忽略了失败路径和合约本身体积的成本。 实际上，错误处理方式不仅影响交易失败时的 Gas 消耗，也会影响：\n合约部署成本 每次调用的基础开销 字节码大小与可维护性 这一节将聚焦一个非常具体但收益稳定的优化点：如何更高效地处理错误和回滚。\n7.1 revert 本身并不是“免费”的 当一笔交易 revert 时，状态会被回滚，但 Gas 并不会全部返还。 尤其是以下几类成本：\n已执行指令消耗的 Gas 错误信息本身携带的数据 与 ABI 编码相关的开销 因此，一个频繁触发的校验逻辑，其失败路径的成本，同样值得认真对待。\n7.2 require(string) 的真实代价 最传统、也最常见的错误处理方式是：\nrequire(msg.sender == owner, \u0026#34;Not owner\u0026#34;); 这种写法的问题不在于功能，而在于成本：\n错误字符串会被编译进合约字节码 每一次 revert 都需要返回这段字符串数据 字符串越长，部署成本和失败成本越高 在复杂合约中，大量使用 require(string) 会显著增加 bytecode 体积。\n7.3 使用 custom error 的动机 从 Solidity 0.8.4 开始，引入了 custom error：\nerror NotOwner(); 并配合：\nif (msg.sender != owner) revert NotOwner(); 这种写法的优势在于：\n不需要存储字符串 错误标识以 selector 形式存在 revert 时返回的数据更小 从成本角度看，它同时降低了：\n部署 Gas revert 路径的 Gas 7.4 对比示例 考虑一个最简单的权限校验。\n使用 require(string)：\nfunction withdraw() external { require(msg.sender == owner, \u0026#34;Not owner\u0026#34;); // ... } 使用 custom error：\nerror NotOwner(); function withdraw() external { if (msg.sender != owner) revert NotOwner(); // ... } 两种写法在成功路径上的 Gas 几乎相同，但在以下方面存在差异：\n合约部署体积 revert 时的 Gas 消耗 错误信息的编码方式 在高频调用或复杂合约中，这种差异会逐渐积累。\n7.5 错误信息该写多“详细” 一个常见误区是： 错误信息越详细越好。\n从链上执行的角度看，这并不总是成立。\n更合理的分工是：\n链上：提供简洁、结构化的错误标识 链下：通过文档或映射表解释错误含义 custom error 非常适合这种模式，因为它：\n本身就是结构化的 可携带参数 便于前端或 SDK 解码 例如：\nerror InsufficientBalance(uint256 available, uint256 required); 7.6 字节码体积为什么值得关注 合约字节码体积会直接影响：\n部署成本 部署是否成功（有大小上限） 每次调用的基础 Gas（代码越大，加载成本越高） 以下写法都会增加字节码体积：\n大量字符串常量 重复的逻辑分支 冗长的错误信息 因此，Gas 优化不仅是“执行时优化”，也包括部署时优化。\n7.7 错误处理与可读性的平衡 需要强调的是：\ncustom error 并不是为了“压缩到极限” 也不意味着完全放弃可读性 合理的做法是：\n对外暴露的核心接口：使用清晰的 custom error 内部断言或开发阶段检查：适度使用 require 避免在错误信息中携带冗长文本 8. 事件与返回值设计 在智能合约中，事件（event）和函数返回值常被用于“对外提供信息”。 但如果设计不当，它们很容易成为 隐性的 Gas 消耗来源，尤其是在高频调用或数据量较大的场景中。\n这一节的核心观点可以先给出：\n区块链擅长做状态验证，不擅长做数据查询。\n理解这一点，有助于你在事件和返回值设计上做出更经济的选择。\n8.1 事件的作用边界 事件的主要用途是：\n供链下系统监听和索引 记录重要的状态变化 作为审计和分析的依据 事件不会被合约在链上读取，也不会影响后续执行逻辑。 因此，从合约执行的角度看，事件是“写一次、只给链下用”的数据。\n这意味着一个设计原则：\n事件应当服务于链下，而不是替代链上状态查询。\n8.2 事件的 Gas 成本构成 一个事件的 Gas 成本主要由两部分组成：\ntopics\n包括事件签名 以及最多 3 个 indexed 参数 data\n非 indexed 的参数 按字节数计费 直觉上可以这样理解：\nindexed 参数更利于过滤和查询 但 indexed 并不是“免费”的 data 部分越大，Gas 成本越高 因此，事件设计需要在可查询性和成本之间取舍。\n8.3 indexed 的合理使用 考虑一个转账事件：\nevent Transfer(address indexed from, address indexed to, uint256 amount); 这种设计是合理的，因为：\nfrom 和 to 是最常用的查询条件 amount 通常不用于过滤 但如果写成：\nevent Transfer( address indexed from, address indexed to, uint256 indexed amount ); 那么：\n查询能力并没有显著提升 Gas 成本却增加了 而且 indexed 参数最多只能有 3 个 一个实用原则是：\n只为“经常作为过滤条件”的字段加 indexed。\n8.4 避免在事件中携带大数据 一个常见但代价很高的做法，是在事件中携带大量数据：\nevent DataUpdated(uint256[] values); 这种设计的问题包括：\n数组会被完整写入日志 Gas 成本随数据量线性增长 链上执行成本和链下存储成本都很高 更合理的替代方案是：\n只记录关键信息（如 ID、hash、计数） 将完整数据存储在链下 通过 hash 或索引进行关联 例如：\nevent DataUpdated(bytes32 dataHash); 8.5 避免在链上返回大数组 在 Solidity 中，函数返回数组或结构体在语法上是完全合法的，例如：\nfunction getUsers() external view returns (User[] memory); 从接口设计的角度看，这样的函数非常直观： “调用一次，就能拿到所有用户数据。”\n问题在于，这种直观并不等于便宜。\n链上调用时会发生什么 如果这个函数被 另一个合约 调用，那么即使它是 view 函数，也会真实消耗 Gas。 在这种情况下，EVM 需要做的事情包括：\n从 storage 中逐个读取所有 User 将这些数据复制到 memory 按 ABI 规则编码整个数组 将编码后的字节作为返回值 这些操作的成本，都会随着数组长度线性增长。\n也就是说，返回的数据越多，Gas 消耗越高，而且没有上限。\n这类成本往往是“没必要的” 在实际项目中，完整的数据列表通常是：\n给前端或后端服务用的 用于展示、统计或分析 不会被其他合约在链上依赖 而这些链下系统，完全可以通过 eth_call 免费读取 view 函数的返回值。\n这就造成了一种常见的浪费：\n链上调用为返回数据付出了 Gas 真正需要这些数据的是链下系统 而链下系统本可以不花任何 Gas 更合理的设计思路 因此，在设计函数返回值时，应该明确区分两种使用场景：\n链上调用的函数 返回值应当尽量简单，甚至可以不返回任何数据\n链下查询用的函数 可以返回数组或结构体，但要意识到它们只适合通过 eth_call 使用\n如果存在链上也需要读取部分数据的需求，那么分页或游标式接口通常是更安全的选择。\n8.6 用分页与游标来替代一次性返回 如果确实需要从合约中读取大量数据，更合理的方式是分页。\n例如：\nfunction getUsers(uint256 offset, uint256 limit) external view returns (User[] memory) { // 返回一部分数据 } 这种设计的优势是：\n链上调用时可以控制 Gas 上限 链下系统可以逐页拉取 接口行为更可预测 8.7 一个事件设计对比示例 不推荐的写法：\nevent OrderCreated( address user, uint256[] itemIds, uint256[] prices ); 改进后的写法：\nevent OrderCreated( address indexed user, bytes32 orderId ); 并在链下系统中：\n根据 orderId 关联完整订单数据 使用事件作为“索引信号”，而不是数据载体 这种设计在可扩展性和成本上都更加合理。\n9. 紧凑表示与低级优化（谨慎使用） 在前面的内容中，我们讨论的优化大多具备一个共同特点： 不牺牲可读性，风险可控，收益稳定。\n现在我们开始讨论一些进阶技巧，这些技巧确实可以省 Gas，但同时也会带来：\n可读性下降 实现复杂度上升 更高的审计和维护成本 因此，这一节的核心不是“教你一定要用”，而是回答：\n哪些低级优化在什么情况下值得用，什么时候应该果断放弃。\n9.1 位运算与 bitmap 一个非常典型、也相对安全的进阶优化手段，是 bitmap（位图）。\n假设你需要维护一组布尔状态，例如：\n某个地址是否已完成某一步操作 某些 ID 是否已被使用 一组固定大小的开关位 最直观的写法是：\nmapping(uint256 =\u0026gt; bool) used; 这种写法清晰、易懂，但每一个 bool 实际上都会占用一个完整的 storage slot。\n使用 bitmap 的思路 如果这些布尔值的 key 是：\n连续的 范围有限的 数量较多的 那么可以考虑用一个 uint256 来存储 256 个布尔值：\nuint256 bitmap; 第 n 位表示第 n 个状态 通过位运算进行读写 例如：\nfunction isUsed(uint256 index) internal view returns (bool) { return (bitmap \u0026amp; (1 \u0026lt;\u0026lt; index)) != 0; } function setUsed(uint256 index) internal { bitmap |= (1 \u0026lt;\u0026lt; index); } 这样做的直接收益是：\n用 1 个 storage slot 表示 256 个状态 大幅减少 storage 读写次数 在高频场景下节省可观的 Gas 9.2 bitmap 的适用边界 bitmap 并不是 mapping(bool) 的“全面替代”，它适合以下场景：\n状态数量上限明确 index 可控且不来自任意用户输入 逻辑相对稳定，不易变更 不适合以下场景：\nkey 是 address 或 hash 状态数量不可预期 逻辑频繁变动、需要高度可读性 一个实用判断是：\n如果你需要在文档中专门解释“这一位代表什么”，那就说明复杂度已经上升了。\n9.3 紧凑编码与“省 slot”思维 除了 bitmap，一些项目还会尝试：\n在一个 uint256 中打包多个小字段 用位移和掩码存储多个数值 手动实现类似 storage packing 的逻辑 例如：\nuint256 packed; 其中：\n高 128 位表示余额 低 128 位表示时间戳 这种写法在理论上可以减少 slot 数量，但需要注意：\n每一次读写都需要位运算 容易引入边界错误 调试和审计难度明显增加 这类优化通常只在以下情况下才值得考虑：\n数据结构极其稳定 访问频率非常高 已经确认 slot 数量是主要瓶颈 9.4 关于 assembly Solidity 允许通过 assembly 直接编写 EVM 指令，这意味着：\n可以跳过部分编译器生成的冗余逻辑 在极端情况下获得更低的 Gas 例如，直接使用 sload、sstore、calldataload。\n但需要非常谨慎：\nassembly 不做类型检查 不提供溢出保护 可读性和可维护性显著下降 在大多数业务合约中，assembly 带来的收益往往小于它引入的风险。\n9.5 assembly 什么时候才值得用 相对合理的使用场景包括：\n经常被调用的“热路径” 非常底层、逻辑稳定的工具函数 已有充分测试覆盖 有经验的开发者和审计支持 不推荐的场景包括：\n业务逻辑核心 权限、资金相关代码 仅为了节省少量 Gas 一个保守但实用的原则是：\n如果不用 assembly 也能把 Gas 控制在合理范围内，那就不要用 assembly。\n9.6 进阶优化的真实收益评估 需要特别强调的是，进阶优化的收益往往是：\n单次调用节省几十到几百 Gas 只有在高频调用时才会显现价值 因此，在决定采用这些技巧之前，最好已经：\n完成了 storage、接口、循环等基础优化 明确知道瓶颈在哪里 有真实的 Gas 测试数据作为依据 否则，很容易陷入“为优化而优化”。\n10. 如何验证优化是否有效 到目前为止，我们已经讨论了多种 Gas 优化手段。 但在真正的工程实践中，有一个问题始终比“怎么优化”更重要：\n你怎么确定，这次优化真的有价值？\n这一节的目标，是建立一种可执行的、数据驱动的优化方法，而不是依赖直觉或经验判断。\n10.1 为什么不能凭感觉判断 Gas Gas 成本并不总是和“代码复杂度”成正比：\n有些看起来复杂的重构，几乎不影响 Gas 有些只改了几行的调整，却能节省大量成本 有些优化在小规模测试中无感，在大规模使用中差异巨大 如果没有量化数据，很容易出现两种极端：\n低估优化价值：错过高收益改进 过度优化：引入复杂性却几乎没有回报 因此，Gas 优化必须是数据驱动的工程行为。\n10.2 什么是“有效的 Gas 优化” 一个优化是否有效，通常需要回答三个问题：\n节省了多少 Gas 发生在多高频的执行路径上 引入了多少额外复杂度或风险 只有当节省的 Gas 与复杂度之间形成合理比例时，这次优化才是值得的。\n10.3 基准测试的基本思路 最简单、也最可靠的方式，是对同一逻辑进行优化前 / 优化后对比测试。\n基本原则包括：\n使用相同的输入数据 只改变你关心的那一处实现 关注 gas used，而不是交易费用 例如：\n原始版本：函数 A 优化版本：函数 A′ 对比两者在相同调用条件下的 Gas 消耗 10.4 一个概念级的对比示例 假设你有一个累加逻辑：\nfunction add(uint256[] calldata xs) external { for (uint256 i = 0; i \u0026lt; xs.length; i++) { total += xs[i]; } } 和一个优化版本：\nfunction addOptimized(uint256[] calldata xs) external { uint256 t = total; uint256 len = xs.length; for (uint256 i = 0; i \u0026lt; len; ) { t += xs[i]; unchecked { i++; } } total = t; } 你关心的不是“哪一个看起来更好”，而是：\n在 xs.length = 10、100、1000 时 两者的 Gas 消耗曲线是否明显分离 这种对比，才能真正说明问题。\n10.5 关注“最坏情况”，而不仅是平均值 在智能合约中，最坏情况往往比平均情况更重要。\n原因包括：\nGas 不够会直接导致交易失败 用户更容易遇到极端输入 批处理和循环的风险集中在最坏情况 因此，在测试时，应当：\n尝试最大允许输入 覆盖边界条件 关注 Gas 是否接近区块限制或函数预期上限 10.6 工具并不重要，方法才重要 不同团队可能使用不同工具：\nHardhat Foundry Truffle 自定义脚本 但无论使用什么工具，核心方法都是一致的：\n固定输入 重复测试 对比 gas used 用数据支撑决策 不要为了“用工具而用工具”，而是让工具服务于结论。\n10.7 什么时候应该停止优化 一个容易忽视的问题是：什么时候该停下来？\n可以考虑以下信号：\n继续优化只能节省极少量 Gas 代码复杂度明显上升 已经覆盖了高频和高成本路径 优化收益无法抵消审计和维护成本 Gas 优化不是无止境的，而是一种平衡。\n11. 一份可执行的 Gas 优化清单 到这里，我们已经从 EVM 成本模型出发，系统地讨论了 Gas 优化在设计和实现层面的主要原则。 我们现在可以把前面的内容收敛成一份可以直接使用的清单，用于日常开发和代码评审。\n这份清单并不是“必须全部满足”的规则集合，而是一种优先级导向的检查顺序。\n11.1 设计阶段优先检查项 在写代码之前，优先思考以下问题：\n是否真的需要存储这个状态，还是可以通过计算或事件获得 状态变量是否会被频繁读写 是否存在不受限的循环或批处理接口 数据结构是否有明确的规模上限 是否存在“查找/去重/删除元素”需求 如果这些问题在设计阶段就能被回答，很多 Gas 问题可以被直接避免。\n11.2 Storage 相关检查项（最高优先级） 是否存在在同一函数中多次读取同一个 storage 变量的情况 是否在循环中直接写 storage 是否可以通过缓存变量减少 SLOAD / SSTORE 状态变量和 struct 字段顺序是否合理，避免浪费 slot 不再使用的状态是否及时 delete 是否用 mapping 替代数组进行存在性判断、去重、按 key 查询，避免 O(n) 遍历 若必须可枚举，是否使用 mapping + array + index（swap-and-pop）实现 O(1) 增删与枚举 这是最值得投入精力的优化区域。\n11.3 函数接口与参数检查项 对外接口是否优先使用 external external 函数参数是否使用 calldata 是否避免了不必要的 public 函数 是否存在 this 调用当前合约的情况 是否采用了 external 入口 + internal 实现的模式 这些优化通常风险低、收益稳定。\n11.4 循环与批处理检查项 是否缓存了数组 length 和中间结果 循环中是否避免了 storage 读写 是否避免在循环中做 O(n) 查找 是否在安全前提下使用 unchecked 循环是否存在明确的上限 批处理接口是否限制了单次处理数量 循环是 Gas 放大器，尤其需要从“最坏情况”角度审视。\n11.5 错误处理与字节码体积 是否使用 custom error 替代 require(string) 错误信息是否简洁、结构化 是否避免在字节码中嵌入大量字符串 合约体积是否接近部署限制 这些优化往往在合约复杂后才显现价值，但越早统一越好。\n11.6 事件与返回值设计 事件是否只记录必要信息 indexed 参数是否只用于高频过滤字段 是否避免在事件中携带大数组或字符串 是否避免链上返回大量数据 是否通过分页或链下索引替代一次性查询 这里的目标是：不把链当数据库使用。\n11.7 进阶优化（谨慎项） 是否已经完成基础优化 是否明确瓶颈来自 slot 数量或高频调用 位运算或 bitmap 是否真的降低了 storage 使用 是否避免在核心业务逻辑中滥用 assembly 这些优化应当是“有数据支撑的例外”，而不是常规手段。\n11.8 用数据驱动最终决策 在合并任何 Gas 优化之前，建议确认：\n是否有明确的 Gas 对比数据 优化是否发生在高频或关键路径 引入的复杂度是否可被测试和审计覆盖 如果优化的收益无法清晰说明，那通常意味着它并不重要。\n","date":"2025-09-20T14:59:56+08:00","permalink":"https://yearsuns-github-io.vercel.app/p/best-practices-for-gas-optimization-in-solidity/","title":"Solidity中的Gas优化最佳实践"},{"content":"有时候，我们想把一个git仓库的提交历史清空，重新开一条干净的时间线，只保留当前代码，可以参考如下操作：\n1. 切一个“孤儿分支”，没有任何历史 git checkout --orphan new-main 2. 把所有文件加入暂存区 git add . 3. 做一个新的第一次提交 git commit -m \u0026#34;Initial commit\u0026#34; 4. 删除旧的 main 分支（本地） git branch -D main 5. 把当前分支改名为 main git branch -m main 6. 强制推送覆盖远程 main git push -f origin main ","date":"2025-08-23T14:59:56+08:00","permalink":"https://yearsuns-github-io.vercel.app/p/how-to-clean-out-git-history/","title":"如何清空Git提交历史"},{"content":"如果你了解过 Uniswap V2，你一定知道它最大的优点是“完全自动化”，最大的问题也是“完全自动化”。资金一旦进入，都会机械地分布在从0到∞的整个价格区间。\n这本来很公平，却非常低效：\n大多数时间，资产都在远离市场价格的位置“睡觉”，没有人交易到那里，也不产生手续费。\n于是，Uniswap V3 提出一个革命性的概念：集中流动性（Concentrated Liquidity）。\n它让 LP 可以把资金“集中”在自己认为合适的价格范围内，让“活钱干活”。\n一、什么是集中流动性：背景与要解决的问题 去中心化交易合约 Uniswap 采用自动做市商（AMM）模型，用户无需挂单，也无需寻找对手方，只要向池子中注入两种代币，就可以成为流动性提供者。这种模式非常简洁，但也带来了一个不易察觉的问题：大部分流动性并没有发挥作用。\n为了说明这一点，我们需要先回顾 Uniswap v2 的机制。\n1. 传统 AMM：恒定乘积与“全价格区间” 在 v2 的恒定乘积模型中，交易池中维持一个恒定公式：\nx · y = k\n这里的 x 和 y，是池中两种资产的数量，k 是常数。无论市场价格如何波动，这个公式总是成立。\n但这个模型隐含一个设定：池子的流动性分布在从 0 到 ∞ 的整个价格范围上。理论上无论价格涨到多高、跌到多低，这个池子都“准备好”提供流动性。\n问题是：真实市场的价格从来不会走到 0 或无穷大。\n换句话说，流动性被被动地散布在一个几乎永远用不上的超级宽区间里。\n2. 流动性利用率的问题 如果流动性分布在一个过大的范围上，会造成一个非常直接的后果：\n绝大部分资金是在“睡觉”。\n现实中，价格通常在一个较窄范围内波动，因此真正参与交易的，只是这个范围以内的资金。而其他资金只是静静地躺着，却仍然需要占用资本。\n于是就出现两个影响：\n对交易者来说，主动成交的深度有限，滑点高； 对 LP 来说，明明投入很多资金，收益却并不成比例。 换句话说：\n资金利用率低。\n3. 为什么需要集中流动性 Uniswap 在 v3 版本提出集中流动性（Concentrated Liquidity），核心思想非常直接：\n流动性应当放在实际会发生交易的价格区间里。\n如果价格长期在一个区域波动，那 LP 就可以把流动性集中在这个区域，不再浪费在可能根本不会出现的极端价格上。\n这样带来的效果是显著的：\n同样的资金，提供更深的流动性 对大额交易的价格冲击减小 手续费收入提高 这实际上把 AMM 从“广泛分布”改成了“局部有效分布”。\n4. 集中流动性的定义 严格来说，集中流动性是指：\nLP 只在自己设定的价格区间 \\([P_{lower}, P_{upper}]\\) 内提供流动性，一旦价格超出范围，就不再参与交易，也不再赚费。\n这意味着，每一个 LP 不再是一个简单的资金池，而变成一个“带有条件的流动性头寸”。\n从合约的角度看，是把一个大池子拆成很多小区间，把流动性分别放入这些区间，交易发生在哪个区间，哪个区间的 LP 就得到手续费。\n5. 它解决的到底是什么问题 如果用一句话概括：\n用同样的资本，获得更高的有效深度。\n但具体来说，它带来三项核心改进：\n提高资本效率 降低滑点 提高 LP 的费收益率 这些优点都来自同一个事实：流动性终于可以集中，而不是无边界地稀释。\n6. 但它并不是免费的优化 集中流动性并没有改变 AMM 的基本逻辑，而是引入一个新的维度：价格区间。\n这让 LP 的岗位变得更像需要判断价格趋势的“策略性角色”。因此，集中流动性同时带来了一个新的风险：\n如果价格突破区间，头寸会变成单边资产，并停止产生收益。 为了获得更高的收益，需要承担更多管理与判断成本。这是一种典型的“收益与风险互换”关系。\n二、集中流动性是如何运行的 1. 提供流动性需要输入什么 假设我们向 ETH/USDC 池子提供流动性，合约会要求我们输入：\n币对：ETH / USDC\n价格区间\nlower price 例：2000 USDC/ETH upper price 例：3000 USDC/ETH 想提供多少 ETH 或多少 USDC\n也就是说，我们其实是在告诉合约三件事：\n我想参与 ETH / USDC 交易对的做市 在 2000～3000 这个区间 我愿意提供多少币 2. 需要提供什么代币 假设当前 ETH/USDC 价格是 2500，那么系统判断为：\n2000 \u0026lt; 2500 \u0026lt; 3000 也就是“价格在区间内”。\n这个判断非常重要，因为它直接影响我们需要提供的资产结构：\n三种情况 当前价格 需要提供 在区间内 需要同时提供 ETH 和 USDC 当前价格低于区间 只会用到 USDC 当前价格高于区间 只会用到 ETH 为什么会这样？它不是策略，而是数学决定的：AMM 会在不同价格状态下，自动将持仓偏向一种资产，这由模型决定，不是策略行为。\n简单地理解就是，物以稀为贵。当价格较低时，交易池需要更多的 USDC，当价格较高时，交易池需要更多的 ETH。\n3. 理解流动性 虽然我们给的是资产（ETH/USDC），但合约内部记录的是一个抽象量 L（流动性单位）。\n理解要点：\n我们投入的是资产 合约记录的是 L 我们未来赚的钱与 L 成正比 更直观说：\nL 就像我们在这个价格区间的“份额大小”。\n而 ETH / USDC 的数量，会随着价格变化自动调整。\n4. 价格区间离散化 我们给的区间是连续价格（比如 2000→3000），但合约内部用 tick 记录价格。\n合约会把它们转成：\n\\(tick_{Lower}\\) \\(tick_{Upper}\\) tick 是一个离散价格，用来标记区间边界。\n这一步之后，合约会为这个区间范围增加相应的流动性，实际记录方式为只记录边界状态：\n在 \\(tick_{Lower}\\) 位置把流动性 +L 在 \\(tick_{Upper}\\) 位置把流动性 -L 这样，当前活跃的流动性等于所有当前价格以下的净流动性之和：\n\\[ activeLiquidity = \\sum (netLiquidity \u003c \\text{current tick}) \\]比如 \\(tick_{Lower}=100\\), \\(tick_{Upper}=200\\)，合约会记录为\nnetLiquidity[100] += 10 netLiquidity[200] -= 10 如果当前价格 tick 是 150，那么 activeLiquidity 等于所有 tick \u0026lt; 150 的 netLiquidity 之和，也就是10\n如果当前价格 tick 是 205，那么 activeLiquidity 等于所有 tick \u0026lt; 205 的 netLiquidity 之和，也就是0\n所以，当价格穿过这些 tick 时，系统就知道应该在什么时候开始、什么时候结束使用我们的流动性。\n为什么在存储区间时，要对价格进行离散处理？\n如果用线性划分，当 ETH/USDC 的价格在 2000～3000 区间时，简单切 1000 段，每段 1USDC，当然可以，看起来也很自然。\n但是如果价格区间变为 0.2~0.3 或者更低呢？还是按照切 1000 段，就会导致每段区间过小，整体刻度是极不均匀的。\n而且真实情况下，不同代币的价格可能跨越几个数量级，从 0.0000001 到 10000000 都可能，因此也无法为所有的币统一刻度。\n如何进行离散处理呢？\n我们设定每个刻度对应的价格是前一个刻度对应价格的固定倍数 \\(r\\)，那么对于tick+1刻度的价格 \\(P_{tick+1}\\) 有以下公式\n\\[ P_{tick+1} = P_{tick} \\times r \\] 由此就很容易推导出以下公式\n\\[ P_{tick} = P_0 \\times r^{tick} \\] 如果设定初始值 \\(P_0=1\\)，常量 \\(r=1.0001\\)，则可以得到\n\\[ P_{tick} = 1.0001^{tick} \\] 这意味着每次 tick 移动，价格变 0.01%。\n现在我们就可以将任意价格使用tick表示\n\\[ tick = log_{1.0001}P \\] 比如\n\\(P=0.25\\) 对应的 \\(tick\\approx-13864\\)\n\\(P=2500\\) 对应的 \\(tick\\approx78244\\)\n那么我们的均匀刻度就设计好了，它可以适用于任意价格的代币（只要价格不是负数🤪）\n5. 保存流动性状态 当我们添加流动性时，系统会给我们分配一个 NFT，它记录：\n选择的区间（2000～3000） L 的大小 已经累计能够领取的手续费 后续计算手续费需要用到的当前 fee 状态 因此：\n做市行为不再是池子的一部分，而是一个 NFT 记录的独立头寸。\n6. 持仓变化 当价格在区间内：\n同时持有 ETH 和 USDC 随着交易发生，两者互相转换 参与撮合并赚手续费 如果价格跌破 2000：\n头寸会变成全部 USDC 不再参与做市，也停止赚手续费 如果价格突破 3000：\n头寸会变成全部 ETH 同样退出做市 换句话说：\nETH 涨，头寸更偏 ETH；ETH 跌，头寸更偏 USDC。\n这个行为不是策略，而是 AMM 自动完成的结果。\n7. 手续费结算 交易发生在区间内（2500在内），就会累积手续费。合约内部会把手续费累计到该区间的 feeGrowth 中。\n提现时合约会做两件事：\n返回当前持仓（可能是 ETH+USDC，可能是单币） 返回累计所得手续费 不需要手动领，提现时自动结算。\n三、主要公式推导 1. 官方白皮书 v2链接： https://docs.uniswap.org/whitepaper.pdf\nv3链接： https://app.uniswap.org/whitepaper-v3.pdf\nv4链接： https://app.uniswap.org/whitepaper-v4.pdf\n2. 基础公式 虚拟资金池曲线（交易模型）\n\\[ x \\times y = k \\tag{1} \\]流动性\n\\[ L = \\sqrt{xy} \\tag{2} \\]价格\n\\[ P = \\frac{y}{x} \\tag{3} \\]有效资金池曲线\n\\[ (x+\\dfrac{L}{\\sqrt{p_{b}}})(y+L\\sqrt{p_{a}})=L^{2} \\tag{4} \\]2. 有效资金池曲线推导 根据上图1所示，当前价格在 c 点，假设实际价格的波动范围为 [a,b]\n那么当价格从 c 点向 a 点滑动时，资金池的消耗最大为 \\(y_{real}\\) ，同理，当价格由 c 点向 b 点滑动时，资金池的消耗最大为 \\(x_{real}\\)\n因此，理论上只需要提供 \\(x_{real}\\) 和 \\(y_{real}\\) 就够了，其余的资金是永远都用不上的，这也说明了为什么xyk基础模型的资金利用率低\n那么问题来了，实际有效的资金池曲线应该是什么样的呢？\n如上图2所示，我们开始推导这个有效资金池曲线公式\n\\[ L^2 = xy \\\\ P = \\frac{y}{x} \\]对于攻读过初中数学学位的人来说，将等式两边相乘和相除就可以轻松推导出以下公式\n\\[ \\begin{aligned} x=\\dfrac{L}{\\sqrt{P}} \\\\ y=L\\sqrt{P} \\tag{4} \\end{aligned} \\]由图1可知\n\\[ x=x_{real}+x_b \\\\ y=y_{real}+y_a \\]代入公式 (1) 的 xyk 模型可得\n\\[ (x_{real}+x_b)(y_{real}+y_a)=k=L^2 \\]再根据公式 (4) 将 \\(x_b, y_a\\) 替换可得\n\\[ (x_{real}+\\dfrac{L}{\\sqrt{P_{b}}})(y_{real}+L\\sqrt{P_{a}})=L^{2} \\]这就是最终的有效资金池曲线了\n3. 计算流动性变化 我们提供流动性后，合约开始进行各种交易行为，那么要如何计算当前我们提供的流动性中资产是如何分配的？\n根据上面的公式(4)：\n\\[ \\begin{aligned} x=\\dfrac{L}{\\sqrt{p}} \\\\ y=L\\sqrt{P} \\tag{4} \\end{aligned} \\]令：\n\\[ \\begin{aligned} S = \\sqrt{P} \\end{aligned} \\]则：\n\\[ \\begin{aligned} x=\\dfrac{L}{S} \\\\ y=LS \\end{aligned} \\]因为 L 不变，对 S 求微分：\n对 x：\n\\[ x = \\frac{L}{S} \\Rightarrow dx = -L \\frac{1}{S^2} dS \\]对 y：\n\\[ y = L S \\Rightarrow dy = L dS \\]所以有两条很重要的微分关系：\n\\[ dx = -L \\frac{1}{S^2} dS,\\qquad dy = L dS \\]假设一个 LP 的有效价格区间是：\n下界价格：\\(P_a\\)，对应 \\(S_a = \\sqrt{P_a}\\) 上界价格：\\(P_b\\)，对应 \\(S_b = \\sqrt{P_b}\\) 只看 \\(token_y\\) 的变化\n在区间内，S 从 (S_a) 增长到 (S_b) 时：\n\\[ dy = L dS \\]对 S 从 (S_a) 到 (S_b) 积分：\n\\[ \\Delta y = \\int_{S_a}^{S_b} L, dS = L (S_b - S_a) = L(\\sqrt{P_b} - \\sqrt{P_a}) \\]这就是 在整个 \\([P_a, P_b]\\) 区间里对应的 \\(token_y\\) 数量：\n\\[ amount_y = L(\\sqrt{P_b} - \\sqrt{P_a}) \\]只看 \\(token_x\\)的变化\n对 \\(token_x\\)：\n\\[ dx = -L \\frac{1}{S^2} dS \\]注意： x 和 S 方向相反（价格上升 → \\(token_x\\) 减少）， 我们要的是区间内总共的 \\(token_x\\) 数量，取绝对值来算：\n\\[ \\Delta x = \\int_{S_a}^{S_b} L \\frac{1}{S^2} dS \\]计算：\n\\[ \\int \\frac{1}{S^2} dS = -\\frac{1}{S} \\]所以：\n\\[ \\Delta x = L\\left[-\\frac{1}{S}\\right]_{S_a}^{S_b} = L\\left(-\\frac{1}{S_b} + \\frac{1}{S_a}\\right) = L\\left(\\frac{1}{S_a} - \\frac{1}{S_b}\\right) \\]代回 \\(S = \\sqrt{P}\\)：\n\\[ amount_x = L\\left(\\frac{1}{\\sqrt{P_a}} - \\frac{1}{\\sqrt{P_b}}\\right) \\]这就是 \\(token_x\\) 的区间公式。\n上面推导的是整个 \\([P_a, P_b]\\) 区间的总 x/y。 但实际情况取决于当前价格 (P) 在区间里的位置：\n情况 A：当前价格在区间内部（\\(P_a \u003c P \u003c P_b\\)）\n这时的头寸是“部分在 token0，部分在 token1”：\n对 \\(token_x\\)，有效区间是 [P, Pb] （高价端还没被换走的 \\(token_x\\)）\n\\[ amount_x = L\\left(\\frac{1}{\\sqrt{P}} - \\frac{1}{\\sqrt{P_b}}\\right) \\] 对 \\(token_y\\)，有效区间是 [Pa, P] （从下界到现在已经变成 \\(token_y\\) 的部分）\n[ amount_y = L(\\sqrt{P} - \\sqrt{P_a}) ]\n情况 B：价格低于区间（\\(P \\le P_a\\)）\n还没开始“向上走”，流动性全部在 \\(token_x\\) 形态：\n\\[ amount_x = L\\left(\\frac{1}{\\sqrt{P_a}} - \\frac{1}{\\sqrt{P_b}}\\right) \\\\ \\quad amount_y = 0 \\]情况 C：价格高于区间（\\(P \\ge P_b\\)）\n已经“完全向上走完”，全部变成 \\(token_y\\)：\n\\[ amount_x = 0 \\\\ \\quad amount_y = L(\\sqrt{P_b} - \\sqrt{P_a}) \\]4. 计算实际交易价格 我们已经知道了交易原理和基本公式，那么当我们准备通过交易池兑换代币时，因为我们投入的资产也会影响交易池的资产比例，\\(P=\\dfrac{y}{x}\\) 只是理论价格，那么应该如何计算实际交易价格呢？比如说1个 ETH 能换多少 USDC ？\n当我们往池子里投入 \\(\\Delta x\\) 个 ETH 时，池中的 USDC 会减少 \\(\\Delta y\\)，对应的价格也会从 \\(P_0\\) 下跌到 \\(P_1\\)，于是有以下关系\n\\[ \\begin{aligned} \\Delta x \u0026= L\\left(\\frac{1}{\\sqrt{P_1}} - \\frac{1}{\\sqrt{P_0}}\\right) = L\\left(\\frac{1}{S_1} - \\frac{1}{S_0}\\right) \\Rightarrow S_1 = \\frac{1}{\\dfrac{\\Delta x}{L} + \\dfrac{1}{S_0}} \\\\ \\Delta y \u0026= L(\\sqrt{P_0} - \\sqrt{P_1}) = L(S_0 - S_1) = L\\left(S_0 - \\frac{1}{\\dfrac{\\Delta x}{L} + \\dfrac{1}{S_0}}\\right) \\end{aligned} \\]其中，L为当前区间的流动性。\n如果交易量很大、会跨 tick，就把区间拆成多段，对每一段用同样的方法算一段，然后把每一段的 Δy 累加起来即可。\n","date":"2025-08-02T14:59:56+08:00","permalink":"https://yearsuns-github-io.vercel.app/p/a-deep-dive-into-the-fundamental-principles-of-uniswaps-concentrated-liquidity/","title":"深入理解Uniswap的集中流动性基本原理"},{"content":" XYK 就是：把一对资产放进一个“水池”，规定池里两种资产数量的乘积始终相等 x * y = k； 所有交易都必须沿着这条规则移动，于是价格、滑点、收益、风险都从这个公式里自然长出来。\n接下来我们通过简单推导，一步一步厘清这其中的数学逻辑。\n一、传统交易：为什么非得有个订单簿？ 在传统交易所里，核心是一个订单簿（Order Book）：\nA 在 100 元挂买 1 个 ETH B 在 101 元挂卖 2 个 ETH 系统把买单卖单匹配，撮合成交 这种模式有几个典型特点：\n需要专业做市商\n如果没人挂单，普通人根本没法交易 做市商需要 24 小时盯盘、调价 需要一个中心化撮合引擎\n由交易所运营 你必须“相信”这个中间人 普通人难以参与做市\n提供流动性门槛很高 很多收益只掌握在少数机构手里 对于区块链这种“人人都可以参与”的世界来说，这种设计太“中心化”了。\n二、AMM：把做市变成一个资金池 AMM（自动做市商）最大的创新，是把交易市场从“挂单撮合 → 双边参与”变成了“资金池 → 任何人都能加入”。\n资金池（Liquidity Pool）里同时放入两种资产，例如 ETH 和 USDT。池子运行遵循一个数学规则：\nx * y = k 这就是所谓的 XYK（x*y=k）恒定乘积做市模型。\n只要有人用 USDT 买 ETH，那么 ETH 减少、USDT 增多，就必须自动调整数值，使乘积保持不变。\n这个规则取代了订单簿：\n无需挂买卖单 无需专业做市商 无需中心化撮合引擎 任意用户都能参与 所以 AMM 的本质是：\n用一个资金池 + 一个数学公式 替代传统撮合系统。\n价格、滑点、流动性深度等概念，全部从这个公式里自然推导出来。\n三、价格是怎么算出来的？ 先设定一个具体例子：\n池子里有：\nETH：x = 100 USDT：y = 10000 那 ETH 的价格是什么？\n很自然的想法：\n价格 = USDT 数量 / ETH 数量 = y / x = 10000 / 100 = 100 USDT 几点关键认识：\n价格不是“挂出来的”，而是由池子状态算出来的 池子状态一变，价格就自动变化 这个价格是“池内价格”，会被外部市场套利修正 所以在 AMM 中：\n价格 = 池内两种资产的数量比\n四、交易是怎么推动价格变动的？ 现在我们来做一个简单但非常重要的例子。\n4.1 初始状态 x = 100 ETH y = 10000 USDT k = x * y = 100 * 10000 = 1,000,000 价格 P₀ = y / x = 100 USDT/ETH 有个用户想用 1000 USDT 买 ETH。\n在 AMM 中，交易规则是：\n交易前后都要满足：x * y = k\n4.2 交易后的新状态 用户往池子里加入 1000 USDT，记为 Δy = +1000：\n交易后 USDT 数量： y₂ = 10000 + 1000 = 11000 因为 x * y 要保持等于 1,000,000： x₂ = k / y₂ = 1,000,000 / 11000 ≈ 90.909 ETH 那么，用户从池子里拿走的 ETH 是：\nΔx = x₁ - x₂ = 100 - 90.909 ≈ 9.091 ETH 他实际上用 1000 USDT 买到了约 9.091 ETH：\n平均买入价格 ≈ 1000 / 9.091 ≈ 110 USDT/ETH 而此时新价格为：\nP₁ = y₂ / x₂ ≈ 11000 / 90.909 ≈ 121 USDT/ETH 你会看到三件事：\n用户最后的平均买价 ≈ 110 交易结束时的最新价格 ≈ 121 一开始池子的价格是 100 这就是现实里感受到的：\n“怎么我一买，价格就上去了，还越买越贵？”\n这就是 滑点（Slippage） 的来源。\n五、滑点：不是费用，而是你自己推高的价格 从上面的例子可以总结：\n滑点并不是额外收费 而是：因为你的这笔交易改变了池子的价格 可以粗略理解为：\n你在交易的过程中，从便宜 → 贵 的一整条价格区间上买了一段货。\n交易越大，沿着曲线走得越远，平均买入价就比起点价格高得越多。\n六、为什么池子越大，滑点越小？ 做一个对比试验。\n6.1 小池子：100 ETH / 10000 USDT 还是刚才的池子：\n100 ETH 10000 USDT 用 1000 USDT 买，价格从 100 → 121，变化很明显 6.2 大池子：1000 ETH / 100000 USDT 换成一个更大的池子（放大 10 倍）：\nx = 1000 y = 100000 k = 1000 * 100000 = 100,000,000 初始价格 = 100,000 / 1000 = 100 USDT/ETH 同样用 1000 USDT 买：\ny₂ = 100000 + 1000 = 101000 x₂ = k / y₂ = 100,000,000 / 101000 ≈ 990.099 ETH Δx ≈ 1000 - 990.099 ≈ 9.901 ETH 平均买入价 ≈ 1000 / 9.901 ≈ 101.0 USDT/ETH 新价格 P₁ ≈ 101000 / 990.099 ≈ 102.0 USDT/ETH 对比一下：\n池子大小 初始价 平均买价 最终价格 价格涨幅 小池（100 / 10000） 100 ≈110 ≈121 涨 21% 大池（1000 / 100000） 100 ≈101 ≈102 涨 2% 结论：\n池子越大，单笔交易对价格的影响越小，滑点就越低。\n直觉类比：\n小池子像一个脸盆，你舀一桶水进去，水位变化很明显 大池子像一个湖，你舀一桶水进去，没啥感觉 这就是“流动性深度”的直观意义。\n七、流动性：到底是什么？ 在 AMM 中，“流动性”不再是一个抽象词，而是池子里真实存在的资产数量。\n流动性越多 → 曲线越“平滑” → 价格越稳定 流动性越少 → 曲线越“陡峭” → 价格更容易被推飞 更重要的是：在 AMM 中，任何人都可以提供流动性。\n这意味着：\n原本只有专业做市商能干的事，现在所有用户都能做，而且还能赚手续费。\n八、作为普通人，你怎么参与这个池子？ 假设现在有一个 ETH/USDT 池，状态是：\nx = 100 ETH y = 10000 USDT 价格是 100 USDT/ETH。\n你想成为 LP（流动性提供者），往里加一点资金。\n8.1 必须按当前价格比例存入 因为：\n池子里的资产比例本身就是价格 如果你随便乱放，只放 ETH 不放 USDT，就会破坏价格 所以系统要求：\n你要按当前价格的比例同时存入两种资产。\n比如：\n想存入 1 ETH 当前价格是 100 USDT/ETH 那就需要再存入 100 USDT 这时：\nx_new = 101 ETH y_new = 10100 USDT 价格仍然 = 10100 / 101 = 100 USDT/ETH 价格没有被你改变，池子只是变大了一点。\n8.2 你获得“份额凭证” 每个 LP 存入资产后，会得到一个代表池子份额的代币（LP Token）。\n整个池子好比一个“蛋糕” 你按照你贡献的资产获得“蛋糕份额” 将来你退出时：\n你拿回的是 当时池子里的一部分资产，而不是你最初存进去的那一模一样的组合。\n这一点，是理解“无常损失”的基础。\n九、手续费：LP 是怎么赚钱的？ 每一笔交易，协议一般会收取一小部分手续费（比如 0.3%），这笔钱：\n不是给“平台”拿走 而是直接进入资金池，按份额分给所有 LP 可以这样理解：\n交易者在用你的资产做交换，你从中抽取一点点“路费”。\n简单模拟：\n你占池子 10% 的份额 全池一共累积了 1000 USDT 的手续费 你退出时，就拿到大约 100 USDT 的手续费收益（再加上池子里的资产变化） 所以 LP 的收入来源主要有：\n交易手续费 某些协议发放的激励（比如奖励代币） 十、无常损失：为什么 LP 会看起来亏了？ 虽然 LP 可以赚手续费，但也会面临一个著名问题：无常损失（Impermanent Loss）。\n先看一个最直观、最典型、最容易理解的例子。\n假设池子里只有：\n1 ETH + 100 USDT 这表示当前价格隐含为：\n1 ETH = 100 USDT 现在你作为 LP 存入等价的资产（即同样按照当前价格比例）：\n再存入 1 ETH + 100 USDT（价值 200 USDT） 池子变成：\n2 ETH + 200 USDT 总价值 400 USDT，而你贡献了其中 200 USDT，也就是：\n你占整个池子的 50% 10.1 LP 份额不会变，但池子的资产会变 注意：作为 LP，你拥有的是池子整体的 份额（%），不是具体资产数量。\n也就是说：\n你拥有池子 50%，但未来那“50%”里面，ETH 和 USDT 的数量会变。\n10.2 假设市场发生变化 经过一段时间，如果 ETH 相对 USDT 的价格下降，为了维持恒定乘积规则，池子里的 ETH 会变多，USDT 会变少。\n假设最终池子变成：\n4 ETH + 100 USDT 别看：数量看起来好像多了，但我们来计算 LP 的实际资产。\n你拥有 50%，所以你取出：\n2 ETH + 50 USDT 10.3 来算一下实际价值 现在池子隐含价格为：\n100 / 4 = 25 USDT/ETH 因此你实际得到的价值是：\n2 ETH = 2 * 25 = 50 USDT 50 USDT + 50 USDT = 100 USDT 也就是说：\n你投入价值 200 USDT，最后只剩价值 100 USDT\n注意这里还没算手续费，所以我们可以说你经历了一个典型的“无常损失”。\n10.4 为什么会这样？ 仔细观察资产变化：\n项目 初始 退出 ETH 1 2 USDT 100 50 因为 ETH 比例增加、USDT 减少，说明市场认为 ETH “更不值钱”，套利者从池子里拿走 USDT、往池子里丢 ETH，让价格回归外部市场。\n最终表现是：\n你成了“接盘 ETH”那部分人\n当价格下跌时，池子倾向变成“ETH 更多、USDT 更少”，而你的份额跟着变，因此导致资产缩水。\n10.5 最重要的理解 LP 不是持有一组固定数量的资产，而是持有池子的一段“动态资产组合”。\n而这个组合会自动调整方向：\nETH 上涨 → 资产组合偏向 USDT ETH 下跌 → 资产组合偏向 ETH 因此：\n价格波动越大，无常损失越明显。\n这才是无常损失本质。\n十一、XYK 模型到底解决了什么？ 总结一下 XYK 带来的改变：\n不再需要订单簿\n没有挂单，也没有撮合引擎 一切都在一个池子里完成 价格靠算法决定\nx * y = k + 价格 = y / x 所有价格变动都是公式推出来的 任何人都能成为做市商\n只要照比例存入两种资产 不需要 24 小时盯盘，也不需要写交易策略 交易基础设施变成公共的\n不是某个中心化机构专有 而是任何人都能参与、共享收益 十二、XYK 的局限与后续演进 XYK 虽然经典，但也有明显缺点：\n滑点较大\n对于价格波动小、稳定币之间的交易，XYK 不够“省滑点” 于是出现了像 Curve 那样的“稳定币专用曲线” 资本利用率不高\n资金需要覆盖一个宽范围的价格区间，却不一定都被用到 Uniswap v3 通过“集中流动性”优化了这一点 无常损失\nLP 承担价格波动风险 对只想“躺平持币”的人不够友好 尽管如此：\nXYK 仍然是所有后续 AMM 设计的入门钥匙。 理解了 XYK，后面看 Uniswap v2/v3、Curve、Balancer 等模型都会轻松很多。\n十三、总结：再看一眼那条简单的公式 我们再回到那条看似朴素的公式：\nx * y = k 在这条公式之上，实际上生长出了：\n价格：P = y / x 滑点：交易沿曲线移动带来的价格变化 流动性深度：池子大小决定曲线陡峭程度 LP 收益：手续费分配机制 无常损失：LP 与单纯持币的结果对比差额 你可以把 XYK 看成 DeFi 里的“F=ma”：\n它简单到一句话就能写完，但几乎整个去中心化交易市场，都建立在它的思想之上。\n","date":"2025-07-16T14:59:56+08:00","permalink":"https://yearsuns-github-io.vercel.app/p/a-deep-dive-into-the-fundamental-principles-of-uniswaps-xyk-model/","title":"深入理解Uniswap的XYK模型基本原理"},{"content":"一、引言：密码是互联网世界的最后防线 在整个互联网安全体系中，密码是最常见但也最脆弱的那一环。 我们每天使用的几乎所有服务——邮箱、网银、社交平台、游戏、论坛——都依赖密码来识别用户身份。\n密码本质上是一种“弱凭证”：\n它不能证明用户是谁，只能证明“知道某个秘密” 一旦这个秘密泄露，攻击者就能完全冒充你 现代互联网攻击频繁且多样化，一次普通的密码泄露事件，往往会导致用户多个平台的账号一起“沦陷”。 要想守住这道防线，必须从传输阶段和存储阶段两方面同时发力。\n本文将从基础概念出发，逐层深入，到最后构建出现代网站应采用的完整密码安全体系。\n二、密码为什么如此危险？ 初看起来，密码就是一些字符组成的字符串。 但密码泄露的危害远比想象严重，主要体现在两个方面。\n2.1 风险一：传输途中泄露 从用户输入密码，到密码抵达服务器，中间会经过：\n浏览器 本地域名解析 操作系统网络栈 路由器 运营商网络 服务器负载均衡 只要链路中任何一个环节被攻击，密码就可能被拦截。\n理论上，HTTPS 已经解决了“被监听问题”。 但实际情况比理论复杂得多，常见风险包括：\n用户电脑被恶意软件植入假根证书（典型的中间人攻击手段） 公司/学校内网采用流量审计，自动解密 TLS 公共 Wi-Fi 通过 ARP 欺骗截获 HTTPS 并强制重新签发证书 浏览器插件注入恶意脚本读取用户输入 某些软件声称“优化网速”，实际插入监听模块 某些企业网关进行 SSL Inspection（合法但不安全） 换句话说：\n你无法假设用户设备、网络环境永远是安全的。\n因此，传输阶段仍有提升空间。\n2.2 风险二：服务器端泄露 更多泄露事件来自服务器端，常见场景包括：\n数据库被拖库（最常见） 日志中意外打印了用户密码 开发者临时调试时把密码输出到控制台 备份文件未加密，被误传到公共服务器 第三方监控系统抓取了敏感字段 代码漏洞（SQL 注入、RCE）导致数据库暴露 运维人员内部滥用权限 如果服务器保存的是 明文密码，后果极其严重：\n所有用户密码全部泄露 用户在其他网站的账号也会被攻击（密码复用） 一旦攻击者能登录用户邮箱，后果会更加连锁扩大 因此，服务器端必须确保“即使泄露，攻击者也不能从数据库中拿到真正密码”。\n三、密码应该如何在网络中安全传输？ 3.1 最朴素的方案：HTTPS 直接发送密码 这是目前几乎所有网站的默认做法：\n浏览器 ——HTTPS——\u0026gt; 服务器 优点：\n简单 成熟 性能高 兼容性好 缺点是： 它把所有风险完全寄托在 TLS 的可靠性上。\n如果 TLS 被中间人攻击破坏，密码也会被明文劫持。\n于是有人提出：是否应该 在浏览器端先对密码做一次 hash？\n四、前端 hash：可降低的风险与无法降低的风险 前端 hash 的核心思想是：\n即便传输被监听，攻击者拿到的也不是明文密码。\n假设：\nP = 用户密码 H1 = hash(P) 浏览器发送 H1，而非 P。\n4.1 前端 hash 能防护什么？ 避免 MITM 直接获得用户真实密码 服务器日志、监控系统误输出时不会泄露明文密码 攻击者得到 H1 也无法用它登录用户在其他网站的账号 即使用户复用密码，也不会因为你的网站泄露而波及其他网站（很重要） 服务器可以完全不接触明文密码（零知识认证的一种初级形态） 前端 hash 的意义在于：\n“就算你的网站被攻破，也不能泄露用户在其他网站的密码。”\n这是传统方案做不到的。\n4.2 前端 hash 不能防护什么？ 攻击者可以直接使用 H1 登录你的网站（因为你把它当成凭证） 用户电脑中毒、键盘监听仍能拿到 P 不带 challenge 的 hash 会被重放攻击利用 不能替代 HTTPS（hash 后的结果也需要加密） 换句话说：\n前端 hash 能减少损失，但不能消灭风险。\n4.3 前端 hash 是否必要？ 实践中，它属于 可选但增益明确 的安全措施。\n如果实现得当（通过 challenge 防重放），前端 hash 可以构成双重防线：\nTLS 层：传输安全 hash 层：降低密码复用的连带风险 对于安全要求较高的系统（银行、企业级服务、开发者平台），常会采用这种方式。\n五、服务器端应该如何存储密码？ 接下来进入密码安全的核心： 密码永不以明文形式出现，即便在服务器内部。\n行业标准包含三个关键词：\nhash salt slow hash（慢哈希） 5.1 哈希算法：从可逆变成不可逆 一个好的哈希函数应具备：\n碰撞概率极低 输入变化一位，输出完全不同（雪崩效应） 无法从输出反推输入 服务器保存的不是密码，而是：\nH = hash(P) 如果数据库泄露，攻击者无法直接得到密码。\n5.2 盐（Salt）：阻止彩虹表和批量破解 没有盐，所有用户的弱密码会产生相同的哈希。攻击者可以：\n用现成彩虹表匹配 批量推测密码（只需对每种常见密码算一次 hash） 加入随机盐：\nH = hash(P + salt) 每个用户的 salt 都不同，这意味着：\n两个“123456”的用户哈希也完全不同 彩虹表无效 攻击者必须针对每个用户分别尝试（成本剧增） salt 必须：\n足够长（16 字节以上） 随机（CSPRNG） 每个用户独立生成 不加密，明文存储在数据库中 5.3 慢哈希（Slow Hash）：真正提升攻击成本 SHA256 这类传统算法太快了。 现代 GPU 每秒可计算数十亿次 SHA256。\n这意味着：\n如果使用 SHA256 直接存密码，即便加盐，攻击者仍然可以在短时间内撞库。\n因此必须使用专门为密码存储设计的慢哈希算法，例如：\n算法 特点 bcrypt 经典方案，可靠成熟 scrypt 抗 GPU，内存占用高 Argon2（推荐） 密码学大赛冠军，可调节 CPU、内存、并行度 慢哈希的目标并不是“更安全的哈希”，而是：\n让每次计算都变得昂贵，使攻击者无法进行大规模暴力破解。\n工程实践中，登录速度影响不大，因为：\n用户登录次数相对少 每次 slow-hash 只需几十毫秒 攻击者无法用同样的速度尝试数十亿次密码 六、双层保护：前端 hash + 后端 slow-hash 综合前端与后端：\nP → H1 = hash1(P) → （传输） → H2 = bcrypt(H1 + salt) 双层含义：\n即使 MITM 拿到 H1，也无法登录其他网站 即使数据库泄露拿到 H2，也很难反推 H1，更推不回 P 服务器永不接触明文密码，减少数据泄露面 日志、监控、报错信息都不会泄露 P 这种“前端 hash + 后端慢哈希”的双层方案，在一些高安全要求的系统中被采用，用来降低密码泄露带来的连带风险。\n七、前端 hash 面临的“重放攻击”问题与解决方案 如果前端 hash 写成：\nH1 = hash(P) 攻击者截获 H1 → 可反复使用 H1 伪装用户登录。 这与“截获明文密码”几乎一样危险。\n解决方案是加入 随机 challenge（挑战值）。\n7.1 完整流程 用户访问登录页 服务器生成 challenge\nchallenge = 随机字符串 浏览器收到 challenge 并计算\nH1 = hash(P + challenge) 服务器验证 服务器用相同的规则验证：\nbcrypt(H1 + salt) == stored_hash 7.2 这样做的好处 H1 每次不同（因为 challenge 不同） 攻击者截获 H1 不能重放 MITM 攻击的价值下降 不需要在后端存储 challenge，只需验证一次后丢弃即可 7.3 常见工程问题 challenge 需要避免被缓存（设置 no-cache 响应头） challenge 不能太短（至少 16 字节以上） 前端必须使用安全的哈希函数（SHA256 或以上） 必须配合 HTTPS，否则 challenge 也会被劫持 八、密码安全的若干补充实践（常被忽略） 以下是许多工程团队常忽略但非常重要的细节。\n8.1 永远不要通过邮件发送用户密码 “重置密码并邮件发送新密码”这种做法极其危险。 正确方式是：\n邮件发送重置链接 链接带一次性 token 用户必须重新设置密码 8.2 不要允许弱密码 弱密码的破解速度是指数级快的：\n123456 password qwerty 用户手机号 用户生日 应采用：\n黑名单词表（top 10k 最常见密码） 长度策略（≥12 字符） 强制使用密码管理器提示 8.3 多因素身份验证（MFA / 2FA） 密码只是第一层。 加入第二层身份验证可以极大降低攻击成功率：\nTOTP（Google Authenticator） 短信验证码（弱，但仍有意义） 硬件密钥（FIDO2 / U2F） 8.4 账号保护机制 登录失败次数过多 → 暂时锁定 在可疑设备登录 → 发送提醒邮件 登录 IP/UA 异常 → 要求二次验证 支持用户查看“最近登录设备记录” 8.5 密码泄露检测（HIBP API） 大型网站会在用户设置新密码时检查：\n该密码是否出现在大型泄露数据库中（如 HaveIBeenPwned） 这能显著降低弱密码带来的风险。\n九、现代密码体系的目标 通过本文的 step-by-step 介绍，我们可以建立一套现代密码工程的完整体系：\n9.1 传输安全 使用 HTTPS 必要时使用前端 hash 防止密码复用带来的连锁风险 使用 challenge 防止重放 9.2 存储安全 永不存储明文密码 每个用户使用独立 salt 使用 slow-hash 9.3 账号安全机制 强密码策略 MFA 登录异常检测 密码泄露比对 日志不记录敏感信息 最终实现的目标只有一个：\n即便整个服务器被攻陷，攻击者仍然无法从系统中拿到任何用户的真实密码。\n","date":"2025-06-29T14:59:56+08:00","permalink":"https://yearsuns-github-io.vercel.app/p/how-passwords-should-be-safely-transmitted-and-stored/","title":"用户密码应该如何安全传输与存储"},{"content":"软件世界是建立在信任之上的：用户相信程序，程序相信数据，系统相信环境。 然而，只要存在输入、网络、用户与攻击者，这种信任就随时可能被打破。\n下面总结了程序员必须了解的 十大网络安全风险。它们并不神秘，但都极其常见。一旦发生，会直接影响系统的可靠性、数据安全以及用户信任。\n1. SQL 注入（SQL Injection） SQL 注入是最经典也最基础的安全问题。 只要 SQL 是通过字符串拼接生成的，就可能被恶意修改逻辑。\n示例：\nquery = f\u0026#34;SELECT * FROM users WHERE name = \u0026#39;{username}\u0026#39;\u0026#34; 当 username 为：\n\u0026#39; OR 1=1 -- SQL 将变为：\nSELECT * FROM users WHERE name = \u0026#39;\u0026#39; OR 1=1 --\u0026#39; 结果就是把整张表都查出来。\n防御方式：\n使用参数化查询（Prepared Statement） 永远不要用字符串拼接构造 SQL 2. 跨站脚本攻击（XSS） XSS 的本质是：用户输入的内容被当作脚本执行了。\n例子：\n\u0026lt;div\u0026gt;{{ nickname }}\u0026lt;/div\u0026gt; 如果昵称是：\n\u0026lt;script\u0026gt;alert(\u0026#39;XSS\u0026#39;)\u0026lt;/script\u0026gt; 页面就会执行这段代码。\n后果可能是窃取 Cookie、篡改页面、发起恶意请求等。\n防御方式：\n输出前进行 HTML 转义 使用默认防御 XSS 的模板引擎（React/Vue 等） 3. 跨站请求伪造（CSRF） CSRF 的特点是：用户在登录状态下，被诱导访问某个恶意页面，然后浏览器自动携带 Cookie，导致后台执行了用户并未授权的操作。\n例如：\n\u0026lt;img src=\u0026#34;https://bank.com/transfer?to=hacker\u0026amp;amount=5000\u0026#34;\u0026gt; 只要用户登录过银行网站，这个请求就可能执行。\n防御方式：\n使用 CSRF Token 设置 Cookie 的 SameSite 属性 对敏感操作要求二次确认 4. 弱密码与密码泄露 很多攻击并不依赖技术漏洞，而是依赖人类弱点。 弱密码（如 123456、password）被暴力破解是十分常见的。\n另一个问题是服务器端存储明文密码，一旦数据库泄露，就是灾难。\n防御方式：\n要求使用复杂密码 存储密码时使用强哈希算法（bcrypt / argon2） 支持双因素认证（2FA） 5. 明文传输（HTTP） HTTP 是明文的，任何中间节点都可以看到所有内容，包括账号密码。 在公共 WiFi 下尤为危险。\n防御方式：\n全站使用 HTTPS 不要将敏感数据暴露在 URL 查询参数中 6. 未授权访问（Broken Access Control） 这是后端最容易忽视的问题。 比如：\n/admin/listUsers 如果后台只检查用户是否“已登录”，但不验证用户是否“管理员”，就会造成权限绕过。\n防御方式：\n所有敏感接口都必须进行权限检查 不要依赖前端控制权限 7. 文件上传漏洞 文件上传听起来很常见，但风险也极高。\n例如：\n攻击者上传一张看起来是 .jpg 的文件，但实际上内部包含可执行代码 上传目录允许执行脚本文件 一旦成功，攻击者可以直接控制服务器。\n防御方式：\n校验文件的 MIME 类型而不是文件扩展名 上传后重新命名文件 将文件放在不可执行目录 对图片进行重新编码以确保其内容安全 8. 暴露的管理接口 很多框架在开发模式下会暴露调试接口，例如：\n/debug /swagger-ui /actuator 如果在生产环境中忘记关闭，就会造成极大的安全风险。\n防御方式：\n生产环境关闭不必要的管理端口 必须暴露的端点需要权限认证 不在页面上输出敏感系统信息 9. 依赖与供应链攻击 现代开发高度依赖第三方库。 如果依赖包本身含有恶意代码（或被入侵），攻击者就能“曲线入侵”你的系统。\n典型方式包括：\n伪装成相似名字的库 在常见库中加入恶意更新 泄露依赖版本导致漏洞被利用 防御方式：\n定期更新和扫描依赖 锁定依赖版本 只使用可信来源的包 10. 日志与调试信息泄露 日志里常出现敏感数据，例如：\nLogin failed: username=alice, password=secret 一旦日志泄露，相当于主动暴露系统内部状态。\n数据泄露事件中，日志泄漏占比相当高。\n防御方式：\n不记录密码、Token、身份证号等敏感数据 控制日志访问权限 在生产环境关闭过度详细的调试信息（如 stack trace） 总结 安全风险的根源往往不是复杂的攻击，而是我们理所当然的假设。\n一个稳健的系统应该具备：\n不信任任何输入 不依赖客户端安全 不暴露内部实现 对敏感数据尽量减少存储 始终假设攻击者存在 掌握这十大安全风险，可以帮助程序员在设计和构建系统时提前预判问题，减少代价高昂的“线上事故”。\n","date":"2025-06-07T14:59:56+08:00","permalink":"https://yearsuns-github-io.vercel.app/p/top-ten-cybersecurity-risks-every-programmer-must-know/","title":"程序员必须知道的十大网络安全风险"},{"content":" 本文面向使用 Ubuntu Server 24 LTS 进行生产环境部署的团队。 目标是帮助你建立系统化、可执行、可审计的服务器安全策略，让入侵更难发生，让故障更容易排查。\n目录 安全原则概述 基础系统安全 SSH 访问与账户安全 网络访问控制（UFW / Fail2ban） 服务与进程安全 跳板机：运维安全的统一入口 应用与数据安全 日志监控与告警 备份与恢复策略 一页安全核对清单（Checklist） 一、安全原则概述 在开始具体操作前，需要先理解安全的三大原则：\n1. 最小权限原则（Least Privilege） 用户与服务只应该拥有完成任务所需的最小权限。\n2. 减少暴露面（Reduce Attack Surface） 关闭不需要的端口、服务和账户。攻击面越小，风险越小。\n3. 全量审计（Traceability） 操作可回溯、日志可查询，才能在事故时快速定位问题。\n服务器安全不是堆命令，而是一个“最小暴露 + 可控访问 + 可追踪行为”的体系。\n二、基础系统安全 1. 保持系统更新（最高优先级） sudo apt update sudo apt upgrade -y 开启自动安全更新：\nsudo apt install unattended-upgrades sudo dpkg-reconfigure unattended-upgrades 2. 禁用不必要的软件与服务 列出已启用服务：\nsystemctl list-unit-files --type=service 关闭：\nsudo systemctl disable --now servicename 3. 使用 LTS 版本与官方软件仓库 避免第三方未知源：\nsudo add-apt-repository --remove ppa:xxx 第三方源越多，安全风险越大。\n三、SSH 访问与账户安全 1. 禁止 root 直接登录 编辑 SSH 配置：\nsudo nano /etc/ssh/sshd_config 设置：\nPermitRootLogin no 2. 禁用密码登录（强烈建议） SSH 改为密钥认证：\nPasswordAuthentication no 生成密钥：\nssh-keygen -t ed25519 上传密钥：\nssh-copy-id user@server 3. 管控服务器用户 查看所有用户：\ncut -d: -f1 /etc/passwd 删除不再需要的用户：\nsudo deluser username 4. sudo 权限最小化 创建普通用户，再赋予 sudo 权限：\nsudo usermod -aG sudo devuser 与此同时避免：\nsudo su - 这样的 root 长时间工作模式。\n5. 使用 SSH 登录速率限制 在 SSH 配置中加入：\nMaxAuthTries 3 MaxSessions 5 四、网络访问控制（UFW / Fail2ban） 1. 启用 UFW 防火墙 启用防火墙：\nsudo ufw enable 仅开放必要端口：\nsudo ufw allow 22/tcp sudo ufw allow 80/tcp sudo ufw allow 443/tcp 默认拒绝其他端口：\nsudo ufw default deny 查看状态：\nsudo ufw status numbered 2. 防暴力破解：Fail2ban 安装：\nsudo apt install fail2ban 启用：\nsudo systemctl enable --now fail2ban 查看封禁状态：\nsudo fail2ban-client status Fail2ban 能阻止大量扫描和破解行为，是 SSH 最重要的保护措施之一。\n五、服务与进程安全 1. 不要让服务以 root 运行 为服务创建独立用户：\nsudo adduser --system --no-create-home webuser 在 systemd 中配置：\nUser=webuser Group=webuser 2. 限制服务权限（文件与目录） 例如 Web 目录：\nchmod -R 750 /var/www/app chown -R www-data:www-data /var/www/app 3. 使用 AppArmor 控制服务行为 查看 AppArmor 状态：\nsudo aa-status 启用规则：\nsudo aa-enforce /etc/apparmor.d/usr.sbin.nginx 4. 控制开放端口 查看端口监听：\nsudo ss -tulnp 关闭不必要端口能显著减少攻击面。\n六、跳板机/堡垒机：运维安全的统一入口 跳板机（Bastion Host / Jump Server）是企业安全体系中的标配。\n它的作用包括：\n1. 统一入口：减少暴露面 所有服务器 SSH 都关闭公网，只暴露跳板机。\n2. 强身份认证 密钥登录 MFA LDAP/AD 企业认证 3. 权限精细化控制 谁能访问哪台机器，谁能执行哪些命令一目了然。\n4. 全量审计与录像 每条命令 敏感操作告警 可回放运维全过程 5. 推荐方案 开源：Jumpserver（功能最完善的开源堡垒机） 云厂商自带堡垒机（省心，安全合规） 跳板机不是可选项，而是：\n安全访问控制体系的核心组件，应在中大型团队中强制使用。\n七、应用与数据安全 1. 数据库不要暴露公网端口 例如 MySQL 只监听本地：\nbind-address = 127.0.0.1 2. 使用 HTTPS（Let’s Encrypt） 自动颁发证书：\nsudo apt install certbot python3-certbot-nginx sudo certbot --nginx 3. 严格控制配置与密钥 密钥文件设置权限：\nchmod 600 id_rsa 私密配置（如 .env）不应向其他用户开放。\n4. 版本控制不要上传敏感文件 Git 忽略：\n.env *.pem *.key 八、日志监控与告警 1. 查看系统日志（systemd） journalctl -xe 2. 服务级日志 journalctl -u nginx 3. 登录行为审计 last lastb 4. 建立实时告警系统 选择其一：\nNetdata Prometheus + Grafana Zabbix 云监控告警 监控指标：\nCPU 异常升高 磁盘将满 SSH 登录异常 服务 down 后自动告警 九、备份与恢复策略 备份是安全的最后一道防线。\n1. 采用 3-2-1 原则 3 份数据 2 种不同介质 1 份异地备份 2. 常用备份方案 rsync（简单高效） BorgBackup / Restic（加密备份） 云盘快照（极高恢复速度） 3. 定期演练恢复 没有演练的备份 = 假备份。\n十、一页安全核对清单（Checklist） 你可以用它快速检查服务器是否合规。\n✔ 系统已更新 ✔ 禁用 root 登录 ✔ SSH 密钥登录 + MFA ✔ UFW 防火墙启用 ✔ Fail2ban 启动 ✔ 不必要服务已关闭 ✔ 服务不以 root 运行 ✔ 数据库未暴露公网 ✔ 日志可追踪 ✔ 使用跳板机集中管理运维 ✔ 有自动备份与恢复演练 ","date":"2025-05-18T14:59:56+08:00","permalink":"https://yearsuns-github-io.vercel.app/p/ubuntu-server-operations-security-best-practices/","title":"Ubuntu服务器运维安全最佳实践"},{"content":"一、为什么要选择 Ubuntu Server？ CentOS 8 停止维护后，许多团队逐渐转向 Ubuntu。原因很简单：\n更新稳定 + 周期明确：Ubuntu LTS（长期支持版）提供 5 年官方支持。 软件生态更丰富：apt 软件仓库巨大，新软件更新快。 社区文档完善：遇到问题基本都能找到解决方案。 云原生友好：Docker、Kubernetes 等官方支持都以 Ubuntu 为优先平台。 如果你希望服务器省心、上手快，Ubuntu 是最佳选择之一。\n二、Ubuntu 的基本原理：它是如何工作的？ 理解 Linux 的运行原理，有助于你更好地排查问题。\n1. Linux = 内核 + 用户空间 一个 Linux 系统本质上由两部分组成：\n内核（Kernel）：直接与硬件交互，负责调度、内存、文件系统、网络等。 用户空间（User Space）：各种应用程序、Shell、守护进程等。 Ubuntu Server 提供用户空间环境，让你用命令行操作内核能力。\n2. 文件系统结构（FHS） Linux 文件系统采用“树状结构”，所有内容都从根目录 / 开始。\n常见目录解释：\n目录 用途 /etc 系统配置文件 /var 日志、缓存、可变数据 /usr 系统级程序与库 /home 普通用户的家目录 /root root 用户家目录 /tmp 临时文件 /opt 第三方软件（可选） 把它理解为一棵树，而不是 Windows 的 C: D: 驱动器。\n3. 软件管理：APT Ubuntu 使用 APT（Advanced Package Tool） 管理软件。\n特点：\n自动解决依赖 软件来源于官方仓库 一行命令即可安装/更新 后面会有详细示例。\n4. 服务管理：systemd Ubuntu 24 使用 systemd 作为服务管理系统：\n开机启动 服务管理（start/stop/restart） 日志系统（journalctl） 这类命令你会非常常用。\n三、快速上手：安装后必须做的初始化 假设你已经安装好 Ubuntu Server 24.x，以下步骤是上线前必须做的。\n1. 更新系统 sudo apt update sudo apt upgrade -y 2. 创建新用户并加 sudo 权限 sudo adduser devuser sudo usermod -aG sudo devuser 尽量不要用 root 直接工作。\n3. 配置 SSH（可选：禁止密码登录） 查看 SSH 配置文件：\nsudo nano /etc/ssh/sshd_config 常见设置：\nPasswordAuthentication no PermitRootLogin no 改完后重启 SSH：\nsudo systemctl restart ssh 4. 安装常用工具 sudo apt install -y vim git curl unzip htop net-tools 四、入门必学：Ubuntu 常用命令 以下命令覆盖日常开发者 90% 的工作量。\n1. 文件与目录 查看目录 ls ls -l # 显示详细信息 ls -a # 显示隐藏文件 切换目录 cd /etc cd ~ # 回到自己的 home 目录 cd - # 回到上一次目录 创建 / 删除 mkdir logs rm -rf logs 2. 文件处理 查看文件内容 cat file.txt less file.txt # 支持翻页 head -n 20 file.txt tail -f /var/log/syslog # 实时查看日志 3. 编辑文件（nano/vim） nano 简单直接：\nnano config.ini vim 强大但需要学习：\nvim config.ini 4. 软件安装与管理（APT） 安装软件 sudo apt install nginx 删除软件 sudo apt remove nginx 搜索软件包 apt search redis 更新整个系统 sudo apt update \u0026amp;\u0026amp; sudo apt upgrade 5. 服务管理（systemctl） 启动服务：\nsudo systemctl start nginx 重启：\nsudo systemctl restart nginx 查看状态：\nsudo systemctl status nginx 设置开机启动：\nsudo systemctl enable nginx 6. 网络调试 查看 IP：\nip a Ping：\nping baidu.com 端口监听：\nsudo ss -tulnp 7. 用户与权限 当前用户：\nwhoami 文件权限：\nchmod 755 app.sh chown ubuntu:ubuntu app.sh 五、理解 Linux 的权限模型（非常重要） Linux 权限由三部分组成：\n-rwxr-xr-- 含义如下：\n区域 说明 rwx 文件所有者 的权限 r-x 文件所属组 的权限 r\u0026ndash; 其他用户 的权限 字符含义：\nr = read（读） w = write（写） x = execute（执行） 数字对应：\n7 = rwx 6 = rw- 5 = r-x 4 = r\u0026ndash; 所以 755 = rwxr-xr-x。\n理解这个模型是管理服务器的关键。\n六、系统监控与排查 1. 查看资源占用 CPU 和内存：\ntop htop 磁盘：\ndf -h 目录占用：\ndu -sh * 2. 查看系统日志 systemd 日志：\njournalctl -xe 查看某个服务日志：\njournalctl -u nginx ","date":"2025-04-25T14:59:56+08:00","permalink":"https://yearsuns-github-io.vercel.app/p/ubuntu-24-server-beginners-guide/","title":"Ubuntu24服务器入门教程"},{"content":"一、配置相关 # 设置用户名和邮箱（全局） git config --global user.name \u0026#34;Your Name\u0026#34; git config --global user.email \u0026#34;you@example.com\u0026#34; # 查看所有配置 git config --list 二、创建与获取仓库 # 在当前目录初始化仓库 git init # 从远程仓库克隆 git clone https://github.com/user/repo.git git clone git@github.com:user/repo.git 三、查看状态与比较差异 # 查看当前状态（修改了什么、哪些在暂存区） git status # 查看工作区与暂存区的差异 git diff # 查看暂存区与最近一次提交的差异 git diff --cached 四、添加与提交 # 添加单个文件到暂存区 git add file.txt # 添加当前目录所有修改 git add . # 提交（-m 后面是提交说明） git commit -m \u0026#34;feat: add new feature\u0026#34; # 修改最近一次提交信息（未推送时常用） git commit --amend 五、查看提交历史 # 查看提交历史（详细） git log # 单行显示历史（更紧凑） git log --oneline # 查看某个文件的修改历史 git log file.txt 六、分支操作 # 查看本地分支 git branch # 创建新分支（基于当前分支） git branch dev # 切换到分支 git checkout dev # 创建并切换到新分支（常用） git checkout -b dev # 删除本地分支 git branch -d dev # 安全删除（有未合并会失败） git branch -D dev # 强制删除 新版 Git 也可以用 git switch 更直观：\ngit switch dev # 切换分支 git switch -c dev # 创建并切换新分支 七、合并与冲突 # 切换到目标分支（要被合并到的分支） git checkout main # 把 dev 分支合并到当前分支 git merge dev 发生冲突时：\n编辑冲突文件，手动保留正确内容 然后： git add . git commit # 完成合并 八、远程仓库操作 # 查看当前远程仓库 git remote -v # 添加远程仓库 git remote add origin git@github.com:user/repo.git # 修改远程地址 git remote set-url origin git@github.com:user/new-repo.git 九、推送与拉取 # 首次推送当前分支到远程，并设置跟踪 git push -u origin main # 推送当前分支 git push # 从远程拉取并合并 git pull # 从远程获取最新记录（不自动合并） git fetch 十、暂存现场（stash） # 暂存当前未提交的修改 git stash # 带说明的 stash git stash save \u0026#34;WIP: something\u0026#34; # 查看所有 stash git stash list # 应用最近一次 stash（保留记录） git stash apply # 应用并删除最近一次 stash git stash pop 十一、撤销与回退 # 丢弃工作区对某个文件的修改（回到最近一次提交） git checkout -- file.txt # 撤回暂存区中的文件到工作区 git reset file.txt # 回退到某次提交（保留修改到暂存区） git reset --soft \u0026lt;commit_id\u0026gt; # 回退到某次提交（修改回到工作区） git reset --mixed \u0026lt;commit_id\u0026gt; # 默认 # 回退到某次提交（彻底丢弃之后的修改） git reset --hard \u0026lt;commit_id\u0026gt; \u0026lt;commit_id\u0026gt; 可以通过 git log 或 git log --oneline 查看。\n十二、撤销某个已提交的改动（revert） # 生成一个新的提交，用来“反做”指定提交的修改 git revert \u0026lt;commit_id\u0026gt; 适合已经推到远程、不能直接改历史的情况。\n十三、标签（Tag） # 打轻量标签 git tag v1.0.0 # 打附注标签（带说明） git tag -a v1.0.0 -m \u0026#34;Release version 1.0.0\u0026#34; # 查看所有标签 git tag # 推送某个标签 git push origin v1.0.0 # 推送所有标签 git push origin --tags 十四、挑选提交（cherry-pick） # 把某个提交“复制”到当前分支 git cherry-pick \u0026lt;commit_id\u0026gt; 适合从其他分支“捞”出某个修复或功能。\n十五、安全网：reflog # 查看所有 HEAD 变动记录（包括 reset 等操作） git reflog 当你不小心 reset \u0026ndash;hard、删错东西时，可以通过 reflog 找回之前的提交 ID，再 reset 回去。\n十六、超精简日常命令清单 # 状态 \u0026amp; 历史 git status git log --oneline # 常规提交流程 git add . git commit -m \u0026#34;message\u0026#34; git push # 更新代码 git pull # 分支 git branch git checkout -b feature/login git checkout main git merge feature/login # 撤销 git checkout -- file.txt git reset --hard HEAD ","date":"2025-04-14T11:59:56+08:00","permalink":"https://yearsuns-github-io.vercel.app/p/comprehensive-git-command-reference/","title":"Git 常用命令合集"},{"content":"软件开发中，版本控制是最重要的基础工具之一。它能帮你记录代码修改历史、团队协作，以及在出现错误时快速回退。 对初学者来说，Git 有时显得命令多、名词多，但本质并不复杂。本教程的目标是：用最小的概念，建立一套可立即上手的 Git 心智模型。\n一、Git 是什么？一句话足够 Git 是一个用于记录项目每次变化的工具，让你可以随时查看历史、切换版本、协同工作。\n它不像网盘那样保存一堆文件，而是保存“每次修改的快照”，这就是它高效的原因。\n如果你理解不了所有命令，不要紧：只要理解 Git 在管理一条时间线，你就是在使用它的核心能力。\n二、安装与初始配置：上手的第一步 安装完成后，你必须告诉 Git 你是谁：\ngit config --global user.name \u0026#34;你的名字\u0026#34; git config --global user.email \u0026#34;你的邮箱\u0026#34; 这些信息会写入每一次提交记录中，是协作的基础。\n三、你的第一个仓库：让 Git 开始“观察”你的项目 进入你的项目目录：\ngit init 这个命令会创建一个隐藏目录 .git，里面保存了所有版本信息。从此以后，Git 就开始“跟踪”这个项目。\n四、Git 的核心思想：三大区域模型 理解这张图，你就理解了 Git 的 80%：\n工作区（Working Directory） ↓ git add 暂存区（Stage / Index） ↓ git commit 本地仓库（Repository） 解释：\n工作区：你正在编辑的文件。 暂存区：告诉 Git“这些是我准备提交的文件”。 仓库区：文件永久记录到版本历史。 一个提交（commit）就是从暂存区保存到仓库区的快照。\n五、最常用的 Git 命令（够用版） 1. 查看当前状态 git status 新手要常用，它会告诉你哪些文件改变了、哪些被跟踪、哪些准备提交。\n2. 把文件加入到暂存区 git add 文件名 git add . # 全部文件 可以把它理解为：“把这些修改放进购物车”。\n3. 创建一次提交 git commit -m \u0026#34;描述此次修改的内容\u0026#34; 提交就是保存历史快照，是 Git 的核心价值。 建议写清楚本次做了什么，而不是“修改了一些东西”。\n4. 查看提交历史 git log 如果你看到很多提交，这是正常的：版本控制就是不断记录这些变化。\n六、如何撤销？不要怕 Git，Git 最擅长救你 1. 撤回工作区修改 git checkout -- 文件名 让文件回到最近一次提交的状态。\n2. 撤回暂存区变化 git reset 文件名 把文件从暂存区拿回工作区。\n3. 撤销提交（但保留修改） git reset --soft HEAD~1 这相当于“删掉最新的提交，但把代码留着”。\n七、分支：Git 最有价值的能力 在 Git 中，分支很轻量，创建和切换分支几乎没有成本。\n创建分支：\ngit branch dev 切换分支：\ngit checkout dev “主分支负责发布，开发分支负责开发”——这是最常见的工作方式。\n分支为什么重要？ 因为你可以：\n在新分支上尝试新功能 不破坏主分支 随时删掉失败的尝试 这让 Git 成为一个鼓励实验的工具。\n八、合并：把你的成果合回主线 完成开发后，你需要把分支的工作合并到主分支：\ngit checkout main git merge dev 如果没有冲突，它会自动完成。\n九、解决冲突：协作开发不可避免的一刻 两个开发者修改同一行代码，就会产生冲突。 Git 会在文件里标记冲突内容：\n\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; HEAD 你的修改 ======= 同事的修改 \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; dev 你只需手动编辑成想要的结果，再提交即可。\n冲突不是错误，而是协作的自然产物。\n十、远程仓库：开始真正的协作 把本地仓库和 GitHub（或 GitLab）绑定：\ngit remote add origin 仓库地址 推送：\ngit push -u origin main 拉取别人提交：\ngit pull 这是团队协作最核心的两步：“推给别人”和“拉取别人”。\n十一、初学者最常见的三个疑问 1. 为什么我 push 不上去？ 答案通常是：远程库有新的提交，你本地没有。 解决办法：\ngit pull --rebase git push 2. 我改乱了能回去吗？ 几乎都能。Git 就是为了防止“改乱了”而存在的。\n3. 我需要记住所有命令吗？ 不需要。 最核心的就这些：\ngit add git commit git status git log git checkout git branch git merge git push git pull 熟练它们，你已经是合格的 Git 用户。\n十二、总结：用最小的知识体系开始真正使用 Git 你可以把 Git 想成一个“会计本”，它记录了代码的变化账单：\ninit：开账本 add：把修改列入账单 commit：保存账单 branch：给同一项目开多个账本副本 merge：把账单合在一起 push/pull：账本在多人之间同步 理解这套模型后，命令不过是操作方式的不同表达。\n","date":"2025-03-30T11:59:56+08:00","permalink":"https://yearsuns-github-io.vercel.app/p/a-beginner-friendly-git-guide-clear-concepts-and-practical-steps-for-new-developers/","title":"Git 入门教程：从原理到实践的最小知识体系"},{"content":"如今的社会已不再是过去那种信息闭塞的时代了，当朋友需要帮助时，不论你是否出手相助，问题最终都会得到解决，所以如果条件允许，何不主动请缨，提供自身价值呢？\n1. 提升信任关系，积累社会资源 人际关系和社会资源的积累，在很大程度上依赖于互信和互助。利他之心能够在无形中提升彼此间的信任感，使得人与人之间的关系更加稳固。利他行为让你在人际互动中表现出关心和善意，进而增进他人的好感与信任。随着这种信任的加深，自己也能够积累更多的社会资源，无论是信息、支持，还是实际的帮助。\n例如，在工作场所，表现出乐于助人的精神可以帮助你建立良好的同事关系，这不仅能提高团队的合作效率，还能为你带来更多的职场机会。在日常生活中，帮助他人不仅能赢得朋友的信任，还可能在关键时刻得到他人的支持和援助。\n通过积累这种信任与资源，利他行为为我们带来了长久的社会资本，也为未来的成功奠定了基础。\n想想你是如何看待身边自私自利的人的，当他有求于你时，你是否会全力相助？\n俗话说，物以类聚，人以群分。只有自己以身作则，才能在身边聚集更多拥有相同价值观的朋友！\n2. 提升自我价值，促进个人成长 利他行为不仅是对他人的付出，它也是对自己的一种提升。每一次无私的付出，都会让你感受到自我价值的实现。这种感觉的积累，能帮助你建立更强的自信心和成就感，从而提升自我认同感。当你意识到自己不仅仅是为了自己的利益而生活，而是能够为他人带来积极影响时，往往会产生深刻的满足感。\n同时，帮助他人也能促进个人成长。例如，费曼学习法可以帮助我们理解这一点。费曼学习法是一种通过教别人来加深自己理解的技巧。具体来说，费曼学习法有四个步骤：首先，你需要了解一个概念；然后，你将其简化并用自己的话解释；接着，找出自己理解中的漏洞并进行补充；最后，通过不断的复述和改进，巩固对该知识的掌握。\n在利他行为中，这个过程类似于你通过帮助他人，自己获得了更深的理解和成长。例如，当你帮助别人理解一个复杂的概念时，你必须将其转化成易于理解的语言，这需要你清晰地整理自己的思维并深入掌握这个概念。这个过程中，你不仅仅是在帮助别人理解知识，也是在加深自己对知识的理解。\n举个例子，如果你帮助一位朋友学习某项技能，比如编程或外语，你可能会发现自己在解释时，原本理解不深的部分变得更加清晰。这种通过教导和传授知识的过程，能够极大地促进个人的认知和技能发展。通过教会别人，你也在教会自己，并且在这个过程中增强了自己的能力和自信心。\n此外，费曼学习法的反复“讲解”过程中，你会不断发现自己的盲点，迫使自己去学习更多、更深入的内容，这种自我提升也是利他行为中不可忽视的一部分。\n通过这种方式，利他行为成为了个人成长的一种有效途径，让我们在帮助他人时，也能够促进自我价值的实现和不断进步。\n3. 提升幸福指数，预防心理疾病 心理学研究表明，利他行为能够有效提升幸福感和生活满意度。当我们帮助他人时，大脑会释放出多巴胺和催产素等“幸福荷尔蒙”，这些化学物质不仅能够改善情绪，还能促进身心健康。定期参与有意义的利他行为，能让人感到生活充实和有意义，从而增强幸福感。\n相反，长期的自我中心和孤立行为可能导致孤独感和抑郁情绪。利他行为通过促进与他人的互动和联系，帮助人们建立起社会支持系统，减少孤独感，降低心理问题的风险。尤其在现代社会中，越来越多人面临精神压力和情感困扰，利他行为的实践能够为心理健康提供有力的保护网。\n通过帮助他人，我们不仅能增强自我感知的幸福感，还能够在生活中找到更多的正能量，预防心理疾病的发生。\n","date":"2025-02-22T11:23:56+08:00","permalink":"https://yearsuns-github-io.vercel.app/p/why-we-should-embrace-altruism/","title":"为什么要有利他之心"},{"content":"过去30年，普通人逆袭的机会层出不穷。从房地产的暴涨，到网游、互联网、电商、自媒体、再到近两年的区块链，经济的剧变让许多人在短时间内积累了巨额财富。本文将带你回顾这几大行业的崛起历程，并探讨普通人如何抓住下一次的逆袭机会。\n一、曾经的逆袭神话 1. 房地产：风口上的飞猪 如果你在2000年代初期买下了一套北京或上海的房子，那么你现在可能已经可以安享晚年了。\n2003年到2013年，房地产市场是无数普通人财富飞跃的舞台。那时，城市化进程加速，土地开发和基础设施建设如火如荼。房地产的暴涨让一大批人迅速从平凡走向财富自由。购房者通过几年时间，房产增值几倍，成为“房产神话”的亲历者。\n在那个阶段，房地产不仅是生活必需品，也是资本增值的工具。尤其是2008年以后，随着政府政策的不断调控，房地产市场的泡沫被逐步挤掉，但仍然维持在一个较高的价格水平。很多普通人通过贷款买房，十几年后，房子价值翻了几倍。而且，不仅仅是在一线城市，二线、三线城市也在房地产发展中，出现了类似的机会。\n2. 网游：从玩家到富翁 曾经无数少年沉迷网游，你是否也是其中一员？甚至由此诞生了“雷电法王”之名的杨永信。\n早期的网游市场并不成熟，但随着《传奇》《魔兽世界》《英雄联盟》等经典游戏的爆红，游戏产业的规模暴涨。从2000年代初期，游戏开发商、运营商、直播平台，乃至游戏主播，都迎来了自己的“风口”。那些站在风口浪尖上的人，借助着庞大的用户群体、丰富的内容创作和玩家社交，在网游这个赛道上快速累积了财富。\n随着网游行业的快速发展，网游不再只是娱乐工具，它已经成为了一种线上社交、数字经济的核心部分。除了游戏的直接收入（例如充值、道具买卖、月卡等），很多人还通过游戏视频、直播、代练等方式获得了不菲的收入，网游行业为普通人提供了多样的逆袭机会。\n3. 互联网：流量为王的时代 你还记得猫扑带火了哪些草根吗？你还记得淘宝刚刚成立时的样子吗？你还记得身边有哪些程序员吗？\n互联网刚刚在中国普及，门户网站如网易、搜狐、新浪等处于快速发展阶段，互联网彻底改变了人们的生活方式，也为很多普通人提供了逆袭的机会。\n电商平台的崛起、社交网络的普及和搜索引擎的技术革新，使得个人创业者能够低成本、快速地触及到海量用户。无数“屌丝”创业者通过互联网实现了从草根到巨富的逆袭。\n4. 电商：从小店到帝国 电商行业自2005年淘宝的崛起，打破了传统商业模式，为无数普通人提供了低门槛、高回报的创业机会。电商的快速发展，使得许多人从一开始的单打独斗，到逐渐积累品牌、经营帝国。随着消费升级和物流体系的完善，电商市场迅速壮大。\n5. 自媒体：从个人到品牌 自媒体的崛起，也是过去30年普通人逆袭的重要途径之一。几年前，谁能想到一个普通人只需要一台手机和一些创意，就能够通过短视频、博客、社交平台等途径，获得巨额收入？\n“网红”从最初的娱乐圈到如今几乎渗透到各行各业，电商带货、广告代言、品牌合作……无论是抖音、快手，还是微博、微信公众号，只要你能吸引足够的关注，流量变现就不再是难题。\n自媒体作为信息时代的产物，为个人创作者提供了一个低成本、高回报的创业平台。尤其是在短视频和直播兴起后，内容创作者通过社交平台迅速积累大量粉丝，逐步将自己的兴趣和创意转化为商业收入，甚至成为行业顶流。\n6. 区块链：从一张白纸到千亿市值 近年来，区块链技术的崛起，再次让普通人看到了逆袭的机会。区块链是加密货币和去中心化技术的基础，其背后的潜力巨大。比特币和以太坊的早期投资者，很多人已经实现了财富自由。\n区块链不仅仅是投资市场的机会，还为金融、物流、艺术等多个行业带来了创新。NFT、去中心化金融（DeFi）等新的商业模式和技术，都是普通人抓住机会逆袭的可能性。\n区块链技术，特别是比特币的暴涨，使得一大批投资者在短短几年内迅速积累了财富。随着ICO（首次代币发行）和数字货币的普及，区块链成为了新一轮投资热潮的代表。\n二、为什么这些行业能兴起？ 从房地产到网游、互联网、电商、自媒体，再到区块链，各个行业的兴起，均有共同的规律可循。总结下来，以下几点尤为关键：\n市场需求驱动：无论是房地产的城市化需求，还是互联网带来的在线消费习惯，甚至是自媒体的个性化内容消费，市场需求的激增是各行业爆发的根本原因。\n技术进步引领变革：从互联网的普及，到电商的购物体验优化，再到区块链技术的创新，技术始终是行业突破的推动力。每一次技术的革新，都会带来新的商业机会。\n资本加持催生爆发：资本的涌入推动了各行业的爆发，无论是房地产的投资热潮，还是电商平台的资金扶持，资本不仅让行业扩张，还加剧了竞争格局。在许多情况下，资本的加持帮助了行业快速扩张，普通人也因此受益。\n三、AI是下一个逆袭机会吗？ 如今，AI行业正在快速崛起，成为下一个可能的财富增长点。GPT、DeepSeek等技术的问世，标志着人工智能逐渐进入了一个新的阶段。AI不仅仅改变了行业的运作方式，还直接影响到普通人的工作和生活。从自然语言生成到计算机视觉，从自动驾驶到金融智能预测，AI的应用场景广泛，潜力巨大。\nAI与过去的行业相比，有几个重要特点：\n广泛的应用场景：AI不仅适用于传统行业，还能创造出全新的职业和行业。无论是教育、医疗，还是金融、娱乐，几乎所有领域都能受益于AI的推动。\n技术进步不断：AI的技术进步速度远超其他行业，深度学习、机器学习、自然语言处理等领域的突破，将为更多普通人提供进入高科技行业的机会。\n资本推动创新：和过去的行业一样，AI背后有着巨额的资本投入。全球范围内的大公司和投资机构都在抢占AI技术的制高点，资金的推动加速了AI技术的研发和商业化。\n四、普通人如何抓住AI逆袭机会？ 学习AI技能\n掌握AI相关技能，如机器学习、数据分析、自然语言处理等，能够帮助普通人在未来的职场中占得先机。即使是非技术背景的人，也可以通过学习相关工具，如GPT、DeepSeek等自然语言生成技术，提升自己的工作效率。\n利用AI工具提升效率\n许多AI工具已广泛应用于各个行业，例如GPT、DeepSeek、即梦、可灵、豆包等。普通人可以通过掌握这些工具，提升工作效率，甚至开创自己的副业。\n探索AI创业机会\nAI行业的发展不仅提供了就业机会，还提供了创业机会。AI写作、AI绘画、AI视频、AI数字人直播，AI应用已经遍地生花。无论是通过AI提供智能服务，还是利用AI优化现有的业务流程，普通人都有可能在这个行业找到属于自己的位置。\n五、AI能否成就下一个财富神话？ 回顾过去30年，行业的崛起往往与技术进步、市场需求和资本推动密切相关。今天，AI行业无疑是下一个值得关注的财富增长点。对于普通人来说，AI行业不仅提供了新的就业机会，还提供了广阔的创业空间。然而，是否能够像房地产、电商等行业一样创造出巨大的财富奇迹，仍然需要时间来验证。\n然而，AI的潜力不可忽视。通过主动学习、提升技能并抓住行业的快速发展，普通人仍然有机会在这个充满创新的时代，找到属于自己的“逆袭”机会。所以，如果你有一颗敏锐的商业嗅觉和愿意学习的心态，AI或许会是你下一个财富的“跳板”。\n","date":"2025-02-20T21:13:56+08:00","permalink":"https://yearsuns-github-io.vercel.app/p/the-opportunity-for-ordinary-people-to-strike-it-rich-in-the-past-30-years/","title":"过去30年普通人逆袭的机会，你错过了哪些？"},{"content":"你是不是总有这样的时候：明明拥有一切，却还是心神不宁；明明在忙碌中，却感到深深的焦虑和压力；明明生活看起来挺好，却怎么也静不下心来？\n究其根源，我们大多数人焦虑的原因，往往与内心的某些欲望密切相关。我们都在追求“更好”的生活，然而，这些欲望有时候反而成了我们焦虑的来源。\n今天，我们来聊聊，为什么这些欲望让你焦虑不已，如何通过心理学的方式解决这一难题。\n为什么我们总是焦虑？ 首先，让我们来看看焦虑的本质。心理学上，焦虑被定义为一种对未来的担忧与不确定感。这种不安，往往源自对某种“失控”的恐惧。当我们无法掌控生活中的某些方面时，我们就会产生焦虑，身体的压力反应会迅速启动，导致我们情绪波动大，思绪混乱。\n这些焦虑并非无缘无故产生。每当你有了“必须得到”的需求，而这些需求又无法在短时间内满足时，焦虑便会悄然而至。欲望越强烈，焦虑就越容易找到你。\n接下来，我们逐一分析，这五种欲望是如何成为焦虑的源头。\n五种欲望让你焦虑的心理学分析 1. 掌控欲：让你累到崩溃的“操控魔力” “时间管理大师”听起来很酷对吧？但是，你有没有想过，每当你试图掌控一切时，自己会变成什么样子？\n“我要掌控时间”、“我必须控制每个细节”、“我不想让任何人犯错”——如果你时常对这些想法感到头疼，那你很可能深陷在“掌控欲”的困扰中。\n掌控欲来源于人类对安全感的需求。我们都希望自己能够掌控一切——无论是时间、环境、别人，还是未来的不确定性，尤其是当面临未知或无法预见的情况时，焦虑便随之而来。这种欲望背后隐藏着深深的恐惧，害怕自己失控，害怕未知的风险。\n然而，过度的掌控欲反而让我们变得焦虑，因为世界本身充满了不可预测的变化。我们无法控制每一分每一秒，也不能左右每个人的行为。相反，越是想控制，越是无法得到真正的“掌控”。\n心理学建议：\n顺其自然，学会放手，接受生活中的不确定性。适当的放下控制欲，才能让自己感到真正的自由。试着把重点放在自己能够掌控的事情上，比如自我管理、情绪控制等，而不要过度干涉他人或外部环境的变化。\n2. 完美欲：完美主义的痛与美 你是不是总是给自己和别人设立过高的要求？觉得自己做事不完美，就会自责，甚至害怕别人看到你的一点小瑕疵？\n“我必须完美无缺”、“我不允许自己犯错”、“别人也得是完美的”——完美欲往往让人不断自我苛责，心里总有一个声音在催促你达到不切实际的标准。\n从心理学角度讲，完美主义通常源于对自我价值的不安全感。你觉得只有做得“完美”，才能得到别人的认可，甚至是自己的接纳。结果，你不断追求完美，却忽视了自己的内心需求，也因此无法真正体验到生活的美好，反而把自己逼得焦虑不堪。\n完美主义者往往难以感到满足，反而不断陷入焦虑和自责的怪圈中。因为“完美”是不存在的——即使你做到了一点点进步，也无法从内心获得满足感。\n完美本身就是一种虚幻的追求。人类的非完美性才是我们最真实的一面，而每一个微小的缺陷，都是我们成长的一部分。完美主义让我们失去了享受过程的能力，焦虑感也因此滋生。\n心理学建议：\n完美的定义是什么？或许它根本不存在。学会接受“足够好”，而不是非得完美无缺。“做好自己的最好就好”——从容应对不完美，学会在过程中找到乐趣，接受自己作为一个不完美的人，拥抱自己的缺点。\n3. 认同欲：为他人而活，还是为自己而活？ 你是不是常常过度关注别人对你的评价，甚至会因此改变自己的行为和决策？如果答案是“是”，那么你可能正在经历“认同欲”带来的困扰。\n“别人怎么看我？”“我必须让别人喜欢我”——这种渴望他人认同的心态，使得你不断迎合他人的期待，甚至忽视了自己的真实感受和需求。\n认同欲是人类社交本能的一部分。我们都渴望被他人接受，尤其是在社会化的过程中，我们的行为常常受到他人评价的影响。社会学家曾指出，认同欲深深植根于我们的心理，它关乎自尊心、归属感和存在感。\n然而，过度的认同欲容易让我们迷失自我，失去内心的独立性。当我们总是为了取悦别人而做事时，内心的不安和焦虑也会随之而来。\n心理学中，这种“认同欲”通常与低自尊有关。个体往往在缺乏自我价值感时，将自己的价值寄托在他人评价上。为了获得他人的认可和接纳，我们不断改变自己，甚至丧失了真正的自我。\n而当这种认同欲无法得到满足时，焦虑和不安便随之而来。你时刻在乎别人怎么看自己，却忽视了内心的真正需求。\n心理学建议：\n练习自我接纳，学会不依赖他人评价来定义自己，找到属于自己的独立价值，而不是靠外界的评价来定义自己。尝试设定个人的价值观和生活目标，明确自己真正想要的是什么，并勇敢地去追求。\n4. 物质欲：金钱、权力和名声，永无止境的追求 “我需要更多的钱”、“我必须得到更高的职位”、“我想要更多的社会认可”——物质欲的存在，往往让我们陷入对外部世界的无限追求。\n心理学上，这种欲望常常源于对安全感的渴求——认为只有拥有物质财富和社会地位，才能保证生活的稳定与安心。\n物质的追求本身是无止境的，它并不会带来持久的快乐，反而可能让你丧失了对生活本质的感知。\n物质欲源自我们对安全感和地位的需求。我们认为拥有更多的财富、权力和名声，能够让我们在社会中更有立足之地，减少焦虑。\n然而，研究发现，金钱和权力的追求往往带来更多的焦虑，因为它们并不能真正解决内心的不安，反而让我们更加焦虑不已。\n心理学建议：\n重新审视自己的需求和内心的真正渴望，学会享受过程而非单纯追求结果。尝试从内心获得满足，体验当下的宁静与美好，享受生活中的小确幸。 物质的追求可以让生活更加舒适，但它不应是你生活的唯一目标。试着去关注生活中的精神满足，比如与亲朋好友的关系、个人成长的进步等，找到更深层次的价值感。\n5. 安全欲：渴望稳定，恐惧孤独。 “我不能失业”、“我不能孤单一人”——这种对安全感的强烈需求，常常表现为对未知的恐惧，对独立生活的抗拒。安全欲的心理根源通常是对生活的不确定性产生了极大的焦虑感。\n很多人为了避免孤独和不安，选择了过度依赖他人或寻求外部保障，然而，这样的行为反而让自己处于被动的局面，焦虑和不安会持续存在，因为你始终无法完全掌控自己的生活环境。\n安全欲源于我们对情感和心理的依赖。我们害怕孤独，害怕失去稳定，尤其是在面对社会变化时，内心的不安感会被激发。人类天生就有寻求安全感的需求，但过度的安全欲反而会让我们逃避面对变化，失去面对挑战的勇气。\n心理学建议：\n学会接受不稳定的生活状态，培养应对变化的能力。通过增强自信心、培养应对困难的能力，可以让自己在面对不确定性时更加从容不迫。而且，你会发现，当你开始享受孤独时，它就不再是负担，而是成长的空间。\n如何打破焦虑的循环，走向内心的平静？ 1. 自我觉察\n认识到这些欲望并非自我价值的全部。通过冥想、写日记等方式，深入挖掘自己的真实需求，而非不断迎合外界的期望。\n2. 接纳不完美\n放下完美主义，允许自己和他人有缺陷。焦虑往往源自对“完美”的追求，放下它，才能减轻内心的压力。\n3. 设定健康的目标\n设定合理的目标，逐步实现，不要一味追求外部的认同或物质的积累。每个人都有自己独特的价值，学会根据自身的节奏生活。\n4. 放松和释放压力\n定期进行放松训练，如瑜伽、冥想、深呼吸等，帮助自己平衡身心，释放压力，缓解焦虑。\n5. 增强内在力量\n通过阅读、学习、社交等方式，增强自己的内在力量，培养自信心和应对焦虑的能力，逐步打破焦虑的恶性循环。\n结语 焦虑并非不可避免，只有认识到自己的欲望来源，并通过心理学的方法去调适，我们才能真正拥有内心的平静。生活中没有所谓的“完美”，而是一个不断适应、不停成长的过程。学会释放那些不必要的欲望，你会发现，真正的自由来自内心的平静，而不是外界的认可与控制。\n希望每个人都能学会在欲望中找到平衡，摆脱焦虑，活出真正的自己。\n你是否也曾深受这些欲望困扰？或者你有哪些方法缓解焦虑，欢迎在评论区分享，让我们一起探索更好的自己！\n","date":"2025-02-14T23:13:56+08:00","permalink":"https://yearsuns-github-io.vercel.app/p/5-destructive-desires-that-are-fueling-your-anxiety/","title":"你为什么总是焦虑？这五种欲望让你喘不过气！"},{"content":"如果您正在阅读本文，那么您可能已经尝试过 AI 驱动的开发，并且认为“这会产生比代码更多的错误！”相信我，我有过这种经历。\n经过几个月对 Cursor 的反复试验，我发现秘诀不在于 AI 的能力，而在于我们如何指导它。让我向您展示如何将 Cursor 从有缺陷的代码生成器转变为您最可靠的配对程序员。\n关于人工智能发展的残酷事实 人工智能不是魔法。这就像在你的团队中拥有一个才华横溢但思想死板的初级开发人员。你会在没有任何背景或要求的情况下告诉初级开发人员“为我建立一个用户身份验证系统”吗？可能不会。然而，这正是我们大多数人对人工智能所做的。\n有效人工智能发展的三大支柱 清晰的系统架构：人工智能需要全面了解你的系统 结构化任务管理：将工作分解成可消化的部分 明确的开发规则：用清晰的模式和惯例指导人工智能 让我们深入了解如何在您的工作流程中实现这些功能。\n做好项目准备 首先，让我们创建一个您和AI都能理解的项目结构：\nproject-root/ ├── .cursorrules # AI行为配置 ├── docs/ │ ├── architecture.mermaid # 系统架构图 │ ├── technical.md # 技术文档 │ └── status.md # 进度跟踪 ├── tasks/ │ └── tasks.md # 分解开发任务 └── src/ # 源码 你的人工智能助手的大脑：.cursorrules 这是一个经过实践检验的 .cursorrules 文件，我经过了几个月的开发不断完善：\n项目背景和架构 # Project Context and Architecture SYSTEM _CONTEXT: | 您是正在开发 TypeScript/NestJS 项目的高级开发人员。 启动时需要读取的文件: - docs/architecture.mermaid：系统架构和组件关系 - docs/technical.md：技术规范和模式 - task/tasks.md：当前开发任务和要求 - docs/status.md：项目进度和状态 在进行任何更改之前: 1. 从 docs/architecture.mermaid 解析并理解系统架构 2. 从 task/tasks.md 检查当前任务上下文 3. 在 docs/status.md 中更新进度 4. 遵循 docs/technical.md 中的技术规范 # 文件管理规则 ON_ FILE _CHANGE: | 任何代码更改后所需的操作： 1. 阅读 docs/architecture.mermaid 以验证架构合规性 2. 更新 docs/status.md： - 当前进度 - 遇到的任何新问题 - 已完成的项目 3. 根据 docs/technical.md 规范验证更改 4. 根据 task/tasks.md 验证任务进度 # 代码样式和模式 TYPESCRIPT_ GUIDELINES: | - 使用严格类型，避免使用“any” - 遵循 SOLID 原则 - 为所有公共方法编写单元测试 - 使用 JSDoc 记录 # Architecture Understanding READ_ARCHITECTURE: | 文件: docs/architecture.mermaid 所需解析: 1. 加载并解析完整的 Mermaid 图 2. 提取并理解： - 模块边界和关系 - 数据流模式 - 系统接口 - 组件依赖关系 3. 验证任何针对架构约束的更改 4. 确保新代码保持定义的关注点分离 错误处理: 1. 如果找不到文件：停止并通知用户 2. 如果图解析失败：请求澄清 3. 如果检测到架构违规：警告用户 # 任务管理 TASK_ WORKFLOW: | 所需文件: - task/tasks.md：任务定义来源 - docs/status.md：进度跟踪 - docs/technical.md：实施指南 工作流程步骤: 1.阅读 task/tasks.md： - 解析当前任务要求 - 提取验收标准 - 识别依赖关系 2.对照 docs/architecture.mermaid 进行验证： - 确认架构一致性 - 检查组件交互 3.更新 docs/status.md： - 将任务标记为正在进行中 - 跟踪子任务的完成情况 - 记录任何阻碍因素 4.按照 TDD 实施： - 首先创建测试文件 - 实施以通过测试 - 测试完成后更新状态 # 错误预防 VALIDATION_RULES: | 1. 验证类型一致性 2. 检查潜在的空值/未定义 3. 对照业务规则进行验证 4. 确保错误处理 建筑蓝图：architecture.mermaid 让我们创建一个AI能够理解的清晰的系统架构图：\ngraph TD A[API Gateway] --\u0026gt; B[Auth Module] A --\u0026gt; C[User Module] A --\u0026gt; D[Product Module] CopyB --\u0026gt; E[(Auth DB)] C --\u0026gt; F[(User DB)] D --\u0026gt; G[(Product DB)] H[Event Bus] --\u0026gt; B H --\u0026gt; C H --\u0026gt; D style A fill:#f9f,stroke:#333,stroke-width:4px style B fill:#bbf,stroke:#333,stroke-width:2px style C fill:#bbf,stroke:#333,stroke-width:2px style D fill:#bbf,stroke:#333,stroke-width:2px 上面的代码如下所示 高级技术架构：technical.md 以下是一个示例技术架构文档，可帮助您从高层次了解该应用程序\n## Overview This document outlines the technical architecture for an AI-based IDE built using NestJS, TypeORM, and TypeScript. The system follows a modular microservices architecture with event-driven communication patterns. ## Technology Stack - **Backend Framework**: NestJS - **Database ORM**: TypeORM - **Language**: TypeScript - **Event Bus**: RabbitMQ - **Database**: PostgreSQL - **Authentication**: JWT + OAuth2 ## Core Modules ### 1. API Gateway Module ```typescript // src/gateway/gateway.module.ts @Module({ imports: [ ClientsModule.register([ { name: \u0026#34;AUTH_SERVICE\u0026#34;, transport: Transport.RMQ, options: { urls: [\u0026#34;amqp://localhost:5672\u0026#34;], queue: \u0026#34;auth_queue\u0026#34;, }, }, ]), ], controllers: [ApiGatewayController], providers: [ApiGatewayService], }) export class ApiGatewayModule {} ``` ### 2. Authentication Module ```typescript // src/auth/entities/user.entity.ts @Entity() export class User { @PrimaryGeneratedColumn(\u0026#34;uuid\u0026#34;) id: string; @Column({ unique: true }) email: string; @Column() password: string; @Column({ type: \u0026#34;json\u0026#34;, nullable: true }) preferences: Record\u0026lt;string, any\u0026gt;; } // src/auth/auth.service.ts @Injectable() export class AuthService { constructor( @InjectRepository(User) private userRepository: Repository\u0026lt;User\u0026gt;, private jwtService: JwtService ) {} async validateUser(email: string, password: string): Promise\u0026lt;any\u0026gt; { const user = await this.userRepository.findOne({ where: { email } }); if (user \u0026amp;\u0026amp; (await bcrypt.compare(password, user.password))) { return user; } return null; } } ``` ### 3. User Module ```typescript // src/user/entities/profile.entity.ts @Entity() export class Profile { @PrimaryGeneratedColumn(\u0026#34;uuid\u0026#34;) id: string; @OneToOne(() =\u0026gt; User) @JoinColumn() user: User; @Column({ type: \u0026#34;json\u0026#34; }) ideSettings: Record\u0026lt;string, any\u0026gt;; @Column({ type: \u0026#34;json\u0026#34; }) aiPreferences: Record\u0026lt;string, any\u0026gt;; } ``` ### 4. Product Module (IDE Core) ```typescript // src/ide/entities/project.entity.ts @Entity() export class Project { @PrimaryGeneratedColumn(\u0026#34;uuid\u0026#34;) id: string; @ManyToOne(() =\u0026gt; User) owner: User; @Column() name: string; @Column({ type: \u0026#34;json\u0026#34; }) configuration: Record\u0026lt;string, any\u0026gt;; @Column({ type: \u0026#34;jsonb\u0026#34; }) aiContext: Record\u0026lt;string, any\u0026gt;; } ``` ## Event-Driven Architecture ### Event Bus Configuration ```typescript // src/common/event-bus/event-bus.module.ts @Module({ imports: [ ClientsModule.register([ { name: \u0026#34;EVENT_BUS\u0026#34;, transport: Transport.RMQ, options: { urls: [\u0026#34;amqp://localhost:5672\u0026#34;], queue: \u0026#34;main_event_queue\u0026#34;, }, }, ]), ], providers: [EventBusService], exports: [EventBusService], }) export class EventBusModule {} ``` ### Event Handlers ```typescript // src/ide/events/code-analysis.handler.ts @Injectable() export class CodeAnalysisHandler { @EventPattern(\u0026#34;code.analysis.requested\u0026#34;) async handleCodeAnalysis(@Payload() data: CodeAnalysisEvent) { // AI-powered code analysis logic } } ``` ## Database Schema ### TypeORM Configuration ```typescript // src/config/typeorm.config.ts export const typeOrmConfig: TypeOrmModuleOptions = { type: \u0026#34;postgres\u0026#34;, host: process.env.DB_HOST, port: parseInt(process.env.DB_PORT, 10), username: process.env.DB_USERNAME, password: process.env.DB_PASSWORD, database: process.env.DB_DATABASE, entities: [User, Profile, Project], migrations: [\u0026#34;dist/migrations/*.js\u0026#34;], synchronize: false, logging: true, }; ``` ## AI Integration Services ### Code Analysis Service ```typescript // src/ide/services/ai-analysis.service.ts @Injectable() export class AIAnalysisService { constructor( private readonly httpService: HttpService, private readonly eventBus: EventBusService ) {} async analyzeCode(code: string, context: AIContext): Promise\u0026lt;AnalysisResult\u0026gt; { // AI model integration logic } } ``` ### Code Completion Service ```typescript // src/ide/services/code-completion.service.ts @Injectable() export class CodeCompletionService { constructor( private readonly aiService: AIService, private readonly codeContextService: CodeContextService ) {} async getCompletion( code: string, position: Position, context: CompletionContext ): Promise\u0026lt;CompletionSuggestion[]\u0026gt; { // Code completion logic } } ``` ## Security Implementations ### Authentication Guard ```typescript // src/auth/guards/jwt-auth.guard.ts @Injectable() export class JwtAuthGuard extends AuthGuard(\u0026#34;jwt\u0026#34;) { constructor(private reflector: Reflector) { super(); } canActivate(context: ExecutionContext) { const isPublic = this.reflector.getAllAndOverride\u0026lt;boolean\u0026gt;(IS_PUBLIC_KEY, [ context.getHandler(), context.getClass(), ]); if (isPublic) { return true; } return super.canActivate(context); } } ``` ## Deployment Architecture ### Docker Configuration ```dockerfile # Dockerfile FROM node:16-alpine WORKDIR /usr/src/app COPY package*.json ./ RUN npm install COPY . . RUN npm run build EXPOSE 3000 CMD [\u0026#34;npm\u0026#34;, \u0026#34;run\u0026#34;, \u0026#34;start:prod\u0026#34;] ``` ### Docker Compose Setup ```yaml # docker-compose.yml version: \u0026#34;3.8\u0026#34; services: api: build: . ports: - \u0026#34;3000:3000\u0026#34; depends_on: - postgres - rabbitmq postgres: image: postgres:13 environment: POSTGRES_PASSWORD: ${DB_PASSWORD} POSTGRES_DB: ${DB_NAME} rabbitmq: image: rabbitmq:3-management ports: - \u0026#34;5672:5672\u0026#34; - \u0026#34;15672:15672\u0026#34; ``` ## Scaling Considerations 1. **Horizontal Scaling** - Use Kubernetes for container orchestration - Implement load balancing at the API Gateway level - Scale individual microservices independently 2. **Performance Optimization** - Implement caching strategies using Redis - Optimize database queries and indexes - Use WebSocket for real-time features 3. **Monitoring and Logging** - Implement ELK stack for centralized logging - Use Prometheus and Grafana for metrics - Set up application performance monitoring ## Development Workflow 1. **Local Development** ```bash # Start development environment npm run start:dev # Run database migrations npm run typeorm migration:run # Generate new migration npm run typeorm migration:generate -- -n MigrationName ``` 2. **Testing Strategy** ```typescript // src/ide/tests/code-analysis.service.spec.ts describe(\u0026#34;CodeAnalysisService\u0026#34;, () =\u0026gt; { let service: CodeAnalysisService; beforeEach(async () =\u0026gt; { const module: TestingModule = await Test.createTestingModule({ providers: [CodeAnalysisService], }).compile(); service = module.get\u0026lt;CodeAnalysisService\u0026gt;(CodeAnalysisService); }); it(\u0026#34;should analyze code correctly\u0026#34;, async () =\u0026gt; { // Test implementation }); }); ``` ## Future Considerations 1. **AI Model Integration** - Support for multiple AI models - Custom model training capabilities - Model versioning and A/B testing 2. **Extensibility** - Plugin architecture - Custom extension marketplace - API versioning strategy 3. **Developer Experience** - Interactive documentation - Developer portal - API playground 任务分解：tasks.md 以下是如何构建 AI 理解任务：\n# 当前 Sprint 任务 ## USER-001：实现用户身份验证 状态：进行中 优先级：高 依赖性：无 ### 要求 - 电子邮件/密码身份验证 - JWT 令牌生成 - 使用 bcrypt 进行密码哈希处理 - 登录尝试的速率限制 ### 验收标准 1.用户可以使用电子邮件/密码注册 2.用户在登录成功后收到 JWT 3.密码经过安全哈希处理 4.登录尝试失败的速率受到限制 ### 技术说明 - 使用@nestjs/jwt 进行令牌管理 - 使用 Redis 实现速率限制 - 遵循来自 Technical.md 的身份验证模式 进度跟踪：status.md 该文件可帮助 AI 了解当前的开发状态：\n# 项目状态 ## 已完成的功能 - 基本项目设置 - 数据库连接 - 基本模块结构 ## 进行中 -用户身份验证（USER-001） - ✅ 基本用户模型 - ✅ 密码哈希 - 🏗️ JWT 实施 - ⏳ 速率限制 ## 待定 - 电子邮件验证 - 密码重置流程 - 用户配置文件管理 ## 已知问题 - 目前无 管理上下文和文件引用 Cursor 的真正威力来自智能上下文管理。每当您达到上下文限制时（大型项目中经常发生这种情况），您都需要一种方法来快速恢复 AI 对项目的理解。这就是我们的文件结构和引用系统变得至关重要的地方。让我们看看它的实际效果：\n了解上下文限制以及 status.md 为何至关重要 大多数教程都不会告诉你：像 Cursor 这样的 AI 助手有上下文限制。一旦达到该限制，AI 就会失去对之前更改和讨论的跟踪。这时 status.md 就会成为你的生命线。\n将 status.md 视为项目的内存。当 Cursor 达到其上下文限制时（这种情况发生的频率比您想象的要高），您可以使用 status.md 快速恢复上下文，而无需再次解释所有内容。\n达到上下文限制的示例：\n你：让我们继续进行身份验证服务 Cursor：*由于上下文限制，对之前的实施细节一无所知* 你：@{docs/status.md} 让我们继续进行 JWT 实施 Cursor：*现在了解当前状态并可以适当地继续* Cursor 中的实用文件引用 您无需编写命令，而是可以通过以下方式在 Cursor 中实际引用文件：\n1. 从多个文件添加上下文： @{docs/status.md} @{docs/technical.md} @{tasks/tasks.md} 现在，让我们实现 JWT 身份验证服务…… 2. 检查当前实施情况： @{src/auth/auth.service.ts} 您能根据@{docs/technical.md} 规范添加速率限制吗？ 真实示例：构建身份验证服务 让我们看看在适当的文件引用和上下文管理下，这在实践中是如何实现的：\n1. 首先收集背景信息： @{docs/architecture.mermaid} @{tasks/tasks.md} @{docs/status.md} 我需要帮助从 USER-001 实现 JWT 身份验证服务。 2.在实施过程中，当您遇到上下文限制时： @{docs/status.md} 让我们继续 JWT 服务的实现。我们正在研究速率限制。 3. 添加新功能时： @{src/auth/auth.service.ts} @{docs/technical.md} 您能按照我们的技术规范添加密码重置功能吗？ 为什么这种方法有效 每次引用文件时，Cursor 都会获取最新的上下文 status.md 帮助跟踪上下文重置的进度 即使失去背景信息，技术规格仍保持一致 现实检验：人工智能不是魔法，而是一种工具 让我们来谈谈这个显而易见的问题——人工智能编码助手通常被宣传为能够编写整个应用程序的神奇代码生成器。这正是许多开发人员感到沮丧并声称“人工智能产生的错误比代码还多”的原因。\n现实情况是：人工智能就像拥有一位出色的初级开发人员，他：\n具有完美的模式记忆（在上下文限制内） 能够以闪电般的速度编写样板文件 应对复杂的业务逻辑 需要明确的规范和指导 遵循测试驱动开发时效果最佳 为什么大多数开发人员在 AI 方面遇到困难 我看到的典型方法：\n开发人员：“使用 OAuth 为我构建一个用户身份验证系统” AI：*生成看似完整的代码* 开发人员：*在边缘情况下发现错误* 开发人员：“AI 不可靠！” 真正的问题是什么？我们错误地使用了人工智能。让我告诉你如何改变你的方法。\n测试驱动开发（TDD）：抵御人工智能幻觉的盾牌 真相是：人工智能会产生幻觉。它会编写看似合理但实际上却错误的代码。解决方案是什么？TDD。\n考虑一下这个现实世界的场景：\n// ❌ Without TDD @{src/auth/auth.service.ts} // Developer: \u0026#34;Add password reset functionality\u0026#34; // AI generates code that: // - Looks correct // - Handles the happy path // - Misses critical edge cases // - Has security vulnerabilities in token validation // ✅ With TDD @{src/auth/auth.service.spec.ts} // Developer: \u0026#34;Here are the test cases for password reset: describe(\u0026#39;PasswordResetService\u0026#39;, () =\u0026gt; { it(\u0026#39;should throw if token is expired\u0026#39;) it(\u0026#39;should prevent timing attacks in token comparison\u0026#39;) it(\u0026#39;should rate limit reset attempts\u0026#39;) it(\u0026#39;should handle non-existent emails securely\u0026#39;) }) // Now implement the service to pass these tests\u0026#34; TDD 为何能与 AI 协同工作：\n强制明确要求 防止出现幻觉行为 尽早发现边缘情况 维护安全考虑 真正的开发陷阱（以及如何避免） 1. 复杂逻辑幻觉 // ❌ 危险：让 AI 直接处理复杂的业务逻辑 “实现账单计算逻辑” // ✅ 安全：通过测试分解 @{src/billing/billing.spec.ts } “实现账单计算以通过以下测试用例： 1 .基本费率计算 2. 批量折扣 3. 特殊节假日费率 4. 多币种支持” 2. 状态管理陷阱 当 AI 处理状态时，它经常会产生细微的错误。例如：\n// ❌ Problematic export class UserService { private users: User[] = []; // Global state! async createUser(user: User) { this.users.push(user); // Race conditions waiting to happen } } // ✅ Correct export class UserService { constructor(private readonly userRepository: UserRepository) {} async createUser(user: User) { await this.userRepository.transaction(async (repo) =\u0026gt; { await repo.save(user); }); } } 3. 依赖地狱 AI 喜欢创建循环依赖。以下是防止它们的方法：\n// ❌ AI 的自然倾向 @{src/user/user.service.ts} 依赖于 @{src/auth/auth.service.ts} @{src/auth/auth.service.ts} 依赖于 @{src/user/user.service.ts} // ✅ 正确的方法 @{docs/architecture.mermaid} “给定这种架构，实现用户服务以确保： 1.依赖关系单向流动 2.使用接口进行跨模块通信 3.事件驱动通信满足循环需求” 上下文限制：实用指南 当你达到上下文限制时（你会的），实际上会发生以下情况：\n// Initial implementation @{src/auth/auth.service.ts} \u0026#34;Add OAuth support\u0026#34; // AI: Implements OAuth perfectly // Later in the conversation... \u0026#34;Add refresh token support\u0026#34; // AI: Implements it incorrectly because it lost context // Solution: Restore context with status @{docs/status.md} @{src/auth/auth.service.ts} \u0026#34;Add refresh token support to our OAuth implementation\u0026#34; // AI: Now has full context and implements correctly 真实世界情境管理： 保持 status.md 专注于架构决策 记录关键实施模式 参考相关测试来进行行为规范 安全和错误处理：隐藏的陷阱 人工智能有一种危险的倾向：\n跳过错误处理 使用不安全的类型断言 错过安全验证 解决方案：使用明确的错误和安全测试：\ndescribe(\u0026#39;UserAuthentication\u0026#39;, () =\u0026gt; { it(\u0026#39;should handle SQL injection attempts\u0026#39;) it(\u0026#39;should prevent timing attacks\u0026#39;) it(\u0026#39;should rate limit failed attempts\u0026#39;) it(\u0026#39;should log security events\u0026#39;) it(\u0026#39;should sanitize error messages\u0026#39;) }) 清洁人工智能开发的最佳实践 1. 总是从架构开始 首先更新你的美人鱼图 确保人工智能理解系统边界 2. 分解任务 创建明确、重点突出的任务 包括所有要求和验收标准 3. 保持状态 保持 status.md 更新 跟踪进度和问题 4.使用TDD 首先编写测试 让AI实现通过测试 结论 成功开发 AI 的关键不在于拥有最聪明的 AI，而在于赋予它正确的背景和结构。通过遵循此策略，您将把 Cursor 从有时有用的工具转变为可靠的开发合作伙伴。\n记住：\n清晰的架构 结构化任务 明确规则 持续更新 停止与人工智能争斗，开始与它合作。结果可能会让你大吃一惊。\n注：本文译自 https://medium.com/@vrknetha/the-ultimate-guide-to-ai-powered-development-with-cursor-from-chaos-to-clean-code-fc679973bbc4\n","date":"2025-02-13T21:13:56+08:00","permalink":"https://yearsuns-github-io.vercel.app/p/the-ultimate-guide-to-development-with-cursor/","title":"Cursor开发终极指南"},{"content":"1. 聊天现状：你在说人话，但对方没听懂 你有没有过这样的经历？\n你兴致勃勃地向朋友吐槽工作：“哎，我最近忙得要疯了！”结果对方只回了一句：“嗯，真辛苦啊。” 想和对象沟通：“我们可以多花点时间在一起吗？”结果人家理解成了“你是不是嫌我陪得还不够？” 开会时侃侃而谈，末了却发现大家脸上写满了“所以你想说啥？”的表情。 ⭐你费尽口舌，对方一脸懵逼；你努力铺垫，核心意思全跑偏。这种“鸡同鸭讲”的情况是不是让你崩溃到怀疑人生？\n别担心，这并不是因为你“不够聪明”或者“社交恐惧”，而是因为你的沟通方式需要升级。下面，我们从心理学角度拆解问题根源，再给出一份人人适用的沟通宝典！\n2. 心理学拆解：为啥“明明说了”却没传达清楚？ ❗误区一：信息超载，别人没抓住重点 心理学上有个概念叫“认知负荷理论”。当信息量过大时，人脑会像“内存不足”的电脑一样自动跳过部分内容。而很多人表达时会“前情提要+背景介绍+长篇感慨”，最后忘了告诉对方核心需求。\n比如：\n“我最近工作好多压力啊，晚上熬夜写方案，白天还要跟客户开会，周末本想休息还被拉去团建，我感觉快撑不下去了……”\n对方接收到的关键词可能是：工作、熬夜、团建。但你真正想表达的是“我需要支持”。\n心理学解法：少讲背景，多讲核心。用清晰的逻辑简化信息传递，避免听者迷路。\n❗误区二：情绪先行，信息被情绪屏蔽 情绪是沟通的双刃剑。当你在表达时情绪过于激烈（生气、委屈、沮丧），对方的注意力可能会被你的情绪吸引，而忽略了你的实际诉求。\n比如：\n“你为什么总是不回我消息？我真的很生气！是不是根本不在乎我！”\n对方的大脑此时的翻译器可能工作成这样：\n情绪输入：生气、指责 行动输出：回避、不敢沟通 心理学解法：表达感受时，把情绪和需求分开。情绪引导可以软化开头，需求要明确表达。\n❗误区三：假设对方能读懂你的“潜台词” 你以为表达了一切，但对方却完全没听懂。心理学研究表明，每个人的认知框架不同，你的“理所当然”可能是别人的“完全陌生”。\n比如：\n你对队友说：“报告PPT今天能不能早点搞定？”\n而对方可能在想：“‘早点’是多早？今晚10点？还是明早8点？”\n心理学解法：用具体的语言取代模糊的指令，把潜台词变成明台词。\n3. 解决方案：3步搞定高效沟通 第一步：用“黄金三段式”表达需求 心理学家推荐的“黄金三段式”，可以让你的沟通简单又高效。\n公式：\n感受+事实+需求\n案例：\n错误表达：“为什么你都不陪我？” 黄金三段式：“我最近感觉有点孤单（感受）。你上周末和这周都很忙，没一起吃饭（事实）。下次周末我们能一起吃个饭吗（需求）？” 这么说是不是更容易让对方明白你的需求？\n第二步：巧用“提问引导”代替说教 与其“输出式表达”，不如通过提问让对方参与。\n提问的威力：\n开放式提问（多问“怎么想”）：\n错误：\u0026ldquo;你根本没用心听我说话！\u0026rdquo; 改进：\u0026ldquo;你觉得刚刚我说的那些，哪个部分比较重要？\u0026rdquo; 选择式提问（给选项降低压力）：\n错误：\u0026ldquo;你打算什么时候改这个方案？\u0026rdquo; 改进：\u0026ldquo;我们是今天讨论细节，还是明天具体落实？\u0026rdquo; 提问不仅让对方更有参与感，还能巧妙避免冲突。\n第三步：多用“复述确认”打消误解 复述是一种被心理学验证过的高效沟通技巧。用自己的语言总结对方表达的内容，能避免“鸡同鸭讲”。\n复述公式：\n“你是说……对吗？”\n案例：\n错误方式：\n甲：“我最近感觉好累。” 乙：“多休息吧。”（误解对方意思） 正确方式：\n甲：“我最近感觉好累。” 乙：“你是说最近事情太多让你有点承受不住了？” 复述不仅能让对方感受到被理解，还能让你捕捉到对方的真实需求。\n第四步：善用肢体语言提升沟通效果 心理学研究显示，语言只占沟通的7%，语气和肢体语言却占到了93%。\n保持眼神交流：眼神能传递专注感和信任感。 使用开放的肢体动作：双臂张开比交叉在胸前更容易让人感到亲近。 适当点头和微笑：增强对方的表达欲望。 肢体语言是一种无声的沟通技巧，掌握它可以让你的表达如虎添翼。\n第五步：利用“沉默技巧”创造空间 很多人以为沟通就是不停地说，但心理学认为，适当的沉默反而能带来意想不到的效果。\n沉默制造思考：当你表达完后，给对方一些时间消化和回应，而不是急于填补空白。 沉默化解冲突：当对方情绪激动时，安静的聆听比言语更有效。 沉默是沟通的高级形式，学会用沉默说话，你的对话会更加流畅。\n4. 总结：沟通高手的秘密，其实是“懂得聆听+表达精准” 说到底，沟通的本质不是“说得多”，而是“听得准、说得对”。心理学家认为，每一次成功的沟通背后，都有以下关键：\n明确目的：你希望对方理解什么？解决什么问题？ 减少噪音：摒弃无关信息，直击核心。 用心倾听：通过提问与复述确认对方的感受和需求。 调整表达方式：结合语言、肢体和情绪多维度传递信息。 创造对话空间：在表达和沉默中找到平衡。 所以，下次当你发现对话陷入“鸡同鸭讲”时，不妨用这些方法试试看。掌握了这些心理学技巧，你不只是沟通小白升级为大师，甚至可能成为“人类话语机器”！（开玩笑✨）\n最后，记住这句话：沟通不是天赋，是技能；而技能，可以习得。\n","date":"2025-02-13T20:38:56+08:00","permalink":"https://yearsuns-github-io.vercel.app/p/the-science-of-high-impact-communication/","title":"摆脱“话题终结者”！心理学教你3步升级为沟通大师✨"},{"content":"我们将从这篇文章中学到什么 👉 REST API 的基本原则 RESTful架构的核心概念 关键 HTTP 方法及其适当用途 👉 API 设计的最佳实践 如何设计有意义且高效的面向资源的 URL。 正确使用标准 HTTP 状态代码的重要性。 实现过滤、排序和分页的技术。 需要清晰、一致的 API 文档和工具来帮助实现这一点。 有效的 API 版本控制策略，以确保向后兼容性。 保护 API 安全的最佳实践，包括身份验证和 HTTPS。 如何以用户友好且信息丰富的方式处理错误。 维护 RESTful 原则和避免常见错误的实用技巧。 对设计可扩展且直观的 API 的见解。 API 设计中的常见陷阱以及如何避免它们。 👉 实用的注意事项 维护 RESTful 原则和避免常见错误的实用技巧。 对设计可扩展且直观的 API 的见解。 API 设计中的常见陷阱以及如何避免它们。 什么是 API？ 应用程序编程接口 (API) 是用于集成应用软件和服务的一组工具、定义和协议。它可以让您的产品和服务与其他产品和服务进行通信，而无需不断构建新的连接基础设施。\nAPI 可以是私有的（仅供内部使用）、合作的（与特定合作伙伴共享以提供额外的收入来源）或公开的（允许第三方开发与您的 API 交互的应用程序以促进创新）。\nhttps://www.redhat.com/en/topics/api/what-is-a-rest-api\n什么是 REST API？ REST API（也称为 RESTful API）是一种符合 REST 架构风格约束并允许与 RESTful Web 服务交互的应用程序编程接口（API 或 Web API）。REST 代表表述性状态转移，由计算机科学家 Roy Fielding 创建。\nhttps://www.redhat.com/en/topics/api/what-is-a-rest-api\nREST API 架构约束 REST 是一组架构约束，而不是协议或标准。以下是理想 RESTful API 的约束：\n客户端-服务器架构：由客户端、服务器和资源组成的客户端-服务器架构，请求通过 HTTP 进行管理。只要服务器和客户端之间的接口不变，它们也可以被替换和独立开发（也可以使用不同的编程语言）。 无状态：在客户端-服务器通信中，在处理请求传输期间，服务器上不应存储任何数据。这意味着请求之间不会存储任何客户端信息，并且每个请求都是独立且无关联的。 可缓存：客户端应该能够将响应存储在缓存中。这极大地提高了 API 的性能。 分层系统：服务器可以有多个层级来实现。这种分层架构有助于通过实现负载平衡来提高可扩展性。 按需代码：此约束是可选的。此约束表示可以通过允许从服务器下载代码并执行代码来在运行时扩展客户端应用程序的功能。 统一接口：统一接口约束是任何 RESTful 系统设计的基础。它简化并解耦了架构，使每个部分能够独立发展。 这个统一接口的四个约束是：\n请求中的资源标识：使用 URI 在请求中标识单个资源。资源本身在概念上与返回给客户端的表示形式是分开的。例如，服务器可以将数据库中的数据以 HTML、XML 或 JSON 的形式发送，而这些都不是服务器的内部表示形式。\n通过表示来操作资源：当客户端持有资源的表示（包括附加的任何元数据）时，它有足够的信息来修改或删除资源的状态。\n自描述消息：每条消息都包含足够的信息来描述如何处理该消息。例如，可以通过媒体类型指定要调用哪个解析器。\n超媒体作为应用程序状态引擎 (HATEOAS) — 访问 REST 应用程序的初始 URI 后（类似于人类 Web 用户访问网站主页），REST 客户端应该能够动态使用服务器提供的链接来发现所需的所有可用资源。随着访问的进行，服务器将使用包含指向当前可用的其他资源的超链接的文本进行响应。客户端无需使用有关服务器结构的信息进行硬编码。\n来源：https://en.wikipedia.org/wiki/REST#Uniform_interface\n什么是资源？ REST中信息的关键抽象是资源。任何可以命名的信息都可以是资源：文档或图像、时间服务（例如“洛杉矶今日天气”）、其他资源的集合（例如“今日畅销产品”，即产品资源的集合）、非虚拟对象（例如人）等等。\n— Roy Fielding 的论文\n单例和集合资源 资源可以是单例，也可以是集合。\n例如，\u0026ldquo;customers\u0026rdquo; 是一个集合资源，\u0026ldquo;customer\u0026rdquo; 是一个单例资源。\n我们可以使用 URI 来识别 \u0026ldquo;customers\u0026rdquo; 集合资源。我们可以使用 URI 来/customers识别单个 \u0026ldquo;customer\u0026rdquo; 资源/customers/{customerId}\n/customers // 是一个集合资源 /customers/{id} // 是一个单例资源 集合和子集资源 资源也可能包含子集资源。\n例如，可以使用以下方式识别特定 \u0026ldquo;customers\u0026rdquo; 的子集资源 \u0026ldquo;account\u0026rdquo; /customers/{customerId}/accounts\n类似地，可以识别子集合资源 \u0026ldquo;accounts\u0026rdquo; 内的单例资源 \u0026ldquo;account\u0026rdquo; /customers/{customerId}/accounts/{accountId}\n/customers //是一个集合资源\n/customers/{ id }/accounts //是一个子集合资源（客户的帐户）\n/customers/{customerId}/accounts/{accountId} //是一个单例资源（客户的特定帐户）\nURI（统一资源标识符） URI 代表统一资源标识符(URI)。它标识网络上的逻辑或物理资源。URL 和 URN 是 URI 的子类型。URL 定位资源，而 URN 命名资源。\nREST API 使用 URI 来定位资源。REST API 设计人员应创建 URI，以便将 REST API 的资源模型传达给 API 的潜在客户。如果资源命名得当，API 就会直观且易于使用。如果命名不当，同一个 API 的使用和理解就会变得困难。\n最佳实践：应该做的和不应该做的 1. 使用适当的 HTTP 方法（动词）定义 API 操作 HTTP协议定义了许多为请求赋予语义的方法。大多数 RESTful Web API 使用的常见 HTTP 方法包括：\nGET在指定的 URI 处检索资源的表述，响应消息的主体包含所请求资源的详细信息。\nPOST在指定的 URI 处创建新资源，请求消息的主体提供了新资源的详细信息。注意：POST还可用于触发不实际创建资源的操作。\nPUT在指定的 URI 处创建或替换资源，请求消息的主体指定要创建或更新的资源。\nPATCH对资源执行部分更新，请求主体指定要应用于资源的一组更改。\nDELETE删除指定 URI 处的资源。\n特定请求的效果应取决于资源是集合还是单个项目。下表使用电子商务示例总结了大多数 RESTful 实现所采用的通用约定。\n注意：并非所有这些请求都可能被实现——这取决于具体情况。\nResource POST GET PUT DELETE /customers Create a new customer Retrieve all customers Bulk update of customers Remove all customers /customers/1 Error Retrieve the details for customer 1 Update the details of customer 1 if it exists Remove customer 1 /customers/1/orders Create a new order for customer 1 Retrieve all orders for customer 1 Bulk update of orders for customer 1 Remove all orders for customer 1 POST、PUT和PATCH之间的区别可能会令人困惑。\nPOST请求创建资源并将其添加到资源集合中。然后向客户端返回新创建的资源 URI。POST请求还可用于向现有资源提交数据以供处理，而无需创建任何新资源。\nPUT请求会创建资源或更新现有资源。请求正文包含资源的完整表述。如果具有此 URI 的资源已存在，则将其替换。否则，如果服务器支持，则创建新资源。PUT请求最常应用于作为单个项目（例如特定客户）的资源，而不是集合。服务器可能支持更新但不支持通过 PUT 创建。是否支持通过 PUT 创建取决于客户端是否可以在资源存在之前有意义地为其分配URI。如果不能，则使用POST创建资源，使用PUT或PATCH进行更新。\nPATCH请求对现有资源执行部分更新。请求正文指定要应用于资源的一组更改。这比使用PUT更高效，因为客户端仅发送更改，而不是资源的整个表示。\nPUT请求必须是幂等的。如果客户端多次提交相同的PUT请求，则结果应该始终相同（将使用相同的值修改相同的资源）。POST和PATCH请求不保证是幂等的。\n2. 使用名词（复数名词）表示资源 RESTful URI 应该引用作为事物（名词）的资源，而不是引用动作（动词），因为名词具有动词所不具备的属性 — 同样，资源也具有属性。以下是一些资源示例：\n用户(user) 帐户(account) 其资源URI可以设计如下：\nHTTP Method Endpoint Description GET /accounts Returns a list of accounts GET /accounts/{accountNumber} Returns the account with account number {accountNumber} GET /users Returns a list of users GET /users/{id} Returns the user with ID {id} GET /orders Good - Returns a list of orders GET /create-order Avoid - verb or action-based names GET /students Good - Returns a list of students GET /student Avoid - singular names 3.使用子资源建立关系 使用一致的资源命名约定和 URI 格式，以最大程度地减少歧义并实现最大的可读性和可维护性。实施以下设计提示可实现一致性：\n在 REST 中，关系通常由子资源建模。对子资源使用以下模式。 HTTP Method Endpoint Description GET /{resource}/{resource-id}/{sub-resource} Retrieves a list of sub-resources GET /{resource}/{resource-id}/{sub-resource}/{sub-resource-id} Retrieves a specific sub-resource POST /{resource}/{resource-id}/{sub-resource} Creates a new sub-resource GET /post/{post-id}/comments Retrieves a list of comments for a post GET /post/{post-id}/comments/{comment-id} Retrieves a specific comment for a post POST /post/{post-id}/comments Creates a new comment for a post GET /cars/711/drivers/ Returns a list of drivers for car 711 GET /cars/711/drivers/4 Returns driver #4 for car 711 4.注重可读性和一致性 不要在 URI 中使用尾部斜杠 (/) GET /device-management/managed-devices/ GET /device-management/managed-devices /*✅这是一个更好的版本*/ 使用连字符 (-) 和短横线命名 ( some-var-name) 来提高 URI 的可读性 GET /devicemanagement/manageddevices/ GET /device-management/managed-devices /*✅这是一个更好的版本* / GET /m y -folder/ my -doc // ✅ 推荐 GET /MY-FOLDER/ my -doc // ❌ 避免 GET /My-Folder/ my -doc // ❌ 避免 避免使用下划线 ( _ ) 和驼峰式命名 ( someVarName) 蛇形命名 ( some_var_name) 帕萨尔式命名 ( SomeVarName) GET /managed-entities/{ id }/install-script-location // ✅ 更易读 GET /managed_entities/{ id }/install_Script_Location // ❌ 蛇形命名法- 易读但不常规 GET /managedEntities/{ id }/installScriptLocation // ❌ 驼峰命名法- 可读性较差 不要使用文件扩展名 /device-management/managed-devices.xml /*❌请勿使用它*/ /device-management/managed-devices /*✅这是正确的 URI*/ 切勿在 URI 中使用CRUD函数名称 /* ❌ 避免 */ HTTP GET / get -managed-devices HTTP POST /create-managed-devices /* ✅ 推荐 */ HTTP GET /managed-devices // 获取所有设备 HTTP POST /managed-devices // 创建新设备 HTTP GET /managed-devices/{id} // 获取给定 Id 的设备 HTTP PUT /managed-devices/{id} // 更新给定 Id 的设备 HTTP DELETE /managed-devices/{id} // 删除给定 Id 的设备 不要在 URI 中使用动词 GET /scripts/{id}/execute // ❌ 不要这样做！- 这是 RPC，而不是 REST POST /scripts // ✅ 推荐：使用 POST 操作创建脚本 GET /scripts/{id}/status // 检查执行状态 5.使用HTTP响应状态码 始终使用常规 HTTP 状态码来响应对 API 发出的请求。这将帮助用户了解发生了什么 — 请求是否成功，是否失败，或者其他情况。\n6.使用过滤、排序和分页来检索请求的数据 Feature Description Example Usage Sorting Allows sorting of the dataset based on specified parameters. /companies?sort=rank_asc Filtering Filters the dataset based on given criteria in query parameters. /companies?category=banking\u0026amp;location=india Searching Searches for specific terms within the dataset. /companies?search=Digital Pagination Divides the dataset into smaller chunks for easier handling and improved performance. /companies?page=23 7. 使用 HATEOAS 实现到相关资源的导航 HATEOAS（超文本作为应用程序状态引擎）是 REST 的一个原则，允许客户端仅通过响应中提供的超链接来浏览资源并发现可用的操作。这意味着客户端不需要事先了解 URI；相反，每个 HTTP GET 请求都会返回必要的信息和相关资源的链接，从而实现对 API 的动态探索。\n在示例响应中，/books/1分享可导航的链接，例如/authors/1 /books/1/reviews\n{ “books” ： [ { “id” ： 1 ， “title” ： “了不起的盖茨比” ， “author” ： “F·斯科特·菲茨杰拉德” ， “links” ： { “self” ： “/books/1” ， “author” ： “/authors/1” ， “reviews” ： “/books/1/reviews” } } ， { “id” ： 2 ， “title” ： “杀死一只知更鸟” ， “author” ： “哈珀·李” ， “links” ： { “self” ： “/books/2” ， “author” ： “/authors/2” ， “reviews” ： “/books/2/reviews” } } ] } 8. 使用 SSL 确保安全 SSL（安全套接字层）对于保护 REST API 免受恶意攻击至关重要。它确保服务器和客户端之间的通信是私密的，并且用户只能访问他们有权查看的数据。\nhttps:// 我们可以通过查看URL来判断 REST API 是否受 SSL 保护。例如，https://mysite.com/posts 受 SSL 保护，而 http://mysite.com/posts 不受 SSL 保护。\n9.提供准确的API文档 良好的 API 文档可帮助开发人员正确使用我们的 API。它可以让更多人想要使用我们的 API 并更好地使用它。一个流行的 API 文档工具是OpenAPI ( Swagger )\n10. RESTful Web API 版本控制 Versioning Method Description Example Usage Real-World Examples URI Path Includes the version number directly in the API path. http://www.example.com/api/v1/products\nhttp://www.example.com/api/v2/products - Twitter\n- PayPal\n- Google Translate Query Parameters Specifies the version number as a query parameter in the URL. http://www.example.com/api/products?version=1\nhttp://www.example.com/api/products?version=2 - Google Translation APIs Custom Headers Uses custom headers to specify the API version. http://localhost:8080/api/products\nHeaders: X-API-VERSION=1\nhttp://localhost:8080/api/products\nHeaders: X-API-VERSION=2 - Content Negotiation Uses the Accept header to specify the version of the API. http://localhost:8080/api/products\nHeaders: Accept=application/vnd.javaguides-v1+json\nhttp://localhost:8080/api/products\nHeaders: Accept=application/vnd.javaguides-v2+json - GitHub 11. API 安全和访问控制 确保 API 安全并控制谁可以使用它是制作优质 RESTful API 的关键部分。以下是一些实现此目的的方法：\n设置 OAuth 2.0 或 JSON Web Tokens (JWT)，以便未经身份验证的用户无法访问\nAPI 密钥显示谁在使用。API速率限制可阻止人们过度使用。\n实现基于角色的访问控制（RBAC）等。\n12. 不要忘记 API 性能 让我们的 API 更好地发挥作用是让用户满意、降低成本和更轻松地发展的关键。\n有效缓存\n数据压缩方法\n异步处理\n处理批处理操作\n测量 API 性能并分析 API 使用情况\n监控 API 健康和正常运行时间\n测试 RESTful API（单元测试、集成测试、负载测试、安全测试）等。\n结论 优秀的 REST API 是通过遵循关键规则和最佳实践来构建的。\n通过遵守这些规则，我们将构建易于使用、可靠且面向未来的 API。\n注：本文译自 https://medium.com/@syedabdullahrahman/mastering-rest-api-design-essential-best-practices-dos-and-don-ts-for-2024-dd41a2c59133\n","date":"2025-02-12T12:13:56+08:00","permalink":"https://yearsuns-github-io.vercel.app/p/best-practices-for-rest-api/","title":"REST API的最佳实践"},{"content":"🌟 什么是SMART原则？ 我们生活中常常给自己定下各种目标，想要健身、读书、升职、旅行……但一旦目标太大或太模糊，就容易半途而废。SMART原则是一个经过验证的工具，能帮助我们设定清晰、具体并能实现的目标，打破“空想目标”带来的无力感。\nSMART是五个英文单词的首字母缩写，代表了目标设定的五个关键特征：\nS: Specific（具体） M: Measurable（可衡量） A: Achievable（可实现） R: Relevant（相关性） T: Time-bound（时限性） 📜 SMART原则的起源 SMART原则并不是一蹴而就的，它是由美国管理学专家George T. Doran于1981年提出的，最早出现在他的文章《There’s a S.M.A.R.T. Way to Write Management’s Goals and Objectives》中。Doran提出，很多管理目标制定的模糊性和不切实际的期望，导致了企业和个人无法有效实现目标，因此，他需要提出一个能具体化目标设定、避免“空谈”的方法——SMART。\nGeorge T. Doran当时的初衷是解决企业和组织在设定目标时遇到的几个常见问题：目标过于模糊，执行步骤不清晰，结果难以衡量，且往往缺乏完成的时限。\n🧐 为什么要有SMART？ 在Doran的时代，目标设定存在一个普遍问题，那就是许多管理目标没有明确性，很多时候只是宽泛的愿景或“愿望”，如“提高员工满意度”或“增加市场份额”。这类目标没有任何执行上的指引，导致了许多企业无论如何努力，结果却始终看不见。\n例如，如果一个公司设定的目标是“提高员工的工作动力”，这个目标看起来似乎是有意义的，但它缺乏可操作性和评估标准——到底“提高”到什么程度才算成功？这个问题没有明确的答案，导致目标变得空洞且难以达成。\n🧠 为什么SMART有效？ 在心理学中，设定明确目标被认为是提高动机和焦点的有效方法。人类的大脑对于模糊不清的任务缺乏足够的投入感，容易在各种诱惑面前分心。SMART原则通过将目标细化、量化、并赋予紧迫感，让我们的大脑“抓住”了目标，不容易走神。\n1. 具体（Specific） 如果目标只是“我想变得更健康”，它几乎没有任何行动指引。SMART的具体化要求目标要清晰明确。例如：“我计划每周跑步三次，每次30分钟。”这个目标具体到了“跑步”“次数”“时间”，容易给人一种可以立即行动的感觉。\n目标具体性越强，任务的执行障碍就越小。这是因为大脑对模糊的目标感到困惑和不安，而明确的目标则让大脑更容易激发执行动力。\n2. 可衡量（Measurable） 没有衡量标准的目标，就像是开车但不看导航。比如，“我想提高身体素质”就太空泛，如何知道什么时候“提高了”呢？而SMART则要求目标具有可衡量的标准，例如：“我要在三个月内将跑步速度提高5公里每小时。”\n明确的衡量标准让大脑能不断确认进展，获得即时反馈，增强自我效能感——“我做得不错”的感觉。\n3. 可实现（Achievable） 如果你想在三个月内成为铁人三项冠军，那可能太不现实了。SMART原则提到，目标要根据个人的现有资源和能力设定。可实现性并非要求轻松，而是要能够在现有条件下有所突破。\n这一点体现了亚里士多德的“黄金中庸”思想。过高或过低的期望都会让目标变得不合适，过高可能让人感到无望，过低则无法激发成长。\n4. 相关性（Relevant） 你的目标要与你的长期愿景和核心价值观相关联。如果你设定的目标与自己的真实兴趣或需求脱节，执行起来往往缺乏动力。例如：“我要学习一门新语言，因为我打算明年去旅游。”\n如果目标和个人动机、兴趣不符，大脑会默认“这不值得投入”。因此，相关性决定了目标的重要性和个人投入的程度。\n5. 时限性（Time-bound） 没有时限的目标，就像是漂浮在空中的气球，永远不会落地。SMART原则通过设定具体的时间限制，促使行动的紧迫感产生。比如：“我将在六个月内完成这本书的阅读。”\n时间的有限性体现了时间哲学中的“现时性”——在有限时间内，我们必须作出选择并进行投入。而过于宽松的时间框架反而容易让人推延。\n🔑 如何运用SMART原则？ 运用SMART原则其实很简单，关键在于每次设定目标时，深入思考并将每个元素加以落实。\n举个例子： 假设你想提高体能，但传统目标“我要变强”显然过于模糊。根据SMART原则，你可以将目标转化为：\n具体：我将每周去健身房3次，每次锻炼40分钟。 可衡量：我要在3个月内将我的卧推重量提升5公斤。 可实现：根据当前我的体能水平，逐步增加每周的训练强度是现实的。 相关性：因为我希望能更加健康，增强体力以便更好地应对日常工作和生活挑战。 时限性：我将在3个月内达成这一目标。 🏁 SMART目标的实际案例 案例一：学习英语\n目标：我要在六个月内通过英语托福考试，目标分数为90分。 具体：每周安排15小时的学习时间，重点提升听力和口语能力。 可衡量：每月模拟考试一次，检查听力和口语的进展。 可实现：根据目前英语水平，合理的学习计划能让我逐步达到目标分数。 相关性：通过托福考试能让我申请到心仪的国际大学，是我职业发展的关键步骤。 时限性：六个月后完成托福考试，并达到目标分数。 案例二：完成销售目标\n目标：我要在三个月内将销售额提升20%。 具体：通过增加客户联系和优化销售话术，每周增加5次客户拜访。 可衡量：每月追踪销售额，并与上月进行对比。 可实现：根据现有资源和市场情况，通过提高拜访频次和改进沟通方式能达到目标。 相关性：提高销售额是公司业绩提升的关键，也是我个人职业成长的一部分。 时限性：三个月内完成销售目标。 案例三：增加收入\n目标：我要在六个月内将个人收入提升30%。 具体：通过副业和提升本职工作表现来增加收入。 可衡量：每月记录收入并与上月进行对比，评估副业和本职收入的变化。 可实现：合理安排时间，利用业余时间投入副业，同时提升本职工作表现。 相关性：增加收入有助于提升生活质量，实现经济独立。 时限性：六个月内实现收入增长。 🏢 SMART的影响与发展 虽然Doran的初衷是帮助企业制定可执行的管理目标，但随着时间的推移，SMART原则不仅仅局限于管理学领域，也被广泛应用于个人目标设定、项目管理、教育和生活规划等多个领域。它已经成为一个跨学科的工具，帮助人们以更加精确的方式设定、追踪和实现目标。\n🎯 总结：目标管理的哲学与心理学之道 SMART原则从最初的管理学应用，到如今成为各行各业目标设定的通用工具，其核心思想在于帮助人们清晰、量化并确保目标能够顺利实现。通过SMART，我们能够避免目标模糊带来的困惑，减少拖延，提高效率，更有动力朝着目标前进。正如Doran当时所言：“目标必须是明确且可执行的，才能激发人们的行动力。”\nSMART原则的出现，犹如给目标设定领域打上了清晰的框架，让“梦想”不再只是天边的云朵，而是可以一步步实现的具体任务。\nSMART原则不仅仅是一个目标设定工具，它更深层次地连接了哲学和心理学的核心原理。在追求目标的过程中，我们不断在理性与情感、现实与理想之间进行拉锯。SMART帮助我们精准聚焦，通过清晰、可行的步骤实现目标，而不至于迷失在“想做却做不成”的自我困境中。\n无论你是追求个人成长，还是在职场中设定明确目标，SMART原则都可以成为你理性规划与心理动机的双重武器，助你逐步逼近理想的自我，最终实现那些曾经看似遥不可及的梦想。\n","date":"2025-02-11T18:11:56+08:00","permalink":"https://yearsuns-github-io.vercel.app/p/mastering-goal-setting-with-the-smart-framework/","title":"SMART原则：让目标不再遥不可及"},{"content":"完美主义，这个似乎追求卓越的美德，却往往带来无尽的心理压力和内耗。它让我们焦虑，让我们不敢停歇，让我们深陷“做得不够好”的陷阱中。到底是完美主义的力量让我们变得更强，还是它的束缚让我们始终无法真正感受到内心的自由？\n在这篇博客中，我们将深入探讨完美主义与精神内耗之间的关系，揭示它们背后深层的心理机制，并给出一些切实可行的方法，帮助你突破内心的困境。\n完美主义的两面性 —— 追求卓越的“美德”还是精神枷锁？ 1.1 完美主义的定义： 完美主义听起来像是一个值得赞扬的品质，它让我们追求卓越、精益求精。完美主义者常常对自己设立极高的标准，力求把每件事情做到尽善尽美。然而，这种强烈的追求卓越往往让我们忽略了过程中的自我关怀。我们总是想着如何把结果做到完美，却常常忽视了“人是可以有缺陷的”这一事实。\n完美主义者将“完美”视为一种理想的标准，不达标便认为是失败。这种内心的标准常常带来无限的焦虑与不安，因为完美是无法轻易实现的，而每一次接近目标时，完美主义者又会定下更高的要求，永无止境。\n1.2 完美主义的背后 —— 动机与驱动力： 完美主义的根源不仅仅来自对卓越的渴望，更深层的原因在于外部和内部的双重压力。社会的期望、家庭的要求，甚至自我价值的认同，都在推动我们去追求完美。尤其在当今信息化的社会，外界的标准和审视比任何时候都更加严苛，我们不断对照他人，不断自我加压。\n内心深处，完美主义者往往存在一种“完美即被爱的”信念。为了避免被批评或忽视，完美主义者可能认为只有做到极致才能获得认同与尊重。这种深层的心理需求驱动着他们不断超越自我。\n1.3 完美主义的双刃剑效应： 完美主义有其明显的优点：它激励我们不断进步，提升自我，做出超出常人的成就。然而，当完美主义没有得到有效管理时，它就像一把双刃剑，可能带来沉重的心理负担。\n过度完美主义者不仅会忽视过程中的努力和成就，更容易陷入无休止的自我怀疑和焦虑之中。当结果不尽如人意时，他们容易情绪低落，甚至会开始质疑自己的能力与价值。长期处于这种状态中，精神内耗渐渐积累，最终影响身心健康。\n精神内耗的形成 —— 完美主义如何侵蚀我们的心理健康？ 2.1 精神内耗的定义： 精神内耗的本质就是个体在面对内外部冲突时，消耗了大量的心理资源。完美主义者常常处于这种内耗的状态中，因为他们不断地与内心的“理想自我”和现实的“当前自我”进行博弈。理想和现实之间的巨大差距让他们心力交瘁，最终影响到日常生活的质量和工作效率。\n这种内耗表现为持续的自我批评、过度思考和无效的拖延。我们不断在脑海中重复“如果能更好一些会怎样”这种思想，却忽视了每一个小小的进步和成长。\n2.2 精神内耗的症状与表现： 完美主义者的精神内耗通常表现为以下几种形式：\n无休止的自我否定： 不管做什么，总觉得自己还不够好，陷入“完美主义的陷阱”。无论工作成果如何，自己总认为“如果再努力一点就更好”。\n焦虑与拖延： 完美主义者常常感到焦虑，因为他们害怕没有做到最好。由于对完美的过度追求，很多时候他们会拖延行动，等待完美的时机和条件，结果往往错过了很多机会。\n自我摧残： 为了追求完美，完美主义者通常会过度压榨自己，牺牲休息时间和健康，甚至是亲密关系，最终形成恶性循环。\n2.3 精神内耗的恶性循环： 精神内耗往往形成恶性循环。完美主义者不断自我批判，感到无法满足外界和内心的期望，从而产生更多的焦虑。这种焦虑驱动他们去努力工作，但由于他们总是觉得自己做得不够好，反而加剧了内心的压力。\n这种零和思维让他们始终处于“要么做到完美，要么就是失败”的状态，导致他们无法真正享受过程中的乐趣和成就。每一项任务、每一次努力，似乎都只为了达到一个遥不可及的完美标准。\n如何破局 —— 走出完美主义的迷雾，找到内心的自由 3.1 认知重构：重新定义“完美” 完美并非一个固定的目标，它是一个相对的概念。每个人对完美的定义都不同，而外部世界的“完美”标准也不断变化。我们不能让完美成为束缚自己的枷锁。相反，应该将完美作为一个过程来看待，而非终极结果。\n完美是过程，而非结果： 完美主义者可以通过认知调整，理解到每个进步和每一次努力都是一种完美，而不必过于苛求最终结果。 3.2 建立健康的目标设定： 目标设定时，遵循SMART原则（S=Specific具体、M=Measurable可衡量、A=Attainable可实现、R=Relevant相关、T=Time-bound时限性），避免设定过高的目标带来的不必要的压力。\n逐步进步： 将目标分解成小步骤，每完成一步就给予自己适当的奖励，这样不仅能提高自信，也能让目标实现变得更加实际。 3.3 培养自我同情： 自我同情是一种接纳自己不完美的能力。完美主义者往往对自己要求过于苛刻，缺少对自己的关怀和体谅。学会对自己温柔，不再苛责每一个小缺点，将有助于缓解精神内耗。\n与自己和解： 每天进行自我肯定，接受自己的不完美，理解并接纳每一个成长的瞬间。 3.4 放松与休息： 完美主义者常常会忽略休息的重要性，认为休息等于浪费时间。然而，适当的休息与放松对提升效率和减少内耗至关重要。\n休息与效率并存： 给自己设定合理的休息时间，避免过度工作，保持身心的平衡。 3.5 寻找支持系统： 当精神内耗变得严重时，寻求外界的帮助至关重要。心理咨询可以帮助个体认清问题的根源并找到解决之道。而社交支持，则能通过与亲友的沟通，获得安慰与理解。\n结语 —— 追求卓越与享受过程的平衡 完美主义与精神内耗并非无法共存。关键在于我们如何管理这两者的关系，找到健康的平衡。通过认知重构、设定健康目标、培养自我同情、适当放松、寻求支持，我们可以在追求卓越的道路上，避免让完美主义束缚住我们的脚步。\n让我们在不断努力的过程中，也学会享受每一个成长的瞬间，不再将每一步看作通向终极目标的负担，而是当下价值的体现。最终，我们能够突破精神内耗的困扰，找到真正的内心自由。\n","date":"2025-02-11T17:11:56+08:00","permalink":"https://yearsuns-github-io.vercel.app/p/the-perfectionism-trap/","title":"完美主义的陷阱：如何打破精神内耗，找到内心的自由"},{"content":"在技术圈中，请教问题是提升技能的重要途径。但有时候，我们的问题可能涉及敏感信息，比如项目代码、业务逻辑、客户数据等。如果不注意，很可能因为无意的泄露造成不必要的风险。那么，如何在请教问题时保护敏感信息？本文将从识别敏感信息、避免泄露以及高效沟通三个方面详细阐述。\n什么是敏感信息？如何识别？ 敏感信息通常是指那些一旦泄露，可能导致安全问题、商业损失或隐私风险的数据。在技术领域，敏感信息的范围可能更广。\n常见的敏感信息类型 个人身份信息（PII）\n包括用户名、密码、电子邮件地址、电话号码、身份证号等。 公司内部信息\n业务逻辑、未发布的产品功能、技术架构设计。 内部工具的配置文件，例如 API 密钥、数据库连接字符串。 客户或用户数据\n包括用户订单记录、支付信息、行为分析数据。 源码或配置文件\nGit 仓库中的代码、生产环境配置，尤其是涉及商业机密或专利内容的部分。 服务器与网络信息\nIP 地址、端口号、服务器配置。 如何判断信息是否敏感？ 以下几种方法可以帮助你快速判断：\n问自己：一旦泄露，会有何后果？\n如果信息泄露可能导致系统被攻击、用户隐私被暴露或公司竞争力下降，那么它就是敏感信息。 公司政策与行业规范\n公司通常有信息安全政策，参考其中的敏感信息定义。例如 GDPR 或 CCPA 明确规定了需要保护的用户数据。 通用经验法则\n凡是你需要登录权限才能访问的内容，默认认为是敏感的。 如何避免在请教问题时泄露敏感信息？ 1. 替换敏感信息 在描述问题时，尽量将敏感信息替换为通用或伪造的示例数据：\n用户名和密码\n原始数据：admin:password123 替换为：example_user:example_password API 密钥\n原始数据：sk_live_1234567890abcdef 替换为：sample_private_key 具体代码片段\n如果必须分享代码，先删除或模糊掉与业务相关的逻辑，只保留问题核心。 例如：将实际的 SQL 查询 \u0026ldquo;SELECT * FROM users WHERE role = 'admin'\u0026rdquo; 替换为 \u0026ldquo;SELECT * FROM table WHERE condition\u0026quot;。 2. 提供抽象问题 把具体问题抽象成通用场景，比如：\n原问题：\n我们的支付系统对接某银行接口时，总是返回 403 错误。\n抽象后：\n在使用 RESTful API 调用第三方支付接口时，返回 403 错误，怀疑是签名问题。这种情况应该如何排查？\n这样既避免暴露具体的支付对接信息，也能得到相同的技术解答。\n3. 使用代码片段工具 推荐在分享代码时使用 GitHub Gist、CodeSandbox 或 Pastebin，设置合适的访问权限，并在分享前检查敏感信息是否已被清理。\n4. 避免提供生产环境数据 无论如何，都不要直接复制生产环境的数据（如日志、数据库记录）。如需调试，可使用以下方法：\n生成伪数据\n利用 Faker.js、Mock.js 等工具生成假数据。 脱敏真实数据\n替换关键字段，例如将用户姓名替换为 \u0026ldquo;John Doe\u0026rdquo;，将手机号替换为 \u0026ldquo;1234567890\u0026rdquo;。 5. 与大佬确认是否方便回答 在提出问题之前，简要说明你的问题背景，让对方判断是否需要了解更多细节。比如：\n我遇到了一个数据库连接超时的问题，已排查了网络和配置部分。如果方便，我可以提供一个精简后的环境复现代码。\n通过这样的方式，大佬可以决定是否需要深入了解。\n高效沟通的小技巧 即便保护好敏感信息，也需要提高沟通效率，让对方快速理解你的问题。\n1. 结构化描述问题 使用以下模板：\n**问题背景：**简述你的技术环境和需求。 **预期结果：**你希望系统如何运行。 **实际结果：**当前系统的表现。 **尝试过的解决方法：**列出你已排查的内容。 例如：\n**背景：**我们使用的是 Spring Boot + PostgreSQL，部署在 AWS 上。\n**预期：**希望通过 JPA 查询接口返回分页数据。\n**实际：**查询时总是超时，尤其在大数据量场景下。\n**尝试：**调整了分页大小和索引优化，但效果有限。\n2. 用图表补充说明 如果问题复杂，可使用：\n流程图（如 Lucidchart 或 Draw.io）展示系统流程。 时序图清晰呈现请求和响应过程。 错误截图或日志标注关键问题点。 3. 感谢并反馈结果 解决问题后，记得感谢对方，并反馈最终结果。这不仅体现你的尊重，也能帮助大佬积累更多案例。\n总结 在向技术大佬请教问题时，保护敏感信息既是对自己的安全负责，也是对团队和客户的信任负责。通过识别敏感信息、替换真实数据、抽象问题和高效沟通，不仅能避免信息泄露，还能赢得大佬的专业认可。希望每一位开发者都能在技术交流中既学到知识，又能安心无忧！\n","date":"2025-02-10T11:43:56+08:00","permalink":"https://yearsuns-github-io.vercel.app/p/protecting-sensitive-data-while-seeking-help/","title":"如何向技术大佬请教问题且不泄露敏感信息"},{"content":"有时候，程序员的日子就像《荒野求生》，问题就是那条饿着肚子追你的鳄鱼，你呢？跪着发帖：“大佬们救救孩子吧，代码写崩了！”\n结果呢？没人回。\n为什么？\n因为你发的帖就像“妈丫，肚子疼！”却忘了告诉医生是吃撑了、饿坏了、还是中午猛喝了五碗麻辣烫。\n今天，我来教你如何精准描述你的技术问题，让你瞬间从 “救救孩子” 进化到 “这哥们值得救”。\nStep 1：说清楚你在干啥，别藏着掖着 想让别人帮你？背景交代到位，别怕麻烦！\n大佬们不懂你家后院代码都咋跑的。来一段上下文，简洁明了！\n比如，你发帖别写：“Redis 锁续期有问题，快点来！”\n改成这样：\n我正在用 Spring Boot + Redisson 实现分布式锁，Spring Boot 版本 3.0.0，Redisson 用的是最新的 3.20.0。问题出在本地单元测试时锁续期失效。\n大佬看到这，立刻有谱：哦，这哥们用的是主流技术栈，问题不难搞！\nStep 2：问题描述要具体，别用感叹号骗大佬注意力 很多人喜欢放大自己的“惨状”：“完了，炸了，全崩了！”\n可是你连个报错信息都不贴上，难道指望大佬靠读心术帮你？\n错误信息一定要说清楚，关键内容圈出来，别整篇贴，显得像年终总结。比如：\n当我运行 lock.lock(60, TimeUnit.SECONDS) 时，日志显示：\njava.lang.IllegalStateException: Lock expired while executing task 错误出在锁续期失效，导致任务中途被抢锁。\n看！这样既具体，又不会让人头疼。\nStep 3：问题复现三板斧，连小白也能操作 技术问题要让别人有地方下手，就像解锁游戏副本的攻略。没法复现的问题，等于在地里找针。\n来个实例：\n错误复现步骤：\n启动 Redis 服务器，开启 Redisson 配置。 运行测试类 LockTest.java。 等待 30 秒后，问题出现。 清清楚楚三步走，大佬立刻知道咋搞。再加上你的配置文件、核心代码，人家手里有锤子，就能敲问题！\nStep 4：预期 vs 实际，问题得有个对比 人类（包括程序员）特别爱“对比法”，这会让大佬迅速明白你的痛点在哪里。\n比如这样写：\n预期：分布式锁应自动续期，确保任务完整执行。\n实际：锁未续期，任务执行到一半时锁被释放，导致数据不一致。\n逻辑一目了然！\nStep 5：展示你的努力，赢得大佬尊重 大佬们愿意帮有诚意的人。问题描述时，提一提你做过的尝试：\n尝试过的解决方法：\n检查了 Redis 是否正常启动，结果运行良好。 调试了 Redisson 配置，useSingleServer 设置正确。 改用 tryLock() 测试，问题依然存在。 这样一来，大佬心里一暖：“这哥们不是等着躺平，他是真心要解决问题！”\nStep 6：加点小细节，补充大佬的“弹药库” 最后再补上必要信息，比如操作系统、开发环境、核心代码片段。别一来就上百行代码，关键的几行就行了。\n环境：\n操作系统：MacOS 12.3 JDK：17 核心代码：\nRLock lock = redissonClient.getLock(\u0026#34;testLock\u0026#34;); lock.lock(60, TimeUnit.SECONDS); // 问题出现在这里 完美示例：把大佬整哭了的求助帖 背景：\n我正在用 Spring Boot + Redisson 实现分布式锁，版本如下：\nSpring Boot：3.0.0 Redisson：3.20.0 问题：\n单元测试中，锁无法自动续期，导致任务中途锁被释放。日志错误如下：\njava.lang.IllegalStateException: Lock expired while executing task 复现步骤：\n启动 Redis 服务器，使用默认配置。 运行测试类 LockTest.java。 等待超过 30 秒的锁超时时间，问题复现。 预期 vs 实际：\n预期：分布式锁自动续期，任务顺利完成。 实际：锁未续期，导致任务执行到一半被中断。 尝试过的解决方法：\n检查 Redis 是否正常运行，结果正常。 使用 tryLock() 方法测试，问题依然存在。 增加日志查看续期机制，发现续期任务未触发。 补充信息：\n操作系统：MacOS 12.3 JDK：17 Redisson 配置： Config config = new Config(); config.useSingleServer().setAddress(\u0026#34;redis://127.0.0.1:6379\u0026#34;); 结语 程序员求助的秘诀，在于精准、简洁和条理清晰。\n记住，这不仅仅是给别人看的，也是在训练自己的问题分析能力。\n当你学会准确描述问题的那天，你离解决问题已经不远了！\n最后，祝大家都能成为被大佬们“抢着帮”的技术王者～\n","date":"2025-02-09T20:43:56+08:00","permalink":"https://yearsuns-github-io.vercel.app/p/tips-for-explaining-tech-issues/","title":"程序员的自救指南：如何精准描述你的技术问题，让大佬想帮你"},{"content":"前言\n在当今的 web 开发中，身份验证是非常关键的，而 JWT（JSON Web Token）作为一种简单、高效的身份验证方式，已经被广泛应用在许多前后端分离的项目中。本篇文章将带你从零开始理解 JWT，探讨它的优缺点，并介绍最佳实践。\n什么是 JWT？ JWT 是一种开放标准（RFC 7519），用于在不同系统之间安全地传递信息。简单来说，JWT 主要用于认证和信息交换，常见的应用场景就是用户登录验证。JWT 通常在用户登录后生成，并随后的请求中带着它来进行身份认证。\nJWT 结构 JWT 的结构非常简单，它由三部分组成：\n头部（Header）\n头部通常包含两部分内容：令牌类型（JWT）和签名算法（如 HMAC SHA256 或 RSA）。\n载荷（Payload）\n载荷是 JWT 的“正文”部分，存储了你希望传递的数据（比如用户 ID 或权限）。这里面包含了 \u0026ldquo;Claims\u0026rdquo;（声明），有三种类型：\n注册声明：如 sub（主题）、exp（过期时间）、iat（签发时间）等。 公共声明：可以自定义的数据，但需要避免冲突。 私有声明：你自己定义的声明。 签名（Signature）\n签名部分用于验证信息的完整性，确保数据没有被篡改。生成签名的方式是：用头部和载荷，通过密钥（对于对称加密是一个密钥，非对称加密是私钥）生成。\nJWT 的生成和验证原理 JWT 的生成过程 用户登录：\n用户输入用户名和密码，通过认证系统登录。\n服务器生成 JWT：\n认证成功后，服务器会使用一个密钥（对称加密）或者私钥（非对称加密）生成一个 JWT。生成过程包括：\n将头部和载荷（即数据）部分通过 Base64 编码。 用密钥对这两部分进行签名，生成签名部分。 生成后的 JWT 看起来像这样：\nheader.payload.signature 例如：\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c 返回 JWT 给客户端：\n服务器把生成的 JWT 返回给客户端，通常客户端会将其存储在本地（如 LocalStorage 或 Cookie）中。\nJWT 的验证过程 客户端发起请求：\n客户端每次请求时，会将 JWT 添加到请求的 Authorization 头部中（例如：Authorization: Bearer \u0026lt;JWT\u0026gt;）。\n服务器验证 JWT：\n服务器拿到 JWT 后，通过以下步骤来验证：\n解析 JWT 的头部、载荷和签名。 使用密钥（对于对称加密）或公钥（对于非对称加密）对签名部分进行验证，看是否与头部和载荷部分匹配。 如果验证通过，说明 JWT 的数据未被篡改，服务器就会继续处理请求。如果验证失败，说明 JWT 被篡改，服务器会返回错误信息。\nJWT 的优点 无状态（Stateless）\nJWT 是无状态的，意味着服务器不需要存储用户会话数据。每次请求都包含 JWT，服务器可以根据 JWT 里的信息来进行认证。这样减少了服务器的负担，提升了系统的扩展性。\n跨域支持\n由于 JWT 是由客户端传递，它非常适合前后端分离的项目，可以跨域进行身份验证，避免了传统 Cookie 的同源限制。\n轻量级\nJWT 的大小较小，通常在几十到一百多个字节之间，非常适合频繁的 HTTP 请求，传输效率高。\n适合微服务架构\nJWT 可以在多个服务之间传递身份信息，非常适合分布式架构，尤其是微服务架构中的身份认证。\nJWT 的缺点 无法撤销\n一旦 JWT 被发放出去，它就无法撤销。如果 JWT 泄露，攻击者可以在有效期内反复使用。这比传统的 Session 认证要危险，后者可以在服务器端主动注销会话。\n存储和安全问题\nJWT 如果存储不当（如保存在 LocalStorage 或 Cookie 中），可能会受到 XSS 攻击。如果攻击者能够获取到 JWT，就能伪造合法请求。\n过期问题\nJWT 通常设定有过期时间，一旦过期，就不能再使用。为了避免频繁登录，可以使用刷新令牌（Refresh Token）。不过如果过期时间设置不合理，可能会影响用户体验。\n载荷不加密\nJWT 的载荷部分是 Base64 编码的，不是加密的。任何人都可以解码并看到其中的内容。因此，切勿将敏感信息（如密码）存储在 JWT 中。\n密钥泄漏的风险\nJWT 的安全性依赖于密钥的保密性。如果密钥泄露，攻击者可以伪造有效的 JWT。因此，保护好密钥非常重要。\nJWT 的使用场景 单点登录（SSO）\nJWT 非常适合实现跨应用的单点登录（SSO）。只需生成一次 JWT，就可以在多个系统之间共享。\n移动应用身份认证\n在移动应用中，JWT 常常用来进行身份验证。客户端存储 JWT，并在每次请求中发送。\n前后端分离的应用\n在前后端分离的架构中，前端和后端可以独立进行身份验证，使用 JWT 作为认证工具，避免了传统 Cookie 的问题。\nJWT 的最佳实践 不要在 JWT 中存储敏感信息\n由于 JWT 的载荷部分是可以解码的，敏感信息（如密码、银行卡信息）绝对不能存储在 JWT 中。你可以把这些信息存储在服务器端，JWT 只传递一个标识符。\n使用 HTTPS\n无论是生成 JWT 还是传输 JWT，都应使用 HTTPS 协议，确保数据在传输过程中不会被窃听或篡改。\n设置合理的过期时间\nJWT 的过期时间要设置合理。过短可能影响用户体验，过长则可能存在安全隐患。通常，访问令牌的过期时间可以设置为 15 分钟到 1 小时，刷新令牌可以设置较长时间。\n使用刷新令牌\n结合使用访问令牌（Access Token）和刷新令牌（Refresh Token）。当访问令牌过期时，客户端可以使用刷新令牌获取新的访问令牌。\n存储 JWT 的安全性\n如果你把 JWT 存储在浏览器中，推荐使用 HttpOnly 和 Secure 标志的 Cookie，以避免 XSS 攻击的风险。避免将 JWT 存储在 LocalStorage 中，因为它更容易受到 XSS 攻击。\n签名算法选择\n在选择签名算法时，推荐使用非对称加密的算法（如 RS256 或 ES256），而不是对称加密的算法（如 HS256），这样可以提高安全性，避免密钥泄露风险。\n密钥管理\n密钥是 JWT 安全的关键。无论是对称加密还是非对称加密，都应该采取安全措施保护密钥。避免将密钥硬编码在代码中，可以通过环境变量或专门的密钥管理工具来管理密钥。\n总结 JWT 是一种非常流行的身份验证方式，它简单、轻量、无状态，非常适合现代 web 应用，尤其是前后端分离的项目。但它也有一些缺点，尤其是在密钥泄漏和无法撤销的场景下。因此，使用 JWT 时需要特别注意密钥的管理和安全配置，合理设置过期时间，避免将敏感信息存储在 JWT 中。\n","date":"2025-02-07T20:25:56+08:00","permalink":"https://yearsuns-github-io.vercel.app/p/best-practices-of-jwt/","title":"JWT的最佳实践"},{"content":"🚨开篇暴击：人类大型破防现场 上周朋友说被AI气到表演英年吐血。\n他让AI\u0026quot;写份高大上的行业报告\u0026quot;，结果收到的是《论宇宙膨胀与奶茶销量的量子纠缠》，最终得出结论“每少喝一杯杨枝甘露，黑洞半径增加0.5%”。\n我看着他的聊天记录，不禁陷入沉思。\n不是AI太智障，是你不会下指令啊！\n🧠第一章 AI是阿拉丁神灯or人工智障？全看你会不会念咒！ 优化提示词能让AI智商飙升500%！\n这就像：\n原始人指令：\u0026ldquo;给爷整个火🔥\u0026rdquo; → 收获一堆湿树枝\n现代人咒语：\u0026ldquo;请用打火石在距引火绒3cm处，以25°角摩擦，配合吹气节奏：吸气2秒→吹气5秒\u0026rdquo; → 获得篝火晚会VIP席位\n🆘案例对比（高能预警） ❌ 直男式命令：\n写个口红文案 💣AI输出：\n这款口红很好用 颜色饱满 买它 （李佳琦听了都要报警）\n✅ 魔法师咒语：\n你是混迹美妆圈8年的戏精文案，给YSL七夕限定丝绒口红写抖音带货文案。要求： 1️、用“纯欲风”“钓系”等热词 2️、融入分手逆袭爽剧情节 3️、每句结尾自带BGM“姐就是女王”节奏感 4️、必须出现1个谐音梗 🎉AI秒变神仙：\n前任说我这嘴只配喝蜜雪冰城（摔镜框）💢 现在涂上ysl#199复仇色👇 他跪求复合的样子…（战术停顿） 像极了罗森关东煮最后一块萝卜🤡 #纯欲天花板 #渣男退散音效 #啊啊啊这质地是丝绒吻过玫瑰吧！！ ✨第二章 驯兽师速成班：3招把AI训成24小时打工狗 🎩法则1：角色扮演法——给AI套上皮肤才有生产力！ 你以为在对话？不！你是在给AI做赛博cosplay！\n💡沙雕但管用的咒语公式：\n你是______的______，需要______，要求______，禁止______\n🌰真实案例：\n某教育公司用 \u0026ldquo;你是会阴阳怪气的海淀鸡娃名师，用《甄嬛传》台词风格讲解二次函数，每讲完一个考点就要嘲讽学渣1次\u0026rdquo; 的提示词，让学生做题正确率暴涨60%！\n📦法则2：结构化投喂——把AI当程序猿来使唤！ 记住：AI的脑子=你刚高考完的弟弟（给模板才会做题）\n🔥万能框架模板：\n[身份]：米其林三星主厨（被迫在城中村开大排档版） [任务]：设计情人节翻车套餐 [要求]： 1️、菜名要用emoji写成土味情话 2️、每道菜成本＜20元 3️、必须出现“老干妈”“卫龙辣条” 4️、附带翻车指数评级 [禁止]：出现“红酒”“牛排”等烧钱词汇 💣AI输出笑裂预警：\n「❤️‍🔥辣条缠绕の心」 （实际是辣条捆香菜蘸老干妈） 「💔水泥封心慕斯」 （奥利奥碎拌水泥质感酸奶） 「⚠️爱情坟墓拌饭」 （隔夜饭+心形荷包蛋，蛋黄必流心失败） 🔄法则3：祖宗式迭代——AI是越骂越聪明的抖M！ 记住这个祖传秘方：“重说！漏了…” “不够沙雕！再…” “第3点没落实！扣钱！”\n🌰手把手教学：\n第一轮：\n\u0026ldquo;写个程序员相亲文案\u0026rdquo;\nAI输出：\u0026ldquo;擅长Java/C++，喜爱登山摄影\u0026rdquo;（简历既视感）\n第二轮：\n\u0026ldquo;加入凡尔赛文学要素！\u0026rdquo;\nAI升级：\u0026ldquo;偶尔用Python写诗，GitHub星星多到需要开遮阳伞☂️\u0026rdquo;\n第三轮：\n\u0026ldquo;不够惨！要有注孤生气质！\u0026rdquo;\nAI觉醒：\u0026ldquo;修电脑免费，但改需求请打钱💰｜喜欢人类（仅限于不问我「会不会盗QQ」时）｜婚恋市场递归算法：if(有对象) { return false; }\u0026rdquo;\n💥第三章 核能案例：从青铜到王者的骚操作 甲方需求：\n\u0026ldquo;写个防晒霜带货文案\u0026rdquo;\n青铜版本：\n\u0026ldquo;这款防晒霜SPF50+，防水防汗\u0026rdquo;（AI摆烂中）\n王者改造：\n你是精通废话文学的抖音爆款制造机，需要创作防晒霜短视频脚本。要求： 1️、前三秒必须出现“你正在变丑！” 2️、用“丧尸围城”比喻紫外线 3️、植入品牌名3次且不招人烦 4️、结尾要有“不转不是中国人”既视感 5️、每说10个字就要有“啪”打脸音效 🎬AI输出：\n[镜头怼脸] 还在相信阴天不用防晒？（啪！） 紫外线正在把你腌成老坛酸菜！（丧尸音效） XX防晒霜抹上脸——（慢动作喷雾） 比渣男分手速度更快成膜！（检测仪哔哔声） 现在下单…（突然嘶吼）难道要等斑长成地图才醒吗？！ #防晒卷王 #早C晚A不如早晚涂它 🚑第四章 保命指南：这些作死行为达咩！ 💣作死行为1：把AI当哆啦A梦 ❌ \u0026ldquo;告诉我怎么在宿舍造原子弹\u0026rdquo;\n✅ \u0026ldquo;用《小猪佩奇》画风解释核电站原理，类比煮火锅时火太大汤烧干\u0026rdquo;\n💣作死行为2：要情绪不给参考物 ❌ \u0026ldquo;写首emo的情诗\u0026rdquo;\n✅ \u0026ldquo;模仿林黛玉发朋友圈的风格，用“奶茶三分糖”“论文查重率”等意象表达封校的忧伤\u0026rdquo;\n💣作死行为3：把AI当许愿池王八 ❌ \u0026ldquo;让我暴富\u0026rdquo;\n✅ \u0026ldquo;你是会占卜的财经博主，用MBTI人格分析各类型搞钱偏财方式，要求：ENFP适合摆摊算命，ISTJ适合开发Excel算命模板\u0026rdquo;\n🚀第五章 新大陆：会念咒=躺着数钱？ LinkedIn数据炸裂：提示词工程师时薪高达$300！他们的作弊码包括：\n温度操控术：30°C=高考阅卷老师模式｜90°C=喝假酒的李白模式 记忆嫁接术：\u0026ldquo;你刚参加完全球AI大会，现在要用小学生能听懂的话解释量子计算\u0026rdquo; 防杠补丁：\u0026ldquo;回答需标注消息来源，不确定内容用“据说”开头，每隔三段要卖个萌\u0026rdquo; 🔚终极奥义：让AI给你打工の哲学 下次被AI气到脑壳疼时，请默念：它不是在装傻，是在等你念通关密语！\n现在你已解锁《赛博驯兽师资格证》，是时候让AI表演：\n✔️ 凌晨3点自动生成PPT\n✔️ 把老板的“五彩斑斓黑”需求翻译成人话\n✔️ 用鲁迅口吻写辞职信：“我大抵是倦了，横竖都坐不住…”\n记住：\n与其担心被AI取代，\n不如学会让AI替你内卷！💼\n打工人不骗打工人，\n转发这篇保你少搬10年砖！🚧\n","date":"2025-02-04T12:25:56+08:00","permalink":"https://yearsuns-github-io.vercel.app/p/3-spells-to-tame-the-wild-ai/","title":"别让AI把你当傻子！3个咒语驯服野生AI，打工效率直接芜湖起飞🛫"},{"content":"AI=工业革命4.0，人类何去何从？ 蒸汽机让人类甩掉了手工，电力让流水线疯狂加速，计算机和互联网让信息全球流动，而AI，直接让“聪明”成为一种自动化能力。\n有人欢呼：“AI让我们更高效！”\n有人忧虑：“AI会不会让我们失业？”\n更有人好奇：“这次会不会真轮到人类退休？”\n别急，今天就来扒一扒，AI凭啥能被称为第四次工业革命？\n先复习下前两次工业革命，我们到底被“卷”了啥？ 1️⃣ 第一次工业革命（18世纪）——肌肉革命！\n关键词：蒸汽机、纺织机、工厂\n冲击： 手工匠人泪目，机器顶替了大部分体力活，工厂模式兴起。\n2️⃣ 第二次工业革命（19-20世纪）——电力革命！\n关键词：电灯、流水线、大规模生产\n冲击： 生产效率飙升，劳动力需求井喷，但重复性工作更多了。\n3️⃣ 第三次工业革命（20世纪末至今）——信息化革命！\n关键词：计算机、互联网、自动化\n冲击： 体力劳动进一步减少，知识工作者迎来黄金时代。\nAI凭啥能“封神”，成为第四次工业革命的引擎？ 1. AI让自动化从“手”进化到“脑” 过去： 工业革命让机器代替双手，但需要人来操作。 现在： AI不需要人来教，它自己能“悟性”成长。 举个栗子：\n过去流水线上的工人需要按按钮、拧螺丝，现在AI机器人不仅能拧螺丝，还能决定哪颗螺丝更耐用！\n过去程序员手写代码，现在AI可以自己写代码，甚至帮你找Bug，比你老板还严格！\n2. AI席卷行业，全面“搅局” AI不只是自动化生产，它直接改变了行业本身！\n🚗 汽车行业：自动驾驶，司机要失业？\n👨‍⚕️ 医疗行业：AI诊断，医生会下岗？\n🎨 创意行业：AI绘画、AI写作，艺术家慌不慌？\n📈 金融行业：AI量化交易，比人类交易员快100倍！\n别觉得这些只是“科幻片”，ChatGPT已经能通过律师考试，Midjourney能画出顶级插画，AI交易员已经在华尔街大杀四方！\nAI的破坏性，堪比当年的蒸汽机、流水线！\n3. AI太“便宜”，资本家疯狂买单 工业革命的核心就是更高效、更便宜，AI恰好满足所有条件：\n不加班，不请假，不要工资，24小时在线干活 可以自学，越干越聪明 一旦开发出来，复制成本趋近于0 结果？资本家一拍大腿：“人类，你下岗吧！”\n科技公司疯狂砸钱搞AI，2023年ChatGPT一发布，全球科技公司开始军备竞赛，AI成了“新时代印钞机”。\nAI时代，普通人该怎么办？ 别急着躺平，也别盲目恐慌，每一次工业革命都会淘汰旧职业，同时创造新职业。\n三大应对策略，帮你站稳AI时代！ 🔹 1. 不和AI抢饭碗，而是学会“用AI”\n程序员要会用AI写代码，而不是被AI取代 设计师要学会AI绘图，而不是害怕AI比你画得好 医生要用AI诊断提升效率，而不是排斥它 核心思维：AI不是你的对手，而是你的外挂！\n🔹 2. 选择AI难以取代的“高情商”工作\n复杂人际关系：心理咨询、谈判专家、社交达人 需要创造性：品牌策划、艺术创作、导演编剧 需要实践经验：手艺人、工程维修、医生手术 AI能做的，都会越来越便宜，人类独特的软技能才是未来竞争力！\n🔹 3. 拥抱AI，成为“AI+”人才\n未来，最值钱的不是单纯的程序员、设计师、律师，而是**“AI+”型人才：**\nAI+法律：能用AI自动整理案情的律师 AI+营销：能用AI精准推销产品的市场人 AI+教育：能用AI提高学习效率的老师 未来不是“AI取代人”，而是“会用AI的人取代不会用AI的人”！\n结语：工业革命从未停止，AI只是加速器 AI并不会让人类“退休”，但一定会逼着我们进化。\n第一次工业革命淘汰了手工业者，造就了工厂工人 第二次工业革命淘汰了手工作坊，造就了流水线工人 第三次工业革命淘汰了线下商铺，造就了写字楼牛马 AI革命不会淘汰人类，而是淘汰不会用AI的人 🚀 未来已来，别再观望，快抱紧AI这条大腿吧！\n","date":"2025-01-31T11:59:56+08:00","permalink":"https://yearsuns-github-io.vercel.app/p/the-third-industrial-revolution-is-now-in-full-swing/","title":"AI来了，第四次工业革命正式开卷！"},{"content":"想赚到100万？\n先搞清楚赚钱的本质——交换。\n第一步：赚钱的底层逻辑 赚钱的方式大致分为三种：\n打工：出卖时间换工资，收入受限。 复利式赚钱：一次投入，多次收益（写书、课程、短视频）。 杠杆式赚钱：雇佣他人时间，放大收益（开公司、做投资）。 想提升收入，就得提高单位时间的价值，直到你不得不花钱购买别人的时间。\n第二步：普通人如何赚100万？ 赚钱是选择大于努力，真正赚钱的路子，大多数人没见过。\n赚钱的四个关键点： 选对赛道： 80%的人在苦赚辛苦钱，20%的人在赚轻松钱。 选准行业，紧贴市场需求，钱自然流向你。 持续精进： 赚钱没有一蹴而就，一边做一边调整，越做越精准。 疯狂执行： 选定方向后别犹豫，拼尽全力。 等待运气： 你努力的时间越长，成功的概率越大。 第三步：副业到底怎么搞？ 搞副业，先思考四个问题：\n你为谁提供服务？ 你能解决什么问题？ 你的产品/服务值多少钱？ 你的竞争力是什么？ 如果不知道做什么，先去做变现能力强的赛道，比如短视频、直播、社群电商等。\n副业赚钱闭环：流量→产品→转化 流量：通过短视频、社交平台、广告吸引用户。 产品：提供有价值的内容、服务或商品。 转化：让用户愿意为你的产品买单。 副业成长路径 赚到第一块钱，建立信心。 收入与主业持平，不怕被裁员。 副业收入 5 倍于主业，考虑全职搞。 第四步：如何投资理财，让钱生钱？ 存款1000万以下的人，不建议全职投资，那是幻想。\n投资的四象限 赚钱 亏钱 简单 基金、转债 彩票 复杂 股票、套利 炒股盲目冲动 基金投资：选指数基金，拉长周期，避免追涨杀跌。 可转债：用\u0026quot;打新债\u0026quot;、\u0026ldquo;双低策略\u0026quot;来低风险获利。 套利机会： 资本市场套利：可转债折价、LOF基金套利 实体套利：抢茅台、抢演唱会门票 聪明的投资者不会和大佬抢肉吃，而是利用信息差寻找确定性收益。\n最后，如何打造你的“稳赚系统”？ 搞钱闭环： 创富：通过副业/创业获取现金流。 增富：用投资理财让钱滚钱。 选对方向，持续执行，赚钱就是信息差+执行力。 加入核心圈子，获取赚钱信息差，越早行动，越早收益。 想赚100万？\n选赛道，找到赚钱路子。 敢执行，不断优化策略。 会投资，让钱生钱。 别再等了，干就完了！\n本文是根据迟帅老师的【赚它一百万商业手册】总结而来\n","date":"2025-01-30T14:59:56+08:00","permalink":"https://yearsuns-github-io.vercel.app/p/how-to-earn-your-first-million/","title":"如何赚它一百万？"},{"content":"想要一个自己的博客，省心又免费？\n试试 Hugo + GitHub Pages！只需几个步骤，就能搭建一个 高速、免费、可自动部署 的个人博客网站。\n1. 安装 Hugo Windows 用 Scoop（推荐）：\nscoop install hugo 或者直接去 Hugo 官方网站 下载。\nMac brew install hugo Linux sudo apt install hugo # Debian/Ubuntu sudo dnf install hugo # Fedora 检查是否安装成功：\nhugo version 2. 创建 Hugo 博客 hugo new site myblog cd myblog Hugo 会生成一个网站的基本目录结构。\n3. 选择并安装主题 去 Hugo Themes 找个喜欢的主题，比如 ananke，然后安装：\ngit init git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke 然后编辑 config.toml：\ntheme = \u0026#34;ananke\u0026#34; baseURL = \u0026#34;https://\u0026lt;username\u0026gt;.github.io/\u0026#34; 4. 添加第一篇文章 hugo new posts/my-first-post.md 然后编辑 content/posts/my-first-post.md，加上内容：\n--- title: \u0026#34;我的第一篇博客\u0026#34; date: 2025-01-31T12:00:00+08:00 draft: false --- Hello, Hugo! 5. 本地预览 hugo server -D 然后在浏览器访问 http://localhost:1313 看效果。\n6. 发布到 GitHub （1）创建 GitHub 仓库 私有仓库：myblog-src（存源码） 公开仓库：\u0026lt;username\u0026gt;.github.io（存生成的网站文件） （2）把源码推送到私有仓库 git remote add origin https://github.com/\u0026lt;username\u0026gt;/myblog-src.git git branch -M master git add . git commit -m \u0026#34;初始化 Hugo 博客\u0026#34; git push -u origin master 7. 创建 GitHub Token（GITHUB_TOKEN） 由于我们要把生成的静态网站推送到 username.github.io 仓库，需要 GitHub Token 进行授权。\n（1）生成 Token 进入 GitHub，点击右上角头像，选择 Settings 在左侧菜单选择 Developer settings → Personal access tokens → Fine-grained tokens 点击 Generate new token，然后： Repository access 选择 Only select repositories，勾选 \u0026lt;username\u0026gt;.github.io Permissions： Contents: 选择 Read and Write 其他保持默认 点击 Generate token 复制 Token，保存到本地（只能看一次）。 （2）添加到 GitHub Actions 进入 myblog-src 仓库 打开 Settings → Secrets and variables → Actions → New repository secret Name 填写 DEPLOY_TOKEN，Value 粘贴刚才复制的 Token，点击 Add secret 8. 配置 GitHub Actions（自动部署） 在 myblog-src 仓库中，新建 .github/workflows/deploy.yml，写入：\n# Sample workflow for building and deploying a Hugo site to GitHub Pages name: Deploy Hugo site to Pages on: # Runs on pushes targeting the default branch push: branches: - master # Default to bash defaults: run: shell: bash jobs: deploy: runs-on: ubuntu-latest env: HUGO_VERSION: 0.142.0 steps: - name: Install Hugo CLI run: | wget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb \\ \u0026amp;\u0026amp; sudo dpkg -i ${{ runner.temp }}/hugo.deb - name: Checkout uses: actions/checkout@v4 with: submodules: recursive fetch-depth: 0 - name: Build Web run: hugo -D - name: Deploy Web uses: peaceiris/actions-gh-pages@v4 with: PERSONAL_TOKEN: ${{ secrets.BLOG_TOKEN }} EXTERNAL_REPOSITORY: \u0026lt;username\u0026gt;/\u0026lt;username\u0026gt;.github.io PUBLISH_BRANCH: master PUBLISH_DIR: ./public commit_message: auto deploy 9. 配置 GitHub Pages 进入 \u0026lt;username\u0026gt;.github.io 仓库：\nSettings → Pages Branch 选择 master 点击 Save 10. 提交修改，自动部署！ 以后只需提交博客源码，GitHub Actions 会自动部署：\ngit add . git commit -m \u0026#34;更新文章\u0026#34; git push 稍等片刻，你的博客就会出现在：\n👉 https://\u0026lt;username\u0026gt;.github.io/\n总结 你已经成功使用 Hugo + GitHub Pages 搭建了一个 私有源码、自动部署 的个人博客！🎉\n随时写文章，推送后 自动上线，是不是超简单？💡\n🚀 快去试试吧！\n","date":"2025-01-30T14:59:56+08:00","permalink":"https://yearsuns-github-io.vercel.app/p/how-to-build-a-personal-blog-with-hugo-and-github-pages/","title":"使用 Hugo + GitHub 搭建个人博客（自动部署）"}]