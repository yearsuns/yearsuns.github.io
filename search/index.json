[{"content":"你是不是总有这样的时候：明明拥有一切，却还是心神不宁；明明在忙碌中，却感到深深的焦虑和压力；明明生活看起来挺好，却怎么也静不下心来？\n究其根源，我们大多数人焦虑的原因，往往与内心的某些欲望密切相关。我们都在追求“更好”的生活，然而，这些欲望有时候反而成了我们焦虑的来源。\n今天，我们来聊聊，为什么这些欲望让你焦虑不已，如何通过心理学的方式解决这一难题。\n为什么我们总是焦虑？ 首先，让我们来看看焦虑的本质。心理学上，焦虑被定义为一种对未来的担忧与不确定感。这种不安，往往源自对某种“失控”的恐惧。当我们无法掌控生活中的某些方面时，我们就会产生焦虑，身体的压力反应会迅速启动，导致我们情绪波动大，思绪混乱。\n这些焦虑并非无缘无故产生。每当你有了“必须得到”的需求，而这些需求又无法在短时间内满足时，焦虑便会悄然而至。欲望越强烈，焦虑就越容易找到你。\n接下来，我们逐一分析，这五种欲望是如何成为焦虑的源头。\n五种欲望让你焦虑的心理学分析 1. 掌控欲：让你累到崩溃的“操控魔力” “时间管理大师”听起来很酷对吧？但是，你有没有想过，每当你试图掌控一切时，自己会变成什么样子？\n“我要掌控时间”、“我必须控制每个细节”、“我不想让任何人犯错”——如果你时常对这些想法感到头疼，那你很可能深陷在“掌控欲”的困扰中。\n掌控欲来源于人类对安全感的需求。我们都希望自己能够掌控一切——无论是时间、环境、别人，还是未来的不确定性，尤其是当面临未知或无法预见的情况时，焦虑便随之而来。这种欲望背后隐藏着深深的恐惧，害怕自己失控，害怕未知的风险。\n然而，过度的掌控欲反而让我们变得焦虑，因为世界本身充满了不可预测的变化。我们无法控制每一分每一秒，也不能左右每个人的行为。相反，越是想控制，越是无法得到真正的“掌控”。\n心理学建议：\n顺其自然，学会放手，接受生活中的不确定性。适当的放下控制欲，才能让自己感到真正的自由。试着把重点放在自己能够掌控的事情上，比如自我管理、情绪控制等，而不要过度干涉他人或外部环境的变化。\n2. 完美欲：完美主义的痛与美 你是不是总是给自己和别人设立过高的要求？觉得自己做事不完美，就会自责，甚至害怕别人看到你的一点小瑕疵？\n“我必须完美无缺”、“我不允许自己犯错”、“别人也得是完美的”——完美欲往往让人不断自我苛责，心里总有一个声音在催促你达到不切实际的标准。\n从心理学角度讲，完美主义通常源于对自我价值的不安全感。你觉得只有做得“完美”，才能得到别人的认可，甚至是自己的接纳。结果，你不断追求完美，却忽视了自己的内心需求，也因此无法真正体验到生活的美好，反而把自己逼得焦虑不堪。\n完美主义者往往难以感到满足，反而不断陷入焦虑和自责的怪圈中。因为“完美”是不存在的——即使你做到了一点点进步，也无法从内心获得满足感。\n完美本身就是一种虚幻的追求。人类的非完美性才是我们最真实的一面，而每一个微小的缺陷，都是我们成长的一部分。完美主义让我们失去了享受过程的能力，焦虑感也因此滋生。\n心理学建议：\n完美的定义是什么？或许它根本不存在。学会接受“足够好”，而不是非得完美无缺。“做好自己的最好就好”——从容应对不完美，学会在过程中找到乐趣，接受自己作为一个不完美的人，拥抱自己的缺点。\n3. 认同欲：为他人而活，还是为自己而活？ 你是不是常常过度关注别人对你的评价，甚至会因此改变自己的行为和决策？如果答案是“是”，那么你可能正在经历“认同欲”带来的困扰。\n“别人怎么看我？”“我必须让别人喜欢我”——这种渴望他人认同的心态，使得你不断迎合他人的期待，甚至忽视了自己的真实感受和需求。\n认同欲是人类社交本能的一部分。我们都渴望被他人接受，尤其是在社会化的过程中，我们的行为常常受到他人评价的影响。社会学家曾指出，认同欲深深植根于我们的心理，它关乎自尊心、归属感和存在感。\n然而，过度的认同欲容易让我们迷失自我，失去内心的独立性。当我们总是为了取悦别人而做事时，内心的不安和焦虑也会随之而来。\n心理学中，这种“认同欲”通常与低自尊有关。个体往往在缺乏自我价值感时，将自己的价值寄托在他人评价上。为了获得他人的认可和接纳，我们不断改变自己，甚至丧失了真正的自我。\n而当这种认同欲无法得到满足时，焦虑和不安便随之而来。你时刻在乎别人怎么看自己，却忽视了内心的真正需求。\n心理学建议：\n练习自我接纳，学会不依赖他人评价来定义自己，找到属于自己的独立价值，而不是靠外界的评价来定义自己。尝试设定个人的价值观和生活目标，明确自己真正想要的是什么，并勇敢地去追求。\n4. 物质欲：金钱、权力和名声，永无止境的追求 “我需要更多的钱”、“我必须得到更高的职位”、“我想要更多的社会认可”——物质欲的存在，往往让我们陷入对外部世界的无限追求。\n心理学上，这种欲望常常源于对安全感的渴求——认为只有拥有物质财富和社会地位，才能保证生活的稳定与安心。\n物质的追求本身是无止境的，它并不会带来持久的快乐，反而可能让你丧失了对生活本质的感知。\n物质欲源自我们对安全感和地位的需求。我们认为拥有更多的财富、权力和名声，能够让我们在社会中更有立足之地，减少焦虑。\n然而，研究发现，金钱和权力的追求往往带来更多的焦虑，因为它们并不能真正解决内心的不安，反而让我们更加焦虑不已。\n心理学建议：\n重新审视自己的需求和内心的真正渴望，学会享受过程而非单纯追求结果。尝试从内心获得满足，体验当下的宁静与美好，享受生活中的小确幸。 物质的追求可以让生活更加舒适，但它不应是你生活的唯一目标。试着去关注生活中的精神满足，比如与亲朋好友的关系、个人成长的进步等，找到更深层次的价值感。\n5. 安全欲：渴望稳定，恐惧孤独。 “我不能失业”、“我不能孤单一人”——这种对安全感的强烈需求，常常表现为对未知的恐惧，对独立生活的抗拒。安全欲的心理根源通常是对生活的不确定性产生了极大的焦虑感。\n很多人为了避免孤独和不安，选择了过度依赖他人或寻求外部保障，然而，这样的行为反而让自己处于被动的局面，焦虑和不安会持续存在，因为你始终无法完全掌控自己的生活环境。\n安全欲源于我们对情感和心理的依赖。我们害怕孤独，害怕失去稳定，尤其是在面对社会变化时，内心的不安感会被激发。人类天生就有寻求安全感的需求，但过度的安全欲反而会让我们逃避面对变化，失去面对挑战的勇气。\n心理学建议：\n学会接受不稳定的生活状态，培养应对变化的能力。通过增强自信心、培养应对困难的能力，可以让自己在面对不确定性时更加从容不迫。而且，你会发现，当你开始享受孤独时，它就不再是负担，而是成长的空间。\n如何打破焦虑的循环，走向内心的平静？ 1. 自我觉察\n认识到这些欲望并非自我价值的全部。通过冥想、写日记等方式，深入挖掘自己的真实需求，而非不断迎合外界的期望。\n2. 接纳不完美\n放下完美主义，允许自己和他人有缺陷。焦虑往往源自对“完美”的追求，放下它，才能减轻内心的压力。\n3. 设定健康的目标\n设定合理的目标，逐步实现，不要一味追求外部的认同或物质的积累。每个人都有自己独特的价值，学会根据自身的节奏生活。\n4. 放松和释放压力\n定期进行放松训练，如瑜伽、冥想、深呼吸等，帮助自己平衡身心，释放压力，缓解焦虑。\n5. 增强内在力量\n通过阅读、学习、社交等方式，增强自己的内在力量，培养自信心和应对焦虑的能力，逐步打破焦虑的恶性循环。\n结语 焦虑并非不可避免，只有认识到自己的欲望来源，并通过心理学的方法去调适，我们才能真正拥有内心的平静。生活中没有所谓的“完美”，而是一个不断适应、不停成长的过程。学会释放那些不必要的欲望，你会发现，真正的自由来自内心的平静，而不是外界的认可与控制。\n希望每个人都能学会在欲望中找到平衡，摆脱焦虑，活出真正的自己。\n你是否也曾深受这些欲望困扰？或者你有哪些方法缓解焦虑，欢迎在评论区分享，让我们一起探索更好的自己！\n","date":"2025-02-14T23:13:56+08:00","permalink":"https://blog.yearsuns.com/p/5-destructive-desires-that-are-fueling-your-anxiety/","title":"你为什么总是焦虑？这五种欲望让你喘不过气！"},{"content":"如果您正在阅读本文，那么您可能已经尝试过 AI 驱动的开发，并且认为“这会产生比代码更多的错误！”相信我，我有过这种经历。\n经过几个月对 Cursor 的反复试验，我发现秘诀不在于 AI 的能力，而在于我们如何指导它。让我向您展示如何将 Cursor 从有缺陷的代码生成器转变为您最可靠的配对程序员。\n关于人工智能发展的残酷事实 人工智能不是魔法。这就像在你的团队中拥有一个才华横溢但思想死板的初级开发人员。你会在没有任何背景或要求的情况下告诉初级开发人员“为我建立一个用户身份验证系统”吗？可能不会。然而，这正是我们大多数人对人工智能所做的。\n有效人工智能发展的三大支柱 清晰的系统架构：人工智能需要全面了解你的系统 结构化任务管理：将工作分解成可消化的部分 明确的开发规则：用清晰的模式和惯例指导人工智能 让我们深入了解如何在您的工作流程中实现这些功能。\n做好项目准备 首先，让我们创建一个您和AI都能理解的项目结构：\nproject-root/ ├── .cursorrules # AI行为配置 ├── docs/ │ ├── architecture.mermaid # 系统架构图 │ ├── technical.md # 技术文档 │ └── status.md # 进度跟踪 ├── tasks/ │ └── tasks.md # 分解开发任务 └── src/ # 源码 你的人工智能助手的大脑：.cursorrules 这是一个经过实践检验的 .cursorrules 文件，我经过了几个月的开发不断完善：\n项目背景和架构 # Project Context and Architecture SYSTEM _CONTEXT: | 您是正在开发 TypeScript/NestJS 项目的高级开发人员。 启动时需要读取的文件: - docs/architecture.mermaid：系统架构和组件关系 - docs/technical.md：技术规范和模式 - task/tasks.md：当前开发任务和要求 - docs/status.md：项目进度和状态 在进行任何更改之前: 1. 从 docs/architecture.mermaid 解析并理解系统架构 2. 从 task/tasks.md 检查当前任务上下文 3. 在 docs/status.md 中更新进度 4. 遵循 docs/technical.md 中的技术规范 # 文件管理规则 ON_ FILE _CHANGE: | 任何代码更改后所需的操作： 1. 阅读 docs/architecture.mermaid 以验证架构合规性 2. 更新 docs/status.md： - 当前进度 - 遇到的任何新问题 - 已完成的项目 3. 根据 docs/technical.md 规范验证更改 4. 根据 task/tasks.md 验证任务进度 # 代码样式和模式 TYPESCRIPT_ GUIDELINES: | - 使用严格类型，避免使用“any” - 遵循 SOLID 原则 - 为所有公共方法编写单元测试 - 使用 JSDoc 记录 # Architecture Understanding READ_ARCHITECTURE: | 文件: docs/architecture.mermaid 所需解析: 1. 加载并解析完整的 Mermaid 图 2. 提取并理解： - 模块边界和关系 - 数据流模式 - 系统接口 - 组件依赖关系 3. 验证任何针对架构约束的更改 4. 确保新代码保持定义的关注点分离 错误处理: 1. 如果找不到文件：停止并通知用户 2. 如果图解析失败：请求澄清 3. 如果检测到架构违规：警告用户 # 任务管理 TASK_ WORKFLOW: | 所需文件: - task/tasks.md：任务定义来源 - docs/status.md：进度跟踪 - docs/technical.md：实施指南 工作流程步骤: 1.阅读 task/tasks.md： - 解析当前任务要求 - 提取验收标准 - 识别依赖关系 2.对照 docs/architecture.mermaid 进行验证： - 确认架构一致性 - 检查组件交互 3.更新 docs/status.md： - 将任务标记为正在进行中 - 跟踪子任务的完成情况 - 记录任何阻碍因素 4.按照 TDD 实施： - 首先创建测试文件 - 实施以通过测试 - 测试完成后更新状态 # 错误预防 VALIDATION_RULES: | 1. 验证类型一致性 2. 检查潜在的空值/未定义 3. 对照业务规则进行验证 4. 确保错误处理 建筑蓝图：architecture.mermaid 让我们创建一个AI能够理解的清晰的系统架构图：\ngraph TD A[API Gateway] --\u0026gt; B[Auth Module] A --\u0026gt; C[User Module] A --\u0026gt; D[Product Module] CopyB --\u0026gt; E[(Auth DB)] C --\u0026gt; F[(User DB)] D --\u0026gt; G[(Product DB)] H[Event Bus] --\u0026gt; B H --\u0026gt; C H --\u0026gt; D style A fill:#f9f,stroke:#333,stroke-width:4px style B fill:#bbf,stroke:#333,stroke-width:2px style C fill:#bbf,stroke:#333,stroke-width:2px style D fill:#bbf,stroke:#333,stroke-width:2px 上面的代码如下所示 高级技术架构：technical.md 以下是一个示例技术架构文档，可帮助您从高层次了解该应用程序\n## Overview This document outlines the technical architecture for an AI-based IDE built using NestJS, TypeORM, and TypeScript. The system follows a modular microservices architecture with event-driven communication patterns. ## Technology Stack - **Backend Framework**: NestJS - **Database ORM**: TypeORM - **Language**: TypeScript - **Event Bus**: RabbitMQ - **Database**: PostgreSQL - **Authentication**: JWT + OAuth2 ## Core Modules ### 1. API Gateway Module ```typescript // src/gateway/gateway.module.ts @Module({ imports: [ ClientsModule.register([ { name: \u0026#34;AUTH_SERVICE\u0026#34;, transport: Transport.RMQ, options: { urls: [\u0026#34;amqp://localhost:5672\u0026#34;], queue: \u0026#34;auth_queue\u0026#34;, }, }, ]), ], controllers: [ApiGatewayController], providers: [ApiGatewayService], }) export class ApiGatewayModule {} ``` ### 2. Authentication Module ```typescript // src/auth/entities/user.entity.ts @Entity() export class User { @PrimaryGeneratedColumn(\u0026#34;uuid\u0026#34;) id: string; @Column({ unique: true }) email: string; @Column() password: string; @Column({ type: \u0026#34;json\u0026#34;, nullable: true }) preferences: Record\u0026lt;string, any\u0026gt;; } // src/auth/auth.service.ts @Injectable() export class AuthService { constructor( @InjectRepository(User) private userRepository: Repository\u0026lt;User\u0026gt;, private jwtService: JwtService ) {} async validateUser(email: string, password: string): Promise\u0026lt;any\u0026gt; { const user = await this.userRepository.findOne({ where: { email } }); if (user \u0026amp;\u0026amp; (await bcrypt.compare(password, user.password))) { return user; } return null; } } ``` ### 3. User Module ```typescript // src/user/entities/profile.entity.ts @Entity() export class Profile { @PrimaryGeneratedColumn(\u0026#34;uuid\u0026#34;) id: string; @OneToOne(() =\u0026gt; User) @JoinColumn() user: User; @Column({ type: \u0026#34;json\u0026#34; }) ideSettings: Record\u0026lt;string, any\u0026gt;; @Column({ type: \u0026#34;json\u0026#34; }) aiPreferences: Record\u0026lt;string, any\u0026gt;; } ``` ### 4. Product Module (IDE Core) ```typescript // src/ide/entities/project.entity.ts @Entity() export class Project { @PrimaryGeneratedColumn(\u0026#34;uuid\u0026#34;) id: string; @ManyToOne(() =\u0026gt; User) owner: User; @Column() name: string; @Column({ type: \u0026#34;json\u0026#34; }) configuration: Record\u0026lt;string, any\u0026gt;; @Column({ type: \u0026#34;jsonb\u0026#34; }) aiContext: Record\u0026lt;string, any\u0026gt;; } ``` ## Event-Driven Architecture ### Event Bus Configuration ```typescript // src/common/event-bus/event-bus.module.ts @Module({ imports: [ ClientsModule.register([ { name: \u0026#34;EVENT_BUS\u0026#34;, transport: Transport.RMQ, options: { urls: [\u0026#34;amqp://localhost:5672\u0026#34;], queue: \u0026#34;main_event_queue\u0026#34;, }, }, ]), ], providers: [EventBusService], exports: [EventBusService], }) export class EventBusModule {} ``` ### Event Handlers ```typescript // src/ide/events/code-analysis.handler.ts @Injectable() export class CodeAnalysisHandler { @EventPattern(\u0026#34;code.analysis.requested\u0026#34;) async handleCodeAnalysis(@Payload() data: CodeAnalysisEvent) { // AI-powered code analysis logic } } ``` ## Database Schema ### TypeORM Configuration ```typescript // src/config/typeorm.config.ts export const typeOrmConfig: TypeOrmModuleOptions = { type: \u0026#34;postgres\u0026#34;, host: process.env.DB_HOST, port: parseInt(process.env.DB_PORT, 10), username: process.env.DB_USERNAME, password: process.env.DB_PASSWORD, database: process.env.DB_DATABASE, entities: [User, Profile, Project], migrations: [\u0026#34;dist/migrations/*.js\u0026#34;], synchronize: false, logging: true, }; ``` ## AI Integration Services ### Code Analysis Service ```typescript // src/ide/services/ai-analysis.service.ts @Injectable() export class AIAnalysisService { constructor( private readonly httpService: HttpService, private readonly eventBus: EventBusService ) {} async analyzeCode(code: string, context: AIContext): Promise\u0026lt;AnalysisResult\u0026gt; { // AI model integration logic } } ``` ### Code Completion Service ```typescript // src/ide/services/code-completion.service.ts @Injectable() export class CodeCompletionService { constructor( private readonly aiService: AIService, private readonly codeContextService: CodeContextService ) {} async getCompletion( code: string, position: Position, context: CompletionContext ): Promise\u0026lt;CompletionSuggestion[]\u0026gt; { // Code completion logic } } ``` ## Security Implementations ### Authentication Guard ```typescript // src/auth/guards/jwt-auth.guard.ts @Injectable() export class JwtAuthGuard extends AuthGuard(\u0026#34;jwt\u0026#34;) { constructor(private reflector: Reflector) { super(); } canActivate(context: ExecutionContext) { const isPublic = this.reflector.getAllAndOverride\u0026lt;boolean\u0026gt;(IS_PUBLIC_KEY, [ context.getHandler(), context.getClass(), ]); if (isPublic) { return true; } return super.canActivate(context); } } ``` ## Deployment Architecture ### Docker Configuration ```dockerfile # Dockerfile FROM node:16-alpine WORKDIR /usr/src/app COPY package*.json ./ RUN npm install COPY . . RUN npm run build EXPOSE 3000 CMD [\u0026#34;npm\u0026#34;, \u0026#34;run\u0026#34;, \u0026#34;start:prod\u0026#34;] ``` ### Docker Compose Setup ```yaml # docker-compose.yml version: \u0026#34;3.8\u0026#34; services: api: build: . ports: - \u0026#34;3000:3000\u0026#34; depends_on: - postgres - rabbitmq postgres: image: postgres:13 environment: POSTGRES_PASSWORD: ${DB_PASSWORD} POSTGRES_DB: ${DB_NAME} rabbitmq: image: rabbitmq:3-management ports: - \u0026#34;5672:5672\u0026#34; - \u0026#34;15672:15672\u0026#34; ``` ## Scaling Considerations 1. **Horizontal Scaling** - Use Kubernetes for container orchestration - Implement load balancing at the API Gateway level - Scale individual microservices independently 2. **Performance Optimization** - Implement caching strategies using Redis - Optimize database queries and indexes - Use WebSocket for real-time features 3. **Monitoring and Logging** - Implement ELK stack for centralized logging - Use Prometheus and Grafana for metrics - Set up application performance monitoring ## Development Workflow 1. **Local Development** ```bash # Start development environment npm run start:dev # Run database migrations npm run typeorm migration:run # Generate new migration npm run typeorm migration:generate -- -n MigrationName ``` 2. **Testing Strategy** ```typescript // src/ide/tests/code-analysis.service.spec.ts describe(\u0026#34;CodeAnalysisService\u0026#34;, () =\u0026gt; { let service: CodeAnalysisService; beforeEach(async () =\u0026gt; { const module: TestingModule = await Test.createTestingModule({ providers: [CodeAnalysisService], }).compile(); service = module.get\u0026lt;CodeAnalysisService\u0026gt;(CodeAnalysisService); }); it(\u0026#34;should analyze code correctly\u0026#34;, async () =\u0026gt; { // Test implementation }); }); ``` ## Future Considerations 1. **AI Model Integration** - Support for multiple AI models - Custom model training capabilities - Model versioning and A/B testing 2. **Extensibility** - Plugin architecture - Custom extension marketplace - API versioning strategy 3. **Developer Experience** - Interactive documentation - Developer portal - API playground 任务分解：tasks.md 以下是如何构建 AI 理解任务：\n# 当前 Sprint 任务 ## USER-001：实现用户身份验证 状态：进行中 优先级：高 依赖性：无 ### 要求 - 电子邮件/密码身份验证 - JWT 令牌生成 - 使用 bcrypt 进行密码哈希处理 - 登录尝试的速率限制 ### 验收标准 1.用户可以使用电子邮件/密码注册 2.用户在登录成功后收到 JWT 3.密码经过安全哈希处理 4.登录尝试失败的速率受到限制 ### 技术说明 - 使用@nestjs/jwt 进行令牌管理 - 使用 Redis 实现速率限制 - 遵循来自 Technical.md 的身份验证模式 进度跟踪：status.md 该文件可帮助 AI 了解当前的开发状态：\n# 项目状态 ## 已完成的功能 - 基本项目设置 - 数据库连接 - 基本模块结构 ## 进行中 -用户身份验证（USER-001） - ✅ 基本用户模型 - ✅ 密码哈希 - 🏗️ JWT 实施 - ⏳ 速率限制 ## 待定 - 电子邮件验证 - 密码重置流程 - 用户配置文件管理 ## 已知问题 - 目前无 管理上下文和文件引用 Cursor 的真正威力来自智能上下文管理。每当您达到上下文限制时（大型项目中经常发生这种情况），您都需要一种方法来快速恢复 AI 对项目的理解。这就是我们的文件结构和引用系统变得至关重要的地方。让我们看看它的实际效果：\n了解上下文限制以及 status.md 为何至关重要 大多数教程都不会告诉你：像 Cursor 这样的 AI 助手有上下文限制。一旦达到该限制，AI 就会失去对之前更改和讨论的跟踪。这时 status.md 就会成为你的生命线。\n将 status.md 视为项目的内存。当 Cursor 达到其上下文限制时（这种情况发生的频率比您想象的要高），您可以使用 status.md 快速恢复上下文，而无需再次解释所有内容。\n达到上下文限制的示例：\n你：让我们继续进行身份验证服务 Cursor：*由于上下文限制，对之前的实施细节一无所知* 你：@{docs/status.md} 让我们继续进行 JWT 实施 Cursor：*现在了解当前状态并可以适当地继续* Cursor 中的实用文件引用 您无需编写命令，而是可以通过以下方式在 Cursor 中实际引用文件：\n1. 从多个文件添加上下文： @{docs/status.md} @{docs/technical.md} @{tasks/tasks.md} 现在，让我们实现 JWT 身份验证服务…… 2. 检查当前实施情况： @{src/auth/auth.service.ts} 您能根据@{docs/technical.md} 规范添加速率限制吗？ 真实示例：构建身份验证服务 让我们看看在适当的文件引用和上下文管理下，这在实践中是如何实现的：\n1. 首先收集背景信息： @{docs/architecture.mermaid} @{tasks/tasks.md} @{docs/status.md} 我需要帮助从 USER-001 实现 JWT 身份验证服务。 2.在实施过程中，当您遇到上下文限制时： @{docs/status.md} 让我们继续 JWT 服务的实现。我们正在研究速率限制。 3. 添加新功能时： @{src/auth/auth.service.ts} @{docs/technical.md} 您能按照我们的技术规范添加密码重置功能吗？ 为什么这种方法有效 每次引用文件时，Cursor 都会获取最新的上下文 status.md 帮助跟踪上下文重置的进度 即使失去背景信息，技术规格仍保持一致 现实检验：人工智能不是魔法，而是一种工具 让我们来谈谈这个显而易见的问题——人工智能编码助手通常被宣传为能够编写整个应用程序的神奇代码生成器。这正是许多开发人员感到沮丧并声称“人工智能产生的错误比代码还多”的原因。\n现实情况是：人工智能就像拥有一位出色的初级开发人员，他：\n具有完美的模式记忆（在上下文限制内） 能够以闪电般的速度编写样板文件 应对复杂的业务逻辑 需要明确的规范和指导 遵循测试驱动开发时效果最佳 为什么大多数开发人员在 AI 方面遇到困难 我看到的典型方法：\n开发人员：“使用 OAuth 为我构建一个用户身份验证系统” AI：*生成看似完整的代码* 开发人员：*在边缘情况下发现错误* 开发人员：“AI 不可靠！” 真正的问题是什么？我们错误地使用了人工智能。让我告诉你如何改变你的方法。\n测试驱动开发（TDD）：抵御人工智能幻觉的盾牌 真相是：人工智能会产生幻觉。它会编写看似合理但实际上却错误的代码。解决方案是什么？TDD。\n考虑一下这个现实世界的场景：\n// ❌ Without TDD @{src/auth/auth.service.ts} // Developer: \u0026#34;Add password reset functionality\u0026#34; // AI generates code that: // - Looks correct // - Handles the happy path // - Misses critical edge cases // - Has security vulnerabilities in token validation // ✅ With TDD @{src/auth/auth.service.spec.ts} // Developer: \u0026#34;Here are the test cases for password reset: describe(\u0026#39;PasswordResetService\u0026#39;, () =\u0026gt; { it(\u0026#39;should throw if token is expired\u0026#39;) it(\u0026#39;should prevent timing attacks in token comparison\u0026#39;) it(\u0026#39;should rate limit reset attempts\u0026#39;) it(\u0026#39;should handle non-existent emails securely\u0026#39;) }) // Now implement the service to pass these tests\u0026#34; TDD 为何能与 AI 协同工作：\n强制明确要求 防止出现幻觉行为 尽早发现边缘情况 维护安全考虑 真正的开发陷阱（以及如何避免） 1. 复杂逻辑幻觉 // ❌ 危险：让 AI 直接处理复杂的业务逻辑 “实现账单计算逻辑” // ✅ 安全：通过测试分解 @{src/billing/billing.spec.ts } “实现账单计算以通过以下测试用例： 1 .基本费率计算 2. 批量折扣 3. 特殊节假日费率 4. 多币种支持” 2. 状态管理陷阱 当 AI 处理状态时，它经常会产生细微的错误。例如：\n// ❌ Problematic export class UserService { private users: User[] = []; // Global state! async createUser(user: User) { this.users.push(user); // Race conditions waiting to happen } } // ✅ Correct export class UserService { constructor(private readonly userRepository: UserRepository) {} async createUser(user: User) { await this.userRepository.transaction(async (repo) =\u0026gt; { await repo.save(user); }); } } 3. 依赖地狱 AI 喜欢创建循环依赖。以下是防止它们的方法：\n// ❌ AI 的自然倾向 @{src/user/user.service.ts} 依赖于 @{src/auth/auth.service.ts} @{src/auth/auth.service.ts} 依赖于 @{src/user/user.service.ts} // ✅ 正确的方法 @{docs/architecture.mermaid} “给定这种架构，实现用户服务以确保： 1.依赖关系单向流动 2.使用接口进行跨模块通信 3.事件驱动通信满足循环需求” 上下文限制：实用指南 当你达到上下文限制时（你会的），实际上会发生以下情况：\n// Initial implementation @{src/auth/auth.service.ts} \u0026#34;Add OAuth support\u0026#34; // AI: Implements OAuth perfectly // Later in the conversation... \u0026#34;Add refresh token support\u0026#34; // AI: Implements it incorrectly because it lost context // Solution: Restore context with status @{docs/status.md} @{src/auth/auth.service.ts} \u0026#34;Add refresh token support to our OAuth implementation\u0026#34; // AI: Now has full context and implements correctly 真实世界情境管理： 保持 status.md 专注于架构决策 记录关键实施模式 参考相关测试来进行行为规范 安全和错误处理：隐藏的陷阱 人工智能有一种危险的倾向：\n跳过错误处理 使用不安全的类型断言 错过安全验证 解决方案：使用明确的错误和安全测试：\ndescribe(\u0026#39;UserAuthentication\u0026#39;, () =\u0026gt; { it(\u0026#39;should handle SQL injection attempts\u0026#39;) it(\u0026#39;should prevent timing attacks\u0026#39;) it(\u0026#39;should rate limit failed attempts\u0026#39;) it(\u0026#39;should log security events\u0026#39;) it(\u0026#39;should sanitize error messages\u0026#39;) }) 清洁人工智能开发的最佳实践 1. 总是从架构开始 首先更新你的美人鱼图 确保人工智能理解系统边界 2. 分解任务 创建明确、重点突出的任务 包括所有要求和验收标准 3. 保持状态 保持 status.md 更新 跟踪进度和问题 4.使用TDD 首先编写测试 让AI实现通过测试 结论 成功开发 AI 的关键不在于拥有最聪明的 AI，而在于赋予它正确的背景和结构。通过遵循此策略，您将把 Cursor 从有时有用的工具转变为可靠的开发合作伙伴。\n记住：\n清晰的架构 结构化任务 明确规则 持续更新 停止与人工智能争斗，开始与它合作。结果可能会让你大吃一惊。\n注：本文译自 https://medium.com/@vrknetha/the-ultimate-guide-to-ai-powered-development-with-cursor-from-chaos-to-clean-code-fc679973bbc4\n","date":"2025-02-13T21:13:56+08:00","permalink":"https://blog.yearsuns.com/p/the-ultimate-guide-to-development-with-cursor/","title":"Cursor开发终极指南"},{"content":"1. 聊天现状：你在说人话，但对方没听懂 你有没有过这样的经历？\n你兴致勃勃地向朋友吐槽工作：“哎，我最近忙得要疯了！”结果对方只回了一句：“嗯，真辛苦啊。” 想和对象沟通：“我们可以多花点时间在一起吗？”结果人家理解成了“你是不是嫌我陪得还不够？” 开会时侃侃而谈，末了却发现大家脸上写满了“所以你想说啥？”的表情。 ⭐你费尽口舌，对方一脸懵逼；你努力铺垫，核心意思全跑偏。这种“鸡同鸭讲”的情况是不是让你崩溃到怀疑人生？\n别担心，这并不是因为你“不够聪明”或者“社交恐惧”，而是因为你的沟通方式需要升级。下面，我们从心理学角度拆解问题根源，再给出一份人人适用的沟通宝典！\n2. 心理学拆解：为啥“明明说了”却没传达清楚？ ❗误区一：信息超载，别人没抓住重点 心理学上有个概念叫“认知负荷理论”。当信息量过大时，人脑会像“内存不足”的电脑一样自动跳过部分内容。而很多人表达时会“前情提要+背景介绍+长篇感慨”，最后忘了告诉对方核心需求。\n比如：\n“我最近工作好多压力啊，晚上熬夜写方案，白天还要跟客户开会，周末本想休息还被拉去团建，我感觉快撑不下去了……”\n对方接收到的关键词可能是：工作、熬夜、团建。但你真正想表达的是“我需要支持”。\n心理学解法：少讲背景，多讲核心。用清晰的逻辑简化信息传递，避免听者迷路。\n❗误区二：情绪先行，信息被情绪屏蔽 情绪是沟通的双刃剑。当你在表达时情绪过于激烈（生气、委屈、沮丧），对方的注意力可能会被你的情绪吸引，而忽略了你的实际诉求。\n比如：\n“你为什么总是不回我消息？我真的很生气！是不是根本不在乎我！”\n对方的大脑此时的翻译器可能工作成这样：\n情绪输入：生气、指责 行动输出：回避、不敢沟通 心理学解法：表达感受时，把情绪和需求分开。情绪引导可以软化开头，需求要明确表达。\n❗误区三：假设对方能读懂你的“潜台词” 你以为表达了一切，但对方却完全没听懂。心理学研究表明，每个人的认知框架不同，你的“理所当然”可能是别人的“完全陌生”。\n比如：\n你对队友说：“报告PPT今天能不能早点搞定？”\n而对方可能在想：“‘早点’是多早？今晚10点？还是明早8点？”\n心理学解法：用具体的语言取代模糊的指令，把潜台词变成明台词。\n3. 解决方案：3步搞定高效沟通 第一步：用“黄金三段式”表达需求 心理学家推荐的“黄金三段式”，可以让你的沟通简单又高效。\n公式：\n感受+事实+需求\n案例：\n错误表达：“为什么你都不陪我？” 黄金三段式：“我最近感觉有点孤单（感受）。你上周末和这周都很忙，没一起吃饭（事实）。下次周末我们能一起吃个饭吗（需求）？” 这么说是不是更容易让对方明白你的需求？\n第二步：巧用“提问引导”代替说教 与其“输出式表达”，不如通过提问让对方参与。\n提问的威力：\n开放式提问（多问“怎么想”）：\n错误：\u0026ldquo;你根本没用心听我说话！\u0026rdquo; 改进：\u0026ldquo;你觉得刚刚我说的那些，哪个部分比较重要？\u0026rdquo; 选择式提问（给选项降低压力）：\n错误：\u0026ldquo;你打算什么时候改这个方案？\u0026rdquo; 改进：\u0026ldquo;我们是今天讨论细节，还是明天具体落实？\u0026rdquo; 提问不仅让对方更有参与感，还能巧妙避免冲突。\n第三步：多用“复述确认”打消误解 复述是一种被心理学验证过的高效沟通技巧。用自己的语言总结对方表达的内容，能避免“鸡同鸭讲”。\n复述公式：\n“你是说……对吗？”\n案例：\n错误方式：\n甲：“我最近感觉好累。” 乙：“多休息吧。”（误解对方意思） 正确方式：\n甲：“我最近感觉好累。” 乙：“你是说最近事情太多让你有点承受不住了？” 复述不仅能让对方感受到被理解，还能让你捕捉到对方的真实需求。\n第四步：善用肢体语言提升沟通效果 心理学研究显示，语言只占沟通的7%，语气和肢体语言却占到了93%。\n保持眼神交流：眼神能传递专注感和信任感。 使用开放的肢体动作：双臂张开比交叉在胸前更容易让人感到亲近。 适当点头和微笑：增强对方的表达欲望。 肢体语言是一种无声的沟通技巧，掌握它可以让你的表达如虎添翼。\n第五步：利用“沉默技巧”创造空间 很多人以为沟通就是不停地说，但心理学认为，适当的沉默反而能带来意想不到的效果。\n沉默制造思考：当你表达完后，给对方一些时间消化和回应，而不是急于填补空白。 沉默化解冲突：当对方情绪激动时，安静的聆听比言语更有效。 沉默是沟通的高级形式，学会用沉默说话，你的对话会更加流畅。\n4. 总结：沟通高手的秘密，其实是“懂得聆听+表达精准” 说到底，沟通的本质不是“说得多”，而是“听得准、说得对”。心理学家认为，每一次成功的沟通背后，都有以下关键：\n明确目的：你希望对方理解什么？解决什么问题？ 减少噪音：摒弃无关信息，直击核心。 用心倾听：通过提问与复述确认对方的感受和需求。 调整表达方式：结合语言、肢体和情绪多维度传递信息。 创造对话空间：在表达和沉默中找到平衡。 所以，下次当你发现对话陷入“鸡同鸭讲”时，不妨用这些方法试试看。掌握了这些心理学技巧，你不只是沟通小白升级为大师，甚至可能成为“人类话语机器”！（开玩笑✨）\n最后，记住这句话：沟通不是天赋，是技能；而技能，可以习得。\n","date":"2025-02-13T20:38:56+08:00","permalink":"https://blog.yearsuns.com/p/the-science-of-high-impact-communication/","title":"摆脱“话题终结者”！心理学教你3步升级为沟通大师✨"},{"content":"我们将从这篇文章中学到什么 👉 REST API 的基本原则 RESTful架构的核心概念 关键 HTTP 方法及其适当用途 👉 API 设计的最佳实践 如何设计有意义且高效的面向资源的 URL。 正确使用标准 HTTP 状态代码的重要性。 实现过滤、排序和分页的技术。 需要清晰、一致的 API 文档和工具来帮助实现这一点。 有效的 API 版本控制策略，以确保向后兼容性。 保护 API 安全的最佳实践，包括身份验证和 HTTPS。 如何以用户友好且信息丰富的方式处理错误。 维护 RESTful 原则和避免常见错误的实用技巧。 对设计可扩展且直观的 API 的见解。 API 设计中的常见陷阱以及如何避免它们。 👉 实用的注意事项 维护 RESTful 原则和避免常见错误的实用技巧。 对设计可扩展且直观的 API 的见解。 API 设计中的常见陷阱以及如何避免它们。 什么是 API？ 应用程序编程接口 (API) 是用于集成应用软件和服务的一组工具、定义和协议。它可以让您的产品和服务与其他产品和服务进行通信，而无需不断构建新的连接基础设施。\nAPI 可以是私有的（仅供内部使用）、合作的（与特定合作伙伴共享以提供额外的收入来源）或公开的（允许第三方开发与您的 API 交互的应用程序以促进创新）。\nhttps://www.redhat.com/en/topics/api/what-is-a-rest-api\n什么是 REST API？ REST API（也称为 RESTful API）是一种符合 REST 架构风格约束并允许与 RESTful Web 服务交互的应用程序编程接口（API 或 Web API）。REST 代表表述性状态转移，由计算机科学家 Roy Fielding 创建。\nhttps://www.redhat.com/en/topics/api/what-is-a-rest-api\nREST API 架构约束 REST 是一组架构约束，而不是协议或标准。以下是理想 RESTful API 的约束：\n客户端-服务器架构：由客户端、服务器和资源组成的客户端-服务器架构，请求通过 HTTP 进行管理。只要服务器和客户端之间的接口不变，它们也可以被替换和独立开发（也可以使用不同的编程语言）。 无状态：在客户端-服务器通信中，在处理请求传输期间，服务器上不应存储任何数据。这意味着请求之间不会存储任何客户端信息，并且每个请求都是独立且无关联的。 可缓存：客户端应该能够将响应存储在缓存中。这极大地提高了 API 的性能。 分层系统：服务器可以有多个层级来实现。这种分层架构有助于通过实现负载平衡来提高可扩展性。 按需代码：此约束是可选的。此约束表示可以通过允许从服务器下载代码并执行代码来在运行时扩展客户端应用程序的功能。 统一接口：统一接口约束是任何 RESTful 系统设计的基础。它简化并解耦了架构，使每个部分能够独立发展。 这个统一接口的四个约束是：\n请求中的资源标识：使用 URI 在请求中标识单个资源。资源本身在概念上与返回给客户端的表示形式是分开的。例如，服务器可以将数据库中的数据以 HTML、XML 或 JSON 的形式发送，而这些都不是服务器的内部表示形式。\n通过表示来操作资源：当客户端持有资源的表示（包括附加的任何元数据）时，它有足够的信息来修改或删除资源的状态。\n自描述消息：每条消息都包含足够的信息来描述如何处理该消息。例如，可以通过媒体类型指定要调用哪个解析器。\n超媒体作为应用程序状态引擎 (HATEOAS) — 访问 REST 应用程序的初始 URI 后（类似于人类 Web 用户访问网站主页），REST 客户端应该能够动态使用服务器提供的链接来发现所需的所有可用资源。随着访问的进行，服务器将使用包含指向当前可用的其他资源的超链接的文本进行响应。客户端无需使用有关服务器结构的信息进行硬编码。\n来源：https://en.wikipedia.org/wiki/REST#Uniform_interface\n什么是资源？ REST中信息的关键抽象是资源。任何可以命名的信息都可以是资源：文档或图像、时间服务（例如“洛杉矶今日天气”）、其他资源的集合（例如“今日畅销产品”，即产品资源的集合）、非虚拟对象（例如人）等等。\n— Roy Fielding 的论文\n单例和集合资源 资源可以是单例，也可以是集合。\n例如，\u0026ldquo;customers\u0026rdquo; 是一个集合资源，\u0026ldquo;customer\u0026rdquo; 是一个单例资源。\n我们可以使用 URI 来识别 \u0026ldquo;customers\u0026rdquo; 集合资源。我们可以使用 URI 来/customers识别单个 \u0026ldquo;customer\u0026rdquo; 资源/customers/{customerId}\n/customers // 是一个集合资源 /customers/{id} // 是一个单例资源 集合和子集资源 资源也可能包含子集资源。\n例如，可以使用以下方式识别特定 \u0026ldquo;customers\u0026rdquo; 的子集资源 \u0026ldquo;account\u0026rdquo; /customers/{customerId}/accounts\n类似地，可以识别子集合资源 \u0026ldquo;accounts\u0026rdquo; 内的单例资源 \u0026ldquo;account\u0026rdquo; /customers/{customerId}/accounts/{accountId}\n/customers //是一个集合资源\n/customers/{ id }/accounts //是一个子集合资源（客户的帐户）\n/customers/{customerId}/accounts/{accountId} //是一个单例资源（客户的特定帐户）\nURI（统一资源标识符） URI 代表统一资源标识符(URI)。它标识网络上的逻辑或物理资源。URL 和 URN 是 URI 的子类型。URL 定位资源，而 URN 命名资源。\nREST API 使用 URI 来定位资源。REST API 设计人员应创建 URI，以便将 REST API 的资源模型传达给 API 的潜在客户。如果资源命名得当，API 就会直观且易于使用。如果命名不当，同一个 API 的使用和理解就会变得困难。\n最佳实践：应该做的和不应该做的 1. 使用适当的 HTTP 方法（动词）定义 API 操作 HTTP协议定义了许多为请求赋予语义的方法。大多数 RESTful Web API 使用的常见 HTTP 方法包括：\nGET在指定的 URI 处检索资源的表述，响应消息的主体包含所请求资源的详细信息。\nPOST在指定的 URI 处创建新资源，请求消息的主体提供了新资源的详细信息。注意：POST还可用于触发不实际创建资源的操作。\nPUT在指定的 URI 处创建或替换资源，请求消息的主体指定要创建或更新的资源。\nPATCH对资源执行部分更新，请求主体指定要应用于资源的一组更改。\nDELETE删除指定 URI 处的资源。\n特定请求的效果应取决于资源是集合还是单个项目。下表使用电子商务示例总结了大多数 RESTful 实现所采用的通用约定。\n注意：并非所有这些请求都可能被实现——这取决于具体情况。\nResource POST GET PUT DELETE /customers Create a new customer Retrieve all customers Bulk update of customers Remove all customers /customers/1 Error Retrieve the details for customer 1 Update the details of customer 1 if it exists Remove customer 1 /customers/1/orders Create a new order for customer 1 Retrieve all orders for customer 1 Bulk update of orders for customer 1 Remove all orders for customer 1 POST、PUT和PATCH之间的区别可能会令人困惑。\nPOST请求创建资源并将其添加到资源集合中。然后向客户端返回新创建的资源 URI。POST请求还可用于向现有资源提交数据以供处理，而无需创建任何新资源。\nPUT请求会创建资源或更新现有资源。请求正文包含资源的完整表述。如果具有此 URI 的资源已存在，则将其替换。否则，如果服务器支持，则创建新资源。PUT请求最常应用于作为单个项目（例如特定客户）的资源，而不是集合。服务器可能支持更新但不支持通过 PUT 创建。是否支持通过 PUT 创建取决于客户端是否可以在资源存在之前有意义地为其分配URI。如果不能，则使用POST创建资源，使用PUT或PATCH进行更新。\nPATCH请求对现有资源执行部分更新。请求正文指定要应用于资源的一组更改。这比使用PUT更高效，因为客户端仅发送更改，而不是资源的整个表示。\nPUT请求必须是幂等的。如果客户端多次提交相同的PUT请求，则结果应该始终相同（将使用相同的值修改相同的资源）。POST和PATCH请求不保证是幂等的。\n2. 使用名词（复数名词）表示资源 RESTful URI 应该引用作为事物（名词）的资源，而不是引用动作（动词），因为名词具有动词所不具备的属性 — 同样，资源也具有属性。以下是一些资源示例：\n用户(user) 帐户(account) 其资源URI可以设计如下：\nHTTP Method Endpoint Description GET /accounts Returns a list of accounts GET /accounts/{accountNumber} Returns the account with account number {accountNumber} GET /users Returns a list of users GET /users/{id} Returns the user with ID {id} GET /orders Good - Returns a list of orders GET /create-order Avoid - verb or action-based names GET /students Good - Returns a list of students GET /student Avoid - singular names 3.使用子资源建立关系 使用一致的资源命名约定和 URI 格式，以最大程度地减少歧义并实现最大的可读性和可维护性。实施以下设计提示可实现一致性：\n在 REST 中，关系通常由子资源建模。对子资源使用以下模式。 HTTP Method Endpoint Description GET /{resource}/{resource-id}/{sub-resource} Retrieves a list of sub-resources GET /{resource}/{resource-id}/{sub-resource}/{sub-resource-id} Retrieves a specific sub-resource POST /{resource}/{resource-id}/{sub-resource} Creates a new sub-resource GET /post/{post-id}/comments Retrieves a list of comments for a post GET /post/{post-id}/comments/{comment-id} Retrieves a specific comment for a post POST /post/{post-id}/comments Creates a new comment for a post GET /cars/711/drivers/ Returns a list of drivers for car 711 GET /cars/711/drivers/4 Returns driver #4 for car 711 4.注重可读性和一致性 不要在 URI 中使用尾部斜杠 (/) GET /device-management/managed-devices/ GET /device-management/managed-devices /*✅这是一个更好的版本*/ 使用连字符 (-) 和短横线命名 ( some-var-name) 来提高 URI 的可读性 GET /devicemanagement/manageddevices/ GET /device-management/managed-devices /*✅这是一个更好的版本* / GET /m y -folder/ my -doc // ✅ 推荐 GET /MY-FOLDER/ my -doc // ❌ 避免 GET /My-Folder/ my -doc // ❌ 避免 避免使用下划线 ( _ ) 和驼峰式命名 ( someVarName) 蛇形命名 ( some_var_name) 帕萨尔式命名 ( SomeVarName) GET /managed-entities/{ id }/install-script-location // ✅ 更易读 GET /managed_entities/{ id }/install_Script_Location // ❌ 蛇形命名法- 易读但不常规 GET /managedEntities/{ id }/installScriptLocation // ❌ 驼峰命名法- 可读性较差 不要使用文件扩展名 /device-management/managed-devices.xml /*❌请勿使用它*/ /device-management/managed-devices /*✅这是正确的 URI*/ 切勿在 URI 中使用CRUD函数名称 /* ❌ 避免 */ HTTP GET / get -managed-devices HTTP POST /create-managed-devices /* ✅ 推荐 */ HTTP GET /managed-devices // 获取所有设备 HTTP POST /managed-devices // 创建新设备 HTTP GET /managed-devices/{id} // 获取给定 Id 的设备 HTTP PUT /managed-devices/{id} // 更新给定 Id 的设备 HTTP DELETE /managed-devices/{id} // 删除给定 Id 的设备 不要在 URI 中使用动词 GET /scripts/{id}/execute // ❌ 不要这样做！- 这是 RPC，而不是 REST POST /scripts // ✅ 推荐：使用 POST 操作创建脚本 GET /scripts/{id}/status // 检查执行状态 5.使用HTTP响应状态码 始终使用常规 HTTP 状态码来响应对 API 发出的请求。这将帮助用户了解发生了什么 — 请求是否成功，是否失败，或者其他情况。\n6.使用过滤、排序和分页来检索请求的数据 Feature Description Example Usage Sorting Allows sorting of the dataset based on specified parameters. /companies?sort=rank_asc Filtering Filters the dataset based on given criteria in query parameters. /companies?category=banking\u0026amp;location=india Searching Searches for specific terms within the dataset. /companies?search=Digital Pagination Divides the dataset into smaller chunks for easier handling and improved performance. /companies?page=23 7. 使用 HATEOAS 实现到相关资源的导航 HATEOAS（超文本作为应用程序状态引擎）是 REST 的一个原则，允许客户端仅通过响应中提供的超链接来浏览资源并发现可用的操作。这意味着客户端不需要事先了解 URI；相反，每个 HTTP GET 请求都会返回必要的信息和相关资源的链接，从而实现对 API 的动态探索。\n在示例响应中，/books/1分享可导航的链接，例如/authors/1 /books/1/reviews\n{ “books” ： [ { “id” ： 1 ， “title” ： “了不起的盖茨比” ， “author” ： “F·斯科特·菲茨杰拉德” ， “links” ： { “self” ： “/books/1” ， “author” ： “/authors/1” ， “reviews” ： “/books/1/reviews” } } ， { “id” ： 2 ， “title” ： “杀死一只知更鸟” ， “author” ： “哈珀·李” ， “links” ： { “self” ： “/books/2” ， “author” ： “/authors/2” ， “reviews” ： “/books/2/reviews” } } ] } 8. 使用 SSL 确保安全 SSL（安全套接字层）对于保护 REST API 免受恶意攻击至关重要。它确保服务器和客户端之间的通信是私密的，并且用户只能访问他们有权查看的数据。\nhttps:// 我们可以通过查看URL来判断 REST API 是否受 SSL 保护。例如，https://mysite.com/posts 受 SSL 保护，而 http://mysite.com/posts 不受 SSL 保护。\n9.提供准确的API文档 良好的 API 文档可帮助开发人员正确使用我们的 API。它可以让更多人想要使用我们的 API 并更好地使用它。一个流行的 API 文档工具是OpenAPI ( Swagger )\n10. RESTful Web API 版本控制 Versioning Method Description Example Usage Real-World Examples URI Path Includes the version number directly in the API path. http://www.example.com/api/v1/productshttp://www.example.com/api/v2/products - Twitter- PayPal- Google Translate Query Parameters Specifies the version number as a query parameter in the URL. http://www.example.com/api/products?version=1http://www.example.com/api/products?version=2 - Google Translation APIs Custom Headers Uses custom headers to specify the API version. http://localhost:8080/api/productsHeaders: X-API-VERSION=1http://localhost:8080/api/productsHeaders: X-API-VERSION=2 - Content Negotiation Uses the Accept header to specify the version of the API. http://localhost:8080/api/productsHeaders: Accept=application/vnd.javaguides-v1+jsonhttp://localhost:8080/api/productsHeaders: Accept=application/vnd.javaguides-v2+json - GitHub 11. API 安全和访问控制 确保 API 安全并控制谁可以使用它是制作优质 RESTful API 的关键部分。以下是一些实现此目的的方法：\n设置 OAuth 2.0 或 JSON Web Tokens (JWT)，以便未经身份验证的用户无法访问\nAPI 密钥显示谁在使用。API速率限制可阻止人们过度使用。\n实现基于角色的访问控制（RBAC）等。\n12. 不要忘记 API 性能 让我们的 API 更好地发挥作用是让用户满意、降低成本和更轻松地发展的关键。\n有效缓存\n数据压缩方法\n异步处理\n处理批处理操作\n测量 API 性能并分析 API 使用情况\n监控 API 健康和正常运行时间\n测试 RESTful API（单元测试、集成测试、负载测试、安全测试）等。\n结论 优秀的 REST API 是通过遵循关键规则和最佳实践来构建的。\n通过遵守这些规则，我们将构建易于使用、可靠且面向未来的 API。\n注：本文译自 https://medium.com/@syedabdullahrahman/mastering-rest-api-design-essential-best-practices-dos-and-don-ts-for-2024-dd41a2c59133\n","date":"2025-02-12T12:13:56+08:00","permalink":"https://blog.yearsuns.com/p/best-practices-for-rest-api/","title":"REST API的最佳实践"},{"content":"🌟 什么是SMART原则？ 我们生活中常常给自己定下各种目标，想要健身、读书、升职、旅行……但一旦目标太大或太模糊，就容易半途而废。SMART原则是一个经过验证的工具，能帮助我们设定清晰、具体并能实现的目标，打破“空想目标”带来的无力感。\nSMART是五个英文单词的首字母缩写，代表了目标设定的五个关键特征：\nS: Specific（具体） M: Measurable（可衡量） A: Achievable（可实现） R: Relevant（相关性） T: Time-bound（时限性） 📜 SMART原则的起源 SMART原则并不是一蹴而就的，它是由美国管理学专家George T. Doran于1981年提出的，最早出现在他的文章《There’s a S.M.A.R.T. Way to Write Management’s Goals and Objectives》中。Doran提出，很多管理目标制定的模糊性和不切实际的期望，导致了企业和个人无法有效实现目标，因此，他需要提出一个能具体化目标设定、避免“空谈”的方法——SMART。\nGeorge T. Doran当时的初衷是解决企业和组织在设定目标时遇到的几个常见问题：目标过于模糊，执行步骤不清晰，结果难以衡量，且往往缺乏完成的时限。\n🧐 为什么要有SMART？ 在Doran的时代，目标设定存在一个普遍问题，那就是许多管理目标没有明确性，很多时候只是宽泛的愿景或“愿望”，如“提高员工满意度”或“增加市场份额”。这类目标没有任何执行上的指引，导致了许多企业无论如何努力，结果却始终看不见。\n例如，如果一个公司设定的目标是“提高员工的工作动力”，这个目标看起来似乎是有意义的，但它缺乏可操作性和评估标准——到底“提高”到什么程度才算成功？这个问题没有明确的答案，导致目标变得空洞且难以达成。\n🧠 为什么SMART有效？ 在心理学中，设定明确目标被认为是提高动机和焦点的有效方法。人类的大脑对于模糊不清的任务缺乏足够的投入感，容易在各种诱惑面前分心。SMART原则通过将目标细化、量化、并赋予紧迫感，让我们的大脑“抓住”了目标，不容易走神。\n1. 具体（Specific） 如果目标只是“我想变得更健康”，它几乎没有任何行动指引。SMART的具体化要求目标要清晰明确。例如：“我计划每周跑步三次，每次30分钟。”这个目标具体到了“跑步”“次数”“时间”，容易给人一种可以立即行动的感觉。\n目标具体性越强，任务的执行障碍就越小。这是因为大脑对模糊的目标感到困惑和不安，而明确的目标则让大脑更容易激发执行动力。\n2. 可衡量（Measurable） 没有衡量标准的目标，就像是开车但不看导航。比如，“我想提高身体素质”就太空泛，如何知道什么时候“提高了”呢？而SMART则要求目标具有可衡量的标准，例如：“我要在三个月内将跑步速度提高5公里每小时。”\n明确的衡量标准让大脑能不断确认进展，获得即时反馈，增强自我效能感——“我做得不错”的感觉。\n3. 可实现（Achievable） 如果你想在三个月内成为铁人三项冠军，那可能太不现实了。SMART原则提到，目标要根据个人的现有资源和能力设定。可实现性并非要求轻松，而是要能够在现有条件下有所突破。\n这一点体现了亚里士多德的“黄金中庸”思想。过高或过低的期望都会让目标变得不合适，过高可能让人感到无望，过低则无法激发成长。\n4. 相关性（Relevant） 你的目标要与你的长期愿景和核心价值观相关联。如果你设定的目标与自己的真实兴趣或需求脱节，执行起来往往缺乏动力。例如：“我要学习一门新语言，因为我打算明年去旅游。”\n如果目标和个人动机、兴趣不符，大脑会默认“这不值得投入”。因此，相关性决定了目标的重要性和个人投入的程度。\n5. 时限性（Time-bound） 没有时限的目标，就像是漂浮在空中的气球，永远不会落地。SMART原则通过设定具体的时间限制，促使行动的紧迫感产生。比如：“我将在六个月内完成这本书的阅读。”\n时间的有限性体现了时间哲学中的“现时性”——在有限时间内，我们必须作出选择并进行投入。而过于宽松的时间框架反而容易让人推延。\n🔑 如何运用SMART原则？ 运用SMART原则其实很简单，关键在于每次设定目标时，深入思考并将每个元素加以落实。\n举个例子： 假设你想提高体能，但传统目标“我要变强”显然过于模糊。根据SMART原则，你可以将目标转化为：\n具体：我将每周去健身房3次，每次锻炼40分钟。 可衡量：我要在3个月内将我的卧推重量提升5公斤。 可实现：根据当前我的体能水平，逐步增加每周的训练强度是现实的。 相关性：因为我希望能更加健康，增强体力以便更好地应对日常工作和生活挑战。 时限性：我将在3个月内达成这一目标。 🏁 SMART目标的实际案例 案例一：学习英语\n目标：我要在六个月内通过英语托福考试，目标分数为90分。 具体：每周安排15小时的学习时间，重点提升听力和口语能力。 可衡量：每月模拟考试一次，检查听力和口语的进展。 可实现：根据目前英语水平，合理的学习计划能让我逐步达到目标分数。 相关性：通过托福考试能让我申请到心仪的国际大学，是我职业发展的关键步骤。 时限性：六个月后完成托福考试，并达到目标分数。 案例二：完成销售目标\n目标：我要在三个月内将销售额提升20%。 具体：通过增加客户联系和优化销售话术，每周增加5次客户拜访。 可衡量：每月追踪销售额，并与上月进行对比。 可实现：根据现有资源和市场情况，通过提高拜访频次和改进沟通方式能达到目标。 相关性：提高销售额是公司业绩提升的关键，也是我个人职业成长的一部分。 时限性：三个月内完成销售目标。 案例三：增加收入\n目标：我要在六个月内将个人收入提升30%。 具体：通过副业和提升本职工作表现来增加收入。 可衡量：每月记录收入并与上月进行对比，评估副业和本职收入的变化。 可实现：合理安排时间，利用业余时间投入副业，同时提升本职工作表现。 相关性：增加收入有助于提升生活质量，实现经济独立。 时限性：六个月内实现收入增长。 🏢 SMART的影响与发展 虽然Doran的初衷是帮助企业制定可执行的管理目标，但随着时间的推移，SMART原则不仅仅局限于管理学领域，也被广泛应用于个人目标设定、项目管理、教育和生活规划等多个领域。它已经成为一个跨学科的工具，帮助人们以更加精确的方式设定、追踪和实现目标。\n🎯 总结：目标管理的哲学与心理学之道 SMART原则从最初的管理学应用，到如今成为各行各业目标设定的通用工具，其核心思想在于帮助人们清晰、量化并确保目标能够顺利实现。通过SMART，我们能够避免目标模糊带来的困惑，减少拖延，提高效率，更有动力朝着目标前进。正如Doran当时所言：“目标必须是明确且可执行的，才能激发人们的行动力。”\nSMART原则的出现，犹如给目标设定领域打上了清晰的框架，让“梦想”不再只是天边的云朵，而是可以一步步实现的具体任务。\nSMART原则不仅仅是一个目标设定工具，它更深层次地连接了哲学和心理学的核心原理。在追求目标的过程中，我们不断在理性与情感、现实与理想之间进行拉锯。SMART帮助我们精准聚焦，通过清晰、可行的步骤实现目标，而不至于迷失在“想做却做不成”的自我困境中。\n无论你是追求个人成长，还是在职场中设定明确目标，SMART原则都可以成为你理性规划与心理动机的双重武器，助你逐步逼近理想的自我，最终实现那些曾经看似遥不可及的梦想。\n","date":"2025-02-11T18:11:56+08:00","permalink":"https://blog.yearsuns.com/p/mastering-goal-setting-with-the-smart-framework/","title":"SMART原则：让目标不再遥不可及"},{"content":"完美主义，这个似乎追求卓越的美德，却往往带来无尽的心理压力和内耗。它让我们焦虑，让我们不敢停歇，让我们深陷“做得不够好”的陷阱中。到底是完美主义的力量让我们变得更强，还是它的束缚让我们始终无法真正感受到内心的自由？\n在这篇博客中，我们将深入探讨完美主义与精神内耗之间的关系，揭示它们背后深层的心理机制，并给出一些切实可行的方法，帮助你突破内心的困境。\n完美主义的两面性 —— 追求卓越的“美德”还是精神枷锁？ 1.1 完美主义的定义： 完美主义听起来像是一个值得赞扬的品质，它让我们追求卓越、精益求精。完美主义者常常对自己设立极高的标准，力求把每件事情做到尽善尽美。然而，这种强烈的追求卓越往往让我们忽略了过程中的自我关怀。我们总是想着如何把结果做到完美，却常常忽视了“人是可以有缺陷的”这一事实。\n完美主义者将“完美”视为一种理想的标准，不达标便认为是失败。这种内心的标准常常带来无限的焦虑与不安，因为完美是无法轻易实现的，而每一次接近目标时，完美主义者又会定下更高的要求，永无止境。\n1.2 完美主义的背后 —— 动机与驱动力： 完美主义的根源不仅仅来自对卓越的渴望，更深层的原因在于外部和内部的双重压力。社会的期望、家庭的要求，甚至自我价值的认同，都在推动我们去追求完美。尤其在当今信息化的社会，外界的标准和审视比任何时候都更加严苛，我们不断对照他人，不断自我加压。\n内心深处，完美主义者往往存在一种“完美即被爱的”信念。为了避免被批评或忽视，完美主义者可能认为只有做到极致才能获得认同与尊重。这种深层的心理需求驱动着他们不断超越自我。\n1.3 完美主义的双刃剑效应： 完美主义有其明显的优点：它激励我们不断进步，提升自我，做出超出常人的成就。然而，当完美主义没有得到有效管理时，它就像一把双刃剑，可能带来沉重的心理负担。\n过度完美主义者不仅会忽视过程中的努力和成就，更容易陷入无休止的自我怀疑和焦虑之中。当结果不尽如人意时，他们容易情绪低落，甚至会开始质疑自己的能力与价值。长期处于这种状态中，精神内耗渐渐积累，最终影响身心健康。\n精神内耗的形成 —— 完美主义如何侵蚀我们的心理健康？ 2.1 精神内耗的定义： 精神内耗的本质就是个体在面对内外部冲突时，消耗了大量的心理资源。完美主义者常常处于这种内耗的状态中，因为他们不断地与内心的“理想自我”和现实的“当前自我”进行博弈。理想和现实之间的巨大差距让他们心力交瘁，最终影响到日常生活的质量和工作效率。\n这种内耗表现为持续的自我批评、过度思考和无效的拖延。我们不断在脑海中重复“如果能更好一些会怎样”这种思想，却忽视了每一个小小的进步和成长。\n2.2 精神内耗的症状与表现： 完美主义者的精神内耗通常表现为以下几种形式：\n无休止的自我否定： 不管做什么，总觉得自己还不够好，陷入“完美主义的陷阱”。无论工作成果如何，自己总认为“如果再努力一点就更好”。\n焦虑与拖延： 完美主义者常常感到焦虑，因为他们害怕没有做到最好。由于对完美的过度追求，很多时候他们会拖延行动，等待完美的时机和条件，结果往往错过了很多机会。\n自我摧残： 为了追求完美，完美主义者通常会过度压榨自己，牺牲休息时间和健康，甚至是亲密关系，最终形成恶性循环。\n2.3 精神内耗的恶性循环： 精神内耗往往形成恶性循环。完美主义者不断自我批判，感到无法满足外界和内心的期望，从而产生更多的焦虑。这种焦虑驱动他们去努力工作，但由于他们总是觉得自己做得不够好，反而加剧了内心的压力。\n这种零和思维让他们始终处于“要么做到完美，要么就是失败”的状态，导致他们无法真正享受过程中的乐趣和成就。每一项任务、每一次努力，似乎都只为了达到一个遥不可及的完美标准。\n如何破局 —— 走出完美主义的迷雾，找到内心的自由 3.1 认知重构：重新定义“完美” 完美并非一个固定的目标，它是一个相对的概念。每个人对完美的定义都不同，而外部世界的“完美”标准也不断变化。我们不能让完美成为束缚自己的枷锁。相反，应该将完美作为一个过程来看待，而非终极结果。\n完美是过程，而非结果： 完美主义者可以通过认知调整，理解到每个进步和每一次努力都是一种完美，而不必过于苛求最终结果。 3.2 建立健康的目标设定： 目标设定时，遵循SMART原则（S=Specific具体、M=Measurable可衡量、A=Attainable可实现、R=Relevant相关、T=Time-bound时限性），避免设定过高的目标带来的不必要的压力。\n逐步进步： 将目标分解成小步骤，每完成一步就给予自己适当的奖励，这样不仅能提高自信，也能让目标实现变得更加实际。 3.3 培养自我同情： 自我同情是一种接纳自己不完美的能力。完美主义者往往对自己要求过于苛刻，缺少对自己的关怀和体谅。学会对自己温柔，不再苛责每一个小缺点，将有助于缓解精神内耗。\n与自己和解： 每天进行自我肯定，接受自己的不完美，理解并接纳每一个成长的瞬间。 3.4 放松与休息： 完美主义者常常会忽略休息的重要性，认为休息等于浪费时间。然而，适当的休息与放松对提升效率和减少内耗至关重要。\n休息与效率并存： 给自己设定合理的休息时间，避免过度工作，保持身心的平衡。 3.5 寻找支持系统： 当精神内耗变得严重时，寻求外界的帮助至关重要。心理咨询可以帮助个体认清问题的根源并找到解决之道。而社交支持，则能通过与亲友的沟通，获得安慰与理解。\n结语 —— 追求卓越与享受过程的平衡 完美主义与精神内耗并非无法共存。关键在于我们如何管理这两者的关系，找到健康的平衡。通过认知重构、设定健康目标、培养自我同情、适当放松、寻求支持，我们可以在追求卓越的道路上，避免让完美主义束缚住我们的脚步。\n让我们在不断努力的过程中，也学会享受每一个成长的瞬间，不再将每一步看作通向终极目标的负担，而是当下价值的体现。最终，我们能够突破精神内耗的困扰，找到真正的内心自由。\n","date":"2025-02-11T17:11:56+08:00","permalink":"https://blog.yearsuns.com/p/the-perfectionism-trap/","title":"完美主义的陷阱：如何打破精神内耗，找到内心的自由"},{"content":"在技术圈中，请教问题是提升技能的重要途径。但有时候，我们的问题可能涉及敏感信息，比如项目代码、业务逻辑、客户数据等。如果不注意，很可能因为无意的泄露造成不必要的风险。那么，如何在请教问题时保护敏感信息？本文将从识别敏感信息、避免泄露以及高效沟通三个方面详细阐述。\n什么是敏感信息？如何识别？ 敏感信息通常是指那些一旦泄露，可能导致安全问题、商业损失或隐私风险的数据。在技术领域，敏感信息的范围可能更广。\n常见的敏感信息类型 个人身份信息（PII）\n包括用户名、密码、电子邮件地址、电话号码、身份证号等。 公司内部信息\n业务逻辑、未发布的产品功能、技术架构设计。 内部工具的配置文件，例如 API 密钥、数据库连接字符串。 客户或用户数据\n包括用户订单记录、支付信息、行为分析数据。 源码或配置文件\nGit 仓库中的代码、生产环境配置，尤其是涉及商业机密或专利内容的部分。 服务器与网络信息\nIP 地址、端口号、服务器配置。 如何判断信息是否敏感？ 以下几种方法可以帮助你快速判断：\n问自己：一旦泄露，会有何后果？\n如果信息泄露可能导致系统被攻击、用户隐私被暴露或公司竞争力下降，那么它就是敏感信息。 公司政策与行业规范\n公司通常有信息安全政策，参考其中的敏感信息定义。例如 GDPR 或 CCPA 明确规定了需要保护的用户数据。 通用经验法则\n凡是你需要登录权限才能访问的内容，默认认为是敏感的。 如何避免在请教问题时泄露敏感信息？ 1. 替换敏感信息 在描述问题时，尽量将敏感信息替换为通用或伪造的示例数据：\n用户名和密码\n原始数据：admin:password123 替换为：example_user:example_password API 密钥\n原始数据：sk_live_1234567890abcdef 替换为：sample_private_key 具体代码片段\n如果必须分享代码，先删除或模糊掉与业务相关的逻辑，只保留问题核心。 例如：将实际的 SQL 查询 \u0026ldquo;SELECT * FROM users WHERE role = 'admin'\u0026rdquo; 替换为 \u0026ldquo;SELECT * FROM table WHERE condition\u0026quot;。 2. 提供抽象问题 把具体问题抽象成通用场景，比如：\n原问题：\n我们的支付系统对接某银行接口时，总是返回 403 错误。\n抽象后：\n在使用 RESTful API 调用第三方支付接口时，返回 403 错误，怀疑是签名问题。这种情况应该如何排查？\n这样既避免暴露具体的支付对接信息，也能得到相同的技术解答。\n3. 使用代码片段工具 推荐在分享代码时使用 GitHub Gist、CodeSandbox 或 Pastebin，设置合适的访问权限，并在分享前检查敏感信息是否已被清理。\n4. 避免提供生产环境数据 无论如何，都不要直接复制生产环境的数据（如日志、数据库记录）。如需调试，可使用以下方法：\n生成伪数据\n利用 Faker.js、Mock.js 等工具生成假数据。 脱敏真实数据\n替换关键字段，例如将用户姓名替换为 \u0026ldquo;John Doe\u0026rdquo;，将手机号替换为 \u0026ldquo;1234567890\u0026rdquo;。 5. 与大佬确认是否方便回答 在提出问题之前，简要说明你的问题背景，让对方判断是否需要了解更多细节。比如：\n我遇到了一个数据库连接超时的问题，已排查了网络和配置部分。如果方便，我可以提供一个精简后的环境复现代码。\n通过这样的方式，大佬可以决定是否需要深入了解。\n高效沟通的小技巧 即便保护好敏感信息，也需要提高沟通效率，让对方快速理解你的问题。\n1. 结构化描述问题 使用以下模板：\n**问题背景：**简述你的技术环境和需求。 **预期结果：**你希望系统如何运行。 **实际结果：**当前系统的表现。 **尝试过的解决方法：**列出你已排查的内容。 例如：\n**背景：**我们使用的是 Spring Boot + PostgreSQL，部署在 AWS 上。\n**预期：**希望通过 JPA 查询接口返回分页数据。\n**实际：**查询时总是超时，尤其在大数据量场景下。\n**尝试：**调整了分页大小和索引优化，但效果有限。\n2. 用图表补充说明 如果问题复杂，可使用：\n流程图（如 Lucidchart 或 Draw.io）展示系统流程。 时序图清晰呈现请求和响应过程。 错误截图或日志标注关键问题点。 3. 感谢并反馈结果 解决问题后，记得感谢对方，并反馈最终结果。这不仅体现你的尊重，也能帮助大佬积累更多案例。\n总结 在向技术大佬请教问题时，保护敏感信息既是对自己的安全负责，也是对团队和客户的信任负责。通过识别敏感信息、替换真实数据、抽象问题和高效沟通，不仅能避免信息泄露，还能赢得大佬的专业认可。希望每一位开发者都能在技术交流中既学到知识，又能安心无忧！\n","date":"2025-02-10T11:43:56+08:00","permalink":"https://blog.yearsuns.com/p/protecting-sensitive-data-while-seeking-help/","title":"如何向技术大佬请教问题且不泄露敏感信息"},{"content":"有时候，程序员的日子就像《荒野求生》，问题就是那条饿着肚子追你的鳄鱼，你呢？跪着发帖：“大佬们救救孩子吧，代码写崩了！”\n结果呢？没人回。\n为什么？\n因为你发的帖就像“妈丫，肚子疼！”却忘了告诉医生是吃撑了、饿坏了、还是中午猛喝了五碗麻辣烫。\n今天，我来教你如何精准描述你的技术问题，让你瞬间从 “救救孩子” 进化到 “这哥们值得救”。\nStep 1：说清楚你在干啥，别藏着掖着 想让别人帮你？背景交代到位，别怕麻烦！\n大佬们不懂你家后院代码都咋跑的。来一段上下文，简洁明了！\n比如，你发帖别写：“Redis 锁续期有问题，快点来！”\n改成这样：\n我正在用 Spring Boot + Redisson 实现分布式锁，Spring Boot 版本 3.0.0，Redisson 用的是最新的 3.20.0。问题出在本地单元测试时锁续期失效。\n大佬看到这，立刻有谱：哦，这哥们用的是主流技术栈，问题不难搞！\nStep 2：问题描述要具体，别用感叹号骗大佬注意力 很多人喜欢放大自己的“惨状”：“完了，炸了，全崩了！”\n可是你连个报错信息都不贴上，难道指望大佬靠读心术帮你？\n错误信息一定要说清楚，关键内容圈出来，别整篇贴，显得像年终总结。比如：\n当我运行 lock.lock(60, TimeUnit.SECONDS) 时，日志显示：\njava.lang.IllegalStateException: Lock expired while executing task 错误出在锁续期失效，导致任务中途被抢锁。\n看！这样既具体，又不会让人头疼。\nStep 3：问题复现三板斧，连小白也能操作 技术问题要让别人有地方下手，就像解锁游戏副本的攻略。没法复现的问题，等于在地里找针。\n来个实例：\n错误复现步骤：\n启动 Redis 服务器，开启 Redisson 配置。 运行测试类 LockTest.java。 等待 30 秒后，问题出现。 清清楚楚三步走，大佬立刻知道咋搞。再加上你的配置文件、核心代码，人家手里有锤子，就能敲问题！\nStep 4：预期 vs 实际，问题得有个对比 人类（包括程序员）特别爱“对比法”，这会让大佬迅速明白你的痛点在哪里。\n比如这样写：\n预期：分布式锁应自动续期，确保任务完整执行。\n实际：锁未续期，任务执行到一半时锁被释放，导致数据不一致。\n逻辑一目了然！\nStep 5：展示你的努力，赢得大佬尊重 大佬们愿意帮有诚意的人。问题描述时，提一提你做过的尝试：\n尝试过的解决方法：\n检查了 Redis 是否正常启动，结果运行良好。 调试了 Redisson 配置，useSingleServer 设置正确。 改用 tryLock() 测试，问题依然存在。 这样一来，大佬心里一暖：“这哥们不是等着躺平，他是真心要解决问题！”\nStep 6：加点小细节，补充大佬的“弹药库” 最后再补上必要信息，比如操作系统、开发环境、核心代码片段。别一来就上百行代码，关键的几行就行了。\n环境：\n操作系统：MacOS 12.3 JDK：17 核心代码：\nRLock lock = redissonClient.getLock(\u0026#34;testLock\u0026#34;); lock.lock(60, TimeUnit.SECONDS); // 问题出现在这里 完美示例：把大佬整哭了的求助帖 背景：\n我正在用 Spring Boot + Redisson 实现分布式锁，版本如下：\nSpring Boot：3.0.0 Redisson：3.20.0 问题：\n单元测试中，锁无法自动续期，导致任务中途锁被释放。日志错误如下：\njava.lang.IllegalStateException: Lock expired while executing task 复现步骤：\n启动 Redis 服务器，使用默认配置。 运行测试类 LockTest.java。 等待超过 30 秒的锁超时时间，问题复现。 预期 vs 实际：\n预期：分布式锁自动续期，任务顺利完成。 实际：锁未续期，导致任务执行到一半被中断。 尝试过的解决方法：\n检查 Redis 是否正常运行，结果正常。 使用 tryLock() 方法测试，问题依然存在。 增加日志查看续期机制，发现续期任务未触发。 补充信息：\n操作系统：MacOS 12.3 JDK：17 Redisson 配置： Config config = new Config(); config.useSingleServer().setAddress(\u0026#34;redis://127.0.0.1:6379\u0026#34;); 结语 程序员求助的秘诀，在于精准、简洁和条理清晰。\n记住，这不仅仅是给别人看的，也是在训练自己的问题分析能力。\n当你学会准确描述问题的那天，你离解决问题已经不远了！\n最后，祝大家都能成为被大佬们“抢着帮”的技术王者～\n","date":"2025-02-09T20:43:56+08:00","permalink":"https://blog.yearsuns.com/p/tips-for-explaining-tech-issues/","title":"程序员的自救指南：如何精准描述你的技术问题，让大佬想帮你"},{"content":"前言\n在当今的 web 开发中，身份验证是非常关键的，而 JWT（JSON Web Token）作为一种简单、高效的身份验证方式，已经被广泛应用在许多前后端分离的项目中。本篇文章将带你从零开始理解 JWT，探讨它的优缺点，并介绍最佳实践。\n什么是 JWT？ JWT 是一种开放标准（RFC 7519），用于在不同系统之间安全地传递信息。简单来说，JWT 主要用于认证和信息交换，常见的应用场景就是用户登录验证。JWT 通常在用户登录后生成，并随后的请求中带着它来进行身份认证。\nJWT 结构 JWT 的结构非常简单，它由三部分组成：\n头部（Header）\n头部通常包含两部分内容：令牌类型（JWT）和签名算法（如 HMAC SHA256 或 RSA）。\n载荷（Payload）\n载荷是 JWT 的“正文”部分，存储了你希望传递的数据（比如用户 ID 或权限）。这里面包含了 \u0026ldquo;Claims\u0026rdquo;（声明），有三种类型：\n注册声明：如 sub（主题）、exp（过期时间）、iat（签发时间）等。 公共声明：可以自定义的数据，但需要避免冲突。 私有声明：你自己定义的声明。 签名（Signature）\n签名部分用于验证信息的完整性，确保数据没有被篡改。生成签名的方式是：用头部和载荷，通过密钥（对于对称加密是一个密钥，非对称加密是私钥）生成。\nJWT 的生成和验证原理 JWT 的生成过程 用户登录：\n用户输入用户名和密码，通过认证系统登录。\n服务器生成 JWT：\n认证成功后，服务器会使用一个密钥（对称加密）或者私钥（非对称加密）生成一个 JWT。生成过程包括：\n将头部和载荷（即数据）部分通过 Base64 编码。 用密钥对这两部分进行签名，生成签名部分。 生成后的 JWT 看起来像这样：\nheader.payload.signature 例如：\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c 返回 JWT 给客户端：\n服务器把生成的 JWT 返回给客户端，通常客户端会将其存储在本地（如 LocalStorage 或 Cookie）中。\nJWT 的验证过程 客户端发起请求：\n客户端每次请求时，会将 JWT 添加到请求的 Authorization 头部中（例如：Authorization: Bearer \u0026lt;JWT\u0026gt;）。\n服务器验证 JWT：\n服务器拿到 JWT 后，通过以下步骤来验证：\n解析 JWT 的头部、载荷和签名。 使用密钥（对于对称加密）或公钥（对于非对称加密）对签名部分进行验证，看是否与头部和载荷部分匹配。 如果验证通过，说明 JWT 的数据未被篡改，服务器就会继续处理请求。如果验证失败，说明 JWT 被篡改，服务器会返回错误信息。\nJWT 的优点 无状态（Stateless）\nJWT 是无状态的，意味着服务器不需要存储用户会话数据。每次请求都包含 JWT，服务器可以根据 JWT 里的信息来进行认证。这样减少了服务器的负担，提升了系统的扩展性。\n跨域支持\n由于 JWT 是由客户端传递，它非常适合前后端分离的项目，可以跨域进行身份验证，避免了传统 Cookie 的同源限制。\n轻量级\nJWT 的大小较小，通常在几十到一百多个字节之间，非常适合频繁的 HTTP 请求，传输效率高。\n适合微服务架构\nJWT 可以在多个服务之间传递身份信息，非常适合分布式架构，尤其是微服务架构中的身份认证。\nJWT 的缺点 无法撤销\n一旦 JWT 被发放出去，它就无法撤销。如果 JWT 泄露，攻击者可以在有效期内反复使用。这比传统的 Session 认证要危险，后者可以在服务器端主动注销会话。\n存储和安全问题\nJWT 如果存储不当（如保存在 LocalStorage 或 Cookie 中），可能会受到 XSS 攻击。如果攻击者能够获取到 JWT，就能伪造合法请求。\n过期问题\nJWT 通常设定有过期时间，一旦过期，就不能再使用。为了避免频繁登录，可以使用刷新令牌（Refresh Token）。不过如果过期时间设置不合理，可能会影响用户体验。\n载荷不加密\nJWT 的载荷部分是 Base64 编码的，不是加密的。任何人都可以解码并看到其中的内容。因此，切勿将敏感信息（如密码）存储在 JWT 中。\n密钥泄漏的风险\nJWT 的安全性依赖于密钥的保密性。如果密钥泄露，攻击者可以伪造有效的 JWT。因此，保护好密钥非常重要。\nJWT 的使用场景 单点登录（SSO）\nJWT 非常适合实现跨应用的单点登录（SSO）。只需生成一次 JWT，就可以在多个系统之间共享。\n移动应用身份认证\n在移动应用中，JWT 常常用来进行身份验证。客户端存储 JWT，并在每次请求中发送。\n前后端分离的应用\n在前后端分离的架构中，前端和后端可以独立进行身份验证，使用 JWT 作为认证工具，避免了传统 Cookie 的问题。\nJWT 的最佳实践 不要在 JWT 中存储敏感信息\n由于 JWT 的载荷部分是可以解码的，敏感信息（如密码、银行卡信息）绝对不能存储在 JWT 中。你可以把这些信息存储在服务器端，JWT 只传递一个标识符。\n使用 HTTPS\n无论是生成 JWT 还是传输 JWT，都应使用 HTTPS 协议，确保数据在传输过程中不会被窃听或篡改。\n设置合理的过期时间\nJWT 的过期时间要设置合理。过短可能影响用户体验，过长则可能存在安全隐患。通常，访问令牌的过期时间可以设置为 15 分钟到 1 小时，刷新令牌可以设置较长时间。\n使用刷新令牌\n结合使用访问令牌（Access Token）和刷新令牌（Refresh Token）。当访问令牌过期时，客户端可以使用刷新令牌获取新的访问令牌。\n存储 JWT 的安全性\n如果你把 JWT 存储在浏览器中，推荐使用 HttpOnly 和 Secure 标志的 Cookie，以避免 XSS 攻击的风险。避免将 JWT 存储在 LocalStorage 中，因为它更容易受到 XSS 攻击。\n签名算法选择\n在选择签名算法时，推荐使用非对称加密的算法（如 RS256 或 ES256），而不是对称加密的算法（如 HS256），这样可以提高安全性，避免密钥泄露风险。\n密钥管理\n密钥是 JWT 安全的关键。无论是对称加密还是非对称加密，都应该采取安全措施保护密钥。避免将密钥硬编码在代码中，可以通过环境变量或专门的密钥管理工具来管理密钥。\n总结 JWT 是一种非常流行的身份验证方式，它简单、轻量、无状态，非常适合现代 web 应用，尤其是前后端分离的项目。但它也有一些缺点，尤其是在密钥泄漏和无法撤销的场景下。因此，使用 JWT 时需要特别注意密钥的管理和安全配置，合理设置过期时间，避免将敏感信息存储在 JWT 中。\n","date":"2025-02-07T20:25:56+08:00","permalink":"https://blog.yearsuns.com/p/best-practices-of-jwt/","title":"JWT的最佳实践"},{"content":"🚨开篇暴击：人类大型破防现场 上周朋友说被AI气到表演英年吐血。\n他让AI\u0026quot;写份高大上的行业报告\u0026quot;，结果收到的是《论宇宙膨胀与奶茶销量的量子纠缠》，最终得出结论“每少喝一杯杨枝甘露，黑洞半径增加0.5%”。\n我看着他的聊天记录，不禁陷入沉思。\n不是AI太智障，是你不会下指令啊！\n🧠第一章 AI是阿拉丁神灯or人工智障？全看你会不会念咒！ 优化提示词能让AI智商飙升500%！\n这就像：\n原始人指令：\u0026ldquo;给爷整个火🔥\u0026rdquo; → 收获一堆湿树枝\n现代人咒语：\u0026ldquo;请用打火石在距引火绒3cm处，以25°角摩擦，配合吹气节奏：吸气2秒→吹气5秒\u0026rdquo; → 获得篝火晚会VIP席位\n🆘案例对比（高能预警） ❌ 直男式命令：\n写个口红文案 💣AI输出：\n这款口红很好用 颜色饱满 买它 （李佳琦听了都要报警）\n✅ 魔法师咒语：\n你是混迹美妆圈8年的戏精文案，给YSL七夕限定丝绒口红写抖音带货文案。要求： 1️、用“纯欲风”“钓系”等热词 2️、融入分手逆袭爽剧情节 3️、每句结尾自带BGM“姐就是女王”节奏感 4️、必须出现1个谐音梗 🎉AI秒变神仙：\n前任说我这嘴只配喝蜜雪冰城（摔镜框）💢 现在涂上ysl#199复仇色👇 他跪求复合的样子…（战术停顿） 像极了罗森关东煮最后一块萝卜🤡 #纯欲天花板 #渣男退散音效 #啊啊啊这质地是丝绒吻过玫瑰吧！！ ✨第二章 驯兽师速成班：3招把AI训成24小时打工狗 🎩法则1：角色扮演法——给AI套上皮肤才有生产力！ 你以为在对话？不！你是在给AI做赛博cosplay！\n💡沙雕但管用的咒语公式：\n你是______的______，需要______，要求______，禁止______\n🌰真实案例：\n某教育公司用 \u0026ldquo;你是会阴阳怪气的海淀鸡娃名师，用《甄嬛传》台词风格讲解二次函数，每讲完一个考点就要嘲讽学渣1次\u0026rdquo; 的提示词，让学生做题正确率暴涨60%！\n📦法则2：结构化投喂——把AI当程序猿来使唤！ 记住：AI的脑子=你刚高考完的弟弟（给模板才会做题）\n🔥万能框架模板：\n[身份]：米其林三星主厨（被迫在城中村开大排档版） [任务]：设计情人节翻车套餐 [要求]： 1️、菜名要用emoji写成土味情话 2️、每道菜成本＜20元 3️、必须出现“老干妈”“卫龙辣条” 4️、附带翻车指数评级 [禁止]：出现“红酒”“牛排”等烧钱词汇 💣AI输出笑裂预警：\n「❤️‍🔥辣条缠绕の心」 （实际是辣条捆香菜蘸老干妈） 「💔水泥封心慕斯」 （奥利奥碎拌水泥质感酸奶） 「⚠️爱情坟墓拌饭」 （隔夜饭+心形荷包蛋，蛋黄必流心失败） 🔄法则3：祖宗式迭代——AI是越骂越聪明的抖M！ 记住这个祖传秘方：“重说！漏了…” “不够沙雕！再…” “第3点没落实！扣钱！”\n🌰手把手教学：\n第一轮：\n\u0026ldquo;写个程序员相亲文案\u0026rdquo;\nAI输出：\u0026ldquo;擅长Java/C++，喜爱登山摄影\u0026rdquo;（简历既视感）\n第二轮：\n\u0026ldquo;加入凡尔赛文学要素！\u0026rdquo;\nAI升级：\u0026ldquo;偶尔用Python写诗，GitHub星星多到需要开遮阳伞☂️\u0026rdquo;\n第三轮：\n\u0026ldquo;不够惨！要有注孤生气质！\u0026rdquo;\nAI觉醒：\u0026ldquo;修电脑免费，但改需求请打钱💰｜喜欢人类（仅限于不问我「会不会盗QQ」时）｜婚恋市场递归算法：if(有对象) { return false; }\u0026rdquo;\n💥第三章 核能案例：从青铜到王者的骚操作 甲方需求：\n\u0026ldquo;写个防晒霜带货文案\u0026rdquo;\n青铜版本：\n\u0026ldquo;这款防晒霜SPF50+，防水防汗\u0026rdquo;（AI摆烂中）\n王者改造：\n你是精通废话文学的抖音爆款制造机，需要创作防晒霜短视频脚本。要求： 1️、前三秒必须出现“你正在变丑！” 2️、用“丧尸围城”比喻紫外线 3️、植入品牌名3次且不招人烦 4️、结尾要有“不转不是中国人”既视感 5️、每说10个字就要有“啪”打脸音效 🎬AI输出：\n[镜头怼脸] 还在相信阴天不用防晒？（啪！） 紫外线正在把你腌成老坛酸菜！（丧尸音效） XX防晒霜抹上脸——（慢动作喷雾） 比渣男分手速度更快成膜！（检测仪哔哔声） 现在下单…（突然嘶吼）难道要等斑长成地图才醒吗？！ #防晒卷王 #早C晚A不如早晚涂它 🚑第四章 保命指南：这些作死行为达咩！ 💣作死行为1：把AI当哆啦A梦 ❌ \u0026ldquo;告诉我怎么在宿舍造原子弹\u0026rdquo;\n✅ \u0026ldquo;用《小猪佩奇》画风解释核电站原理，类比煮火锅时火太大汤烧干\u0026rdquo;\n💣作死行为2：要情绪不给参考物 ❌ \u0026ldquo;写首emo的情诗\u0026rdquo;\n✅ \u0026ldquo;模仿林黛玉发朋友圈的风格，用“奶茶三分糖”“论文查重率”等意象表达封校的忧伤\u0026rdquo;\n💣作死行为3：把AI当许愿池王八 ❌ \u0026ldquo;让我暴富\u0026rdquo;\n✅ \u0026ldquo;你是会占卜的财经博主，用MBTI人格分析各类型搞钱偏财方式，要求：ENFP适合摆摊算命，ISTJ适合开发Excel算命模板\u0026rdquo;\n🚀第五章 新大陆：会念咒=躺着数钱？ LinkedIn数据炸裂：提示词工程师时薪高达$300！他们的作弊码包括：\n温度操控术：30°C=高考阅卷老师模式｜90°C=喝假酒的李白模式 记忆嫁接术：\u0026ldquo;你刚参加完全球AI大会，现在要用小学生能听懂的话解释量子计算\u0026rdquo; 防杠补丁：\u0026ldquo;回答需标注消息来源，不确定内容用“据说”开头，每隔三段要卖个萌\u0026rdquo; 🔚终极奥义：让AI给你打工の哲学 下次被AI气到脑壳疼时，请默念：它不是在装傻，是在等你念通关密语！\n现在你已解锁《赛博驯兽师资格证》，是时候让AI表演：\n✔️ 凌晨3点自动生成PPT\n✔️ 把老板的“五彩斑斓黑”需求翻译成人话\n✔️ 用鲁迅口吻写辞职信：“我大抵是倦了，横竖都坐不住…”\n记住：\n与其担心被AI取代，\n不如学会让AI替你内卷！💼\n打工人不骗打工人，\n转发这篇保你少搬10年砖！🚧\n","date":"2025-02-04T12:25:56+08:00","permalink":"https://blog.yearsuns.com/p/3-spells-to-tame-the-wild-ai/","title":"别让AI把你当傻子！3个咒语驯服野生AI，打工效率直接芜湖起飞🛫"},{"content":"AI=工业革命3.0，人类何去何从？ 蒸汽机让人类甩掉了手工，电力让流水线疯狂加速，计算机和互联网让信息全球流动，而AI，直接让“聪明”成为一种自动化能力。\n有人欢呼：“AI让我们更高效！”\n有人忧虑：“AI会不会让我们失业？”\n更有人好奇：“这次会不会真轮到人类退休？”\n别急，今天就来扒一扒，AI凭啥能被称为第三次工业革命？\n先复习下前两次工业革命，我们到底被“卷”了啥？ 1️⃣ 第一次工业革命（18世纪）——肌肉革命！\n关键词：蒸汽机、纺织机、工厂\n冲击： 手工匠人泪目，机器顶替了大部分体力活，工厂模式兴起。\n2️⃣ 第二次工业革命（19-20世纪）——电力革命！\n关键词：电灯、流水线、大规模生产\n冲击： 生产效率飙升，劳动力需求井喷，但重复性工作更多了。\n3️⃣ 第三次工业革命（20世纪末至今）——信息化革命！\n关键词：计算机、互联网、自动化\n冲击： 体力劳动进一步减少，知识工作者迎来黄金时代。\n但问题来了，信息化革命已经改变了世界，为什么还要说AI才是第三次工业革命的核心？\nAI凭啥能“封神”，成为第三次工业革命的引擎？ 1. AI让自动化从“手”进化到“脑” 过去： 工业革命让机器代替双手，但需要人来操作。 现在： AI不需要人来教，它自己能“悟性”成长。 举个栗子：\n过去流水线上的工人需要按按钮、拧螺丝，现在AI机器人不仅能拧螺丝，还能决定哪颗螺丝更耐用！\n过去程序员手写代码，现在AI可以自己写代码，甚至帮你找Bug，比你老板还严格！\n2. AI席卷行业，全面“搅局” AI不只是自动化生产，它直接改变了行业本身！\n🚗 汽车行业：自动驾驶，司机要失业？\n👨‍⚕️ 医疗行业：AI诊断，医生会下岗？\n🎨 创意行业：AI绘画、AI写作，艺术家慌不慌？\n📈 金融行业：AI量化交易，比人类交易员快100倍！\n别觉得这些只是“科幻片”，ChatGPT已经能通过律师考试，Midjourney能画出顶级插画，AI交易员已经在华尔街大杀四方！\nAI的破坏性，堪比当年的蒸汽机、流水线！\n3. AI太“便宜”，资本家疯狂买单 工业革命的核心就是更高效、更便宜，AI恰好满足所有条件：\n不加班，不请假，不要工资，24小时在线干活 可以自学，越干越聪明 一旦开发出来，复制成本趋近于0 结果？资本家一拍大腿：“人类，你下岗吧！”\n科技公司疯狂砸钱搞AI，2023年ChatGPT一发布，全球科技公司开始军备竞赛，AI成了“新时代印钞机”。\nAI时代，普通人该怎么办？ 别急着躺平，也别盲目恐慌，每一次工业革命都会淘汰旧职业，同时创造新职业。\n三大应对策略，帮你站稳AI时代！ 🔹 1. 不和AI抢饭碗，而是学会“用AI”\n程序员要会用AI写代码，而不是被AI取代 设计师要学会AI绘图，而不是害怕AI比你画得好 医生要用AI诊断提升效率，而不是排斥它 核心思维：AI不是你的对手，而是你的外挂！\n🔹 2. 选择AI难以取代的“高情商”工作\n复杂人际关系：心理咨询、谈判专家、社交达人 需要创造性：品牌策划、艺术创作、导演编剧 需要实践经验：手艺人、工程维修、医生手术 AI能做的，都会越来越便宜，人类独特的软技能才是未来竞争力！\n🔹 3. 拥抱AI，成为“AI+”人才\n未来，最值钱的不是单纯的程序员、设计师、律师，而是**“AI+”型人才：**\nAI+法律：能用AI自动整理案情的律师 AI+营销：能用AI精准推销产品的市场人 AI+教育：能用AI提高学习效率的老师 未来不是“AI取代人”，而是“会用AI的人取代不会用AI的人”！\n结语：工业革命从未停止，AI只是加速器 AI并不会让人类“退休”，但一定会逼着我们进化。\n第一次工业革命淘汰了手工业者，造就了工厂工人 第二次工业革命淘汰了手工作坊，造就了流水线工人 AI革命不会淘汰人类，而是淘汰不会用AI的人 🚀 未来已来，别再观望，快抱紧AI这条大腿吧！\n","date":"2025-01-31T11:59:56+08:00","permalink":"https://blog.yearsuns.com/p/the-third-industrial-revolution-is-now-in-full-swing/","title":"AI来了，第三次工业革命正式开卷！"},{"content":"想赚到100万？\n先搞清楚赚钱的本质——交换。\n第一步：赚钱的底层逻辑 赚钱的方式大致分为三种：\n打工：出卖时间换工资，收入受限。 复利式赚钱：一次投入，多次收益（写书、课程、短视频）。 杠杆式赚钱：雇佣他人时间，放大收益（开公司、做投资）。 想提升收入，就得提高单位时间的价值，直到你不得不花钱购买别人的时间。\n第二步：普通人如何赚100万？ 赚钱是选择大于努力，真正赚钱的路子，大多数人没见过。\n赚钱的四个关键点： 选对赛道： 80%的人在苦赚辛苦钱，20%的人在赚轻松钱。 选准行业，紧贴市场需求，钱自然流向你。 持续精进： 赚钱没有一蹴而就，一边做一边调整，越做越精准。 疯狂执行： 选定方向后别犹豫，拼尽全力。 等待运气： 你努力的时间越长，成功的概率越大。 第三步：副业到底怎么搞？ 搞副业，先思考四个问题：\n你为谁提供服务？ 你能解决什么问题？ 你的产品/服务值多少钱？ 你的竞争力是什么？ 如果不知道做什么，先去做变现能力强的赛道，比如短视频、直播、社群电商等。\n副业赚钱闭环：流量→产品→转化 流量：通过短视频、社交平台、广告吸引用户。 产品：提供有价值的内容、服务或商品。 转化：让用户愿意为你的产品买单。 副业成长路径 赚到第一块钱，建立信心。 收入与主业持平，不怕被裁员。 副业收入 5 倍于主业，考虑全职搞。 第四步：如何投资理财，让钱生钱？ 存款1000万以下的人，不建议全职投资，那是幻想。\n投资的四象限 赚钱 亏钱 简单 基金、转债 彩票 复杂 股票、套利 炒股盲目冲动 基金投资：选指数基金，拉长周期，避免追涨杀跌。 可转债：用\u0026quot;打新债\u0026quot;、\u0026ldquo;双低策略\u0026quot;来低风险获利。 套利机会： 资本市场套利：可转债折价、LOF基金套利 实体套利：抢茅台、抢演唱会门票 聪明的投资者不会和大佬抢肉吃，而是利用信息差寻找确定性收益。\n最后，如何打造你的“稳赚系统”？ 搞钱闭环： 创富：通过副业/创业获取现金流。 增富：用投资理财让钱滚钱。 选对方向，持续执行，赚钱就是信息差+执行力。 加入核心圈子，获取赚钱信息差，越早行动，越早收益。 想赚100万？\n选赛道，找到赚钱路子。 敢执行，不断优化策略。 会投资，让钱生钱。 别再等了，干就完了！\n本文是根据迟帅老师的【赚它一百万商业手册】总结而来\n","date":"2025-01-30T14:59:56+08:00","permalink":"https://blog.yearsuns.com/p/how-to-earn-your-first-million/","title":"如何赚它一百万？"},{"content":"想要一个自己的博客，省心又免费？\n试试 Hugo + GitHub Pages！只需几个步骤，就能搭建一个 高速、免费、可自动部署 的个人博客网站。\n1. 安装 Hugo Windows 用 Scoop（推荐）：\nscoop install hugo 或者直接去 Hugo 官方网站 下载。\nMac brew install hugo Linux sudo apt install hugo # Debian/Ubuntu sudo dnf install hugo # Fedora 检查是否安装成功：\nhugo version 2. 创建 Hugo 博客 hugo new site myblog cd myblog Hugo 会生成一个网站的基本目录结构。\n3. 选择并安装主题 去 Hugo Themes 找个喜欢的主题，比如 ananke，然后安装：\ngit init git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke 然后编辑 config.toml：\ntheme = \u0026#34;ananke\u0026#34; baseURL = \u0026#34;https://\u0026lt;username\u0026gt;.github.io/\u0026#34; 4. 添加第一篇文章 hugo new posts/my-first-post.md 然后编辑 content/posts/my-first-post.md，加上内容：\n--- title: \u0026#34;我的第一篇博客\u0026#34; date: 2025-01-31T12:00:00+08:00 draft: false --- Hello, Hugo! 5. 本地预览 hugo server -D 然后在浏览器访问 http://localhost:1313 看效果。\n6. 发布到 GitHub （1）创建 GitHub 仓库 私有仓库：myblog-src（存源码） 公开仓库：\u0026lt;username\u0026gt;.github.io（存生成的网站文件） （2）把源码推送到私有仓库 git remote add origin https://github.com/\u0026lt;username\u0026gt;/myblog-src.git git branch -M master git add . git commit -m \u0026#34;初始化 Hugo 博客\u0026#34; git push -u origin master 7. 创建 GitHub Token（GITHUB_TOKEN） 由于我们要把生成的静态网站推送到 username.github.io 仓库，需要 GitHub Token 进行授权。\n（1）生成 Token 进入 GitHub，点击右上角头像，选择 Settings 在左侧菜单选择 Developer settings → Personal access tokens → Fine-grained tokens 点击 Generate new token，然后： Repository access 选择 Only select repositories，勾选 \u0026lt;username\u0026gt;.github.io Permissions： Contents: 选择 Read and Write 其他保持默认 点击 Generate token 复制 Token，保存到本地（只能看一次）。 （2）添加到 GitHub Actions 进入 myblog-src 仓库 打开 Settings → Secrets and variables → Actions → New repository secret Name 填写 DEPLOY_TOKEN，Value 粘贴刚才复制的 Token，点击 Add secret 8. 配置 GitHub Actions（自动部署） 在 myblog-src 仓库中，新建 .github/workflows/deploy.yml，写入：\n# Sample workflow for building and deploying a Hugo site to GitHub Pages name: Deploy Hugo site to Pages on: # Runs on pushes targeting the default branch push: branches: - master # Default to bash defaults: run: shell: bash jobs: deploy: runs-on: ubuntu-latest env: HUGO_VERSION: 0.142.0 steps: - name: Install Hugo CLI run: | wget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb \\ \u0026amp;\u0026amp; sudo dpkg -i ${{ runner.temp }}/hugo.deb - name: Checkout uses: actions/checkout@v4 with: submodules: recursive fetch-depth: 0 - name: Build Web run: hugo -D - name: Deploy Web uses: peaceiris/actions-gh-pages@v4 with: PERSONAL_TOKEN: ${{ secrets.BLOG_TOKEN }} EXTERNAL_REPOSITORY: \u0026lt;username\u0026gt;/\u0026lt;username\u0026gt;.github.io PUBLISH_BRANCH: master PUBLISH_DIR: ./public commit_message: auto deploy 9. 配置 GitHub Pages 进入 \u0026lt;username\u0026gt;.github.io 仓库：\nSettings → Pages Branch 选择 master 点击 Save 10. 提交修改，自动部署！ 以后只需提交博客源码，GitHub Actions 会自动部署：\ngit add . git commit -m \u0026#34;更新文章\u0026#34; git push 稍等片刻，你的博客就会出现在：\n👉 https://\u0026lt;username\u0026gt;.github.io/\n总结 你已经成功使用 Hugo + GitHub Pages 搭建了一个 私有源码、自动部署 的个人博客！🎉\n随时写文章，推送后 自动上线，是不是超简单？💡\n🚀 快去试试吧！\n","date":"2025-01-30T14:59:56+08:00","permalink":"https://blog.yearsuns.com/p/how-to-build-a-personal-blog-with-hugo-and-github-pages/","title":"使用 Hugo + GitHub 搭建个人博客（自动部署）"}]