[{"content":" XYK means: put a pair of assets into a “pool”, and require that the product of the two asset amounts always stays equal: x * y = k. All swaps must follow this rule, and therefore price, slippage, yield and risk all naturally come from this formula.\nLet’s walk through the math step by step.\n1. Traditional Trading: Why Do We Need an Order Book? In traditional exchanges, the core mechanism is the order book:\nA places a buy order at 100 for 1 ETH B places a sell order at 101 for 2 ETH The system matches orders and completes the trade This design has several characteristics:\n1. Requires professional market makers Without someone providing orders, ordinary traders cannot trade Market makers must watch the market and continuously update orders 2. Requires a centralized matching engine Run by the exchange You have to trust the intermediary 3. Ordinary users cannot participate in market-making easily Hard to provide liquidity Most profits go to institutions For blockchain, which emphasizes open participation, this is too centralized.\n2. AMM: Turning Market Making into a Liquidity Pool The innovation of AMM (Automated Market Maker) is transforming trading from order matching into a liquidity pool that anyone can join.\nA liquidity pool holds two assets (e.g., ETH and USDT) and follows:\nx * y = k This is the XYK constant product market maker model.\nWhen someone buys ETH with USDT, ETH decreases and USDT increases, while keeping the product constant.\nAMM replaces the order book:\nno buy/sell orders no professional market makers no centralized matching engine anyone can join So essentially:\nAMM = liquidity pool + mathematical rule\nPrice, slippage and liquidity depth all follow from this.\n3. How Is Price Determined? Example:\nPool state:\nETH x = 100 USDT y = 10000 Then the price is naturally:\nprice = y / x = 10000 / 100 = 100 USDT Key points:\nPrice is not quoted manually Price changes automatically with pool state External arbitrage aligns the pool price to market price So in AMM:\nPrice = asset ratio in pool\n4. How Do Trades Change Price? Initial State x = 100 ETH y = 10000 USDT k = 1,000,000 P₀ = 100 A user wants to spend 1000 USDT to buy ETH.\nTransaction rule Must satisfy x * y = k before and after the swap\nAfter the swap User adds:\nΔy = +1000 y₂ = 11000 x₂ = 1,000,000 / 11000 ≈ 90.909 Δx ≈ 9.091 Average price ≈ 110 Final price ≈ 121\nYou observe:\nAverage paid ≈ 110 Final price ≈ 121 Initial price = 100 That feeling of:\n“I buy → the price jumps!”\nThat is slippage.\n5. Slippage: Not a Fee, But Price You Push Higher Slippage is not a fee:\nYou moved the price by trading You are literally buying along the curve from cheap → expensive. Bigger trades cause more slippage.\n6. Why Bigger Pools Have Lower Slippage? Compare:\nSmall pool: 100 / 10000 Price moves 100 → 121\nBig pool: 1000 / 100000 Price moves 100 → 102\nConclusion:\nMore liquidity → milder price curve → lower slippage\nIt\u0026rsquo;s like:\na basin vs. a lake adding a bucket changes the level much more in a basin 7. What Exactly Is Liquidity? Liquidity = actual asset amounts in the pool\nmore liquidity → flatter curve → stable prices less liquidity → steep curve → price impact increases Anyone can provide liquidity, therefore:\nMarket-making becomes open\n8. How Do You Join as a Liquidity Provider? Pool state:\nx = 100 ETH y = 10000 USDT Price = 100 USDT/ETH\nTo add liquidity, you must deposit proportionally:\nadd 1 ETH plus 100 USDT Otherwise you change the price.\nYou receive LP tokens representing your share.\nWhen you withdraw, you take a share of the pool, not exactly what you put in.\nThis is important for understanding impermanent loss.\n9. How Do LPs Earn Fees? Each trade pays a small fee (e.g., 0.3%), and this fee:\ndoes NOT go to “the platform” goes into the pool distributed to LPs Think of it as:\nTraders use your assets, and you charge toll fees\nLP earnings:\ntrading fees token incentives 10. Impermanent Loss LPs earn fees but face impermanent loss.\nExample pool:\n1 ETH + 100 USDT You add:\n1 ETH + 100 USDT Pool:\n2 ETH + 200 USDT (You own 50%) If ETH price falls, the pool becomes:\n4 ETH + 100 USDT You withdraw:\n2 ETH + 50 USDT = 100 USDT value You deposited value: 200 You withdraw value: 100\nYou lose value because:\npool moved toward the depreciating asset arbitrage takes the increasing asset out The pool automatically rebalances toward cheaper assets.\n11. What Problems Does XYK Solve? No order book Price determined algorithmically Anyone can become a market maker Infrastructure becomes public and open 12. Limitations \u0026amp; Evolution XYK drawbacks Large slippage → specialized stable-swap curves (Curve) Poor capital efficiency → concentrated liquidity (Uniswap v3) Impermanent loss → LP bears volatility risk Still:\nXYK is the entrance door to AMM design\nUnderstanding XYK makes everything else easier.\n13. The One Simple Formula Back to:\nx * y = k From this follows:\nprice: P = y / x slippage liquidity depth LP revenue impermanent loss XYK is the F = ma of DeFi:\ndeceptively simple, yet the foundation of decentralized trading.\n","date":"2025-07-16T14:59:56+08:00","permalink":"https://yearsuns-github-io.vercel.app/en/p/the-fundamental-principles-of-the-xyk-model/","title":"The Fundamental Principles of the XYK Model"},{"content":"1. Introduction: Passwords Are the Last Line of Defense in the Digital World In the entire ecosystem of internet security, passwords are the most common yet also the most fragile component. Almost all services we use daily—email, online banking, social platforms, games, forums—rely on passwords to authenticate user identity.\nA password is essentially a weak credential:\nIt cannot prove who the user really is—it only proves that they “know a certain secret.” Once this secret is leaked, an attacker can completely impersonate you. Modern cyberattacks are frequent and diverse. A single ordinary password leak often results in multiple accounts across different platforms being compromised. To defend against these threats, we must strengthen both the transmission stage and the storage stage.\nThis article builds from fundamental concepts and gradually develops a complete, modern password security system.\n2. Why Are Passwords So Dangerous? At first glance, a password is just a string composed of characters. But the damage caused by a leaked password is far more severe than it seems, mainly for two reasons.\n2.1 Risk 1: Leakage During Transmission From the moment a user enters a password until it reaches the server, the data passes through:\nThe browser Local DNS resolution OS network stack Routers ISP backbone Server load balancers If any part of this chain is compromised, the password could be intercepted.\nIn theory, HTTPS solves the “eavesdropping problem.” But reality is more complex. Common risks include:\nMalware installing fake root certificates (classic MITM strategy) Internal corporate/school networks performing TLS inspection Public Wi-Fi conducting ARP spoofing and re-signing HTTPS certificates Browser extensions injecting malicious scripts to read user input “Network optimization” software adding hidden interception modules Enterprise gateways performing SSL inspection (legal but unsafe) In other words:\nYou cannot assume the user’s device or network environment is always secure.\nTherefore, there is room to improve the security of transmission.\n2.2 Risk 2: Server-side Leakage Most leaks occur on the server side. Common scenarios include:\nDatabase breaches (most common) Passwords accidentally printed in logs Developers outputting passwords during debugging Unencrypted backups mistakenly exposed to the public Third-party monitoring tools capturing sensitive fields Vulnerabilities (SQL injection, RCE) exposing the database Internal misuse of privileges by operations staff If the server stores plaintext passwords, the consequences are catastrophic:\nAll user passwords are exposed Accounts on other websites are compromised due to password reuse If attackers access a user’s email, the impact escalates further Therefore, the server must ensure that even if a breach occurs, attackers cannot obtain the real passwords.\n3. How Should Passwords Be Safely Transmitted Over the Internet? 3.1 The Most Straightforward Approach: Send the Password Directly Over HTTPS This is the default method used by most websites today:\nBrowser ——HTTPS——\u0026gt; Server Advantages:\nSimple Mature Fast Compatible with everything The drawback is:\nIt places all risk on the reliability of TLS.\nIf TLS is compromised by a MITM attack, the password is exposed.\nThus, some propose hashing the password on the client side first.\n4. Front-end Hashing: Risks Reduced and Risks Not Reduced The core idea of front-end hashing is:\nEven if the transmission is intercepted, the attacker does not get the real password.\nAssume:\nP = user password H1 = hash(P) The browser sends H1 instead of P.\n4.1 What Can Front-end Hashing Protect Against? Prevents MITM from obtaining the real password Prevents plaintext password leakage through server logs/monitoring Attackers cannot use H1 to log in to the user’s accounts on other websites Even if users reuse passwords elsewhere, a breach of your site won’t cascade to others (very important) The server never touches plaintext passwords (a simple form of zero-knowledge authentication) Front-end hashing provides:\n“Even if your website is compromised, attackers still cannot learn users’ real passwords for other services.”\nTraditional approaches cannot offer this.\n4.2 What Can Front-end Hashing Not Protect Against? Attackers can directly use H1 to log in to your website (you treat it as the credential) Keyloggers / infected devices still capture P Hashes without challenge are vulnerable to replay attacks HTTPS is still required—hashes themselves must be encrypted In short:\nFront-end hashing reduces damage but does not eliminate risk.\n4.3 Is Front-end Hashing Necessary? In practice, it is an optional but clearly beneficial enhancement.\nWhen implemented properly (with challenges to prevent replay), front-end hashing creates a dual defense:\nTLS ensures transport security Hashing reduces cross-site password reuse impact High-security systems (banks, enterprise platforms, developer services) often use such mechanisms.\n5. How Should Servers Store Passwords? Now to the core of password engineering:\nPasswords must never appear in plaintext—even inside the server.\nIndustry standards involve three key elements:\nHash Salt Slow hash 5.1 Hashing: Making It Irreversible A good hashing function must:\nHave extremely low collision probability Change output drastically when input changes slightly (avalanche effect) Make it impossible to reverse the input Servers store:\nH = hash(P) If the database leaks, attackers cannot directly obtain the password.\n5.2 Salt: Preventing Rainbow Tables and Mass Cracking Without salt, users with the same weak passwords produce identical hashes. Attackers can:\nUse precomputed rainbow tables Test common passwords once to crack many accounts By adding a random salt:\nH = hash(P + salt) Now:\nTwo users with “123456” have completely different hashes Rainbow tables become useless Attackers must brute-force each user individually (massively increasing cost) Salt must be:\nLong enough (≥16 bytes) Random (CSPRNG) Unique per user Stored in plaintext (not encrypted) 5.3 Slow Hashing: Truly Increasing the Cost of Attacks Algorithms like SHA256 are far too fast. Modern GPUs can compute billions of SHA256 hashes per second.\nMeaning:\nEven with salt, SHA256-stored passwords can often be cracked quickly.\nThus, we must use slow hashing algorithms designed specifically for password storage:\nAlgorithm Characteristics bcrypt Classic, mature scrypt GPU-resistant, high memory use Argon2 (recommended) Winner of password hashing competition; tunable CPU/memory/parallelism Slow hashing is not about “stronger hashing”; it\u0026rsquo;s about:\nMaking each guess expensive so attackers cannot perform massive brute-force attacks.\nLogin delays are negligible:\nUsers log in infrequently Each slow-hash costs only tens of milliseconds Attackers cannot scale up computations the same way 6. Dual Protection: Front-end Hash + Back-end Slow Hash Combined:\nP → H1 = hash1(P) → (transmission) → H2 = bcrypt(H1 + salt) Dual-layer benefits:\nMITM capturing H1 cannot use it on other sites Database leaks revealing H2 are still hard to crack Server never touches plaintext passwords Logs and monitoring systems cannot leak P This “front-end hash + back-end slow hash” model is used in high-security environments to reduce cascade risks.\n7. The Replay Attack Problem of Front-end Hashing and Its Solution If front-end hashing is simply:\nH1 = hash(P) An attacker who intercepts H1 can replay it indefinitely—almost identical to stealing the real password.\nSolution: Use a random challenge. 7.1 Complete Workflow User opens login page The server generates a challenge:\nchallenge = random string Browser computes:\nH1 = hash(P + challenge) Server verifies:\nbcrypt(H1 + salt) == stored_hash 7.2 Benefits H1 is different every time (challenge varies) Intercepted H1 cannot be reused MITM value decreases Server does not need to store challenge—just verify once and discard 7.3 Common Engineering Issues Challenge must not be cached (use no-cache) Must be long enough (≥16 bytes) Front-end must use secure hash (SHA256 or higher) Still requires HTTPS (challenge itself can be intercepted otherwise) 8. Additional Important Practices (Often Overlooked) 8.1 Never Email Users Their Passwords Sending a new password via email is extremely dangerous. Correct process:\nSend a password reset link Link contains a one-time token User must set a new password 8.2 Do Not Allow Weak Passwords Weak passwords are exponentially easier to crack:\n123456 password qwerty User phone numbers User birthdays Use:\nBlacklists of common passwords (top 10k) Length policies (≥12 chars) Encouragement of password managers 8.3 Multi-factor Authentication (MFA / 2FA) Passwords are only the first layer. A second factor dramatically reduces attack success rates:\nTOTP (Google Authenticator) SMS codes (weaker, but still useful) Hardware keys (FIDO2 / U2F) 8.4 Account Protection Features Lockouts after multiple failed attempts Suspicious-login email alerts Unusual IP/UA verification steps Recent login activity logs for user review 8.5 Password Breach Checks (HIBP API) Many large websites check whether:\nA user\u0026rsquo;s chosen password appears in known breach databases (like HaveIBeenPwned) This significantly reduces risk from weak password reuse.\n9. Goals of a Modern Password Security System With all steps combined, a modern password system should ensure:\n9.1 Secure Transmission Use HTTPS Optional front-end hashing to prevent cascading leaks Challenge-based anti-replay 9.2 Secure Storage Never store plaintext passwords Unique salt per user Use slow hashing algorithms 9.3 Account Protection Strong password policies MFA Anomaly detection Password leak comparison No sensitive info in logs The final objective:\nEven if the entire server is compromised, attackers still cannot obtain any user\u0026rsquo;s real password.\n","date":"2025-06-29T14:59:56+08:00","permalink":"https://yearsuns-github-io.vercel.app/en/p/how-passwords-should-be-safely-transmitted-and-stored/","title":"How Passwords Should Be Safely Transmitted and Stored"}]